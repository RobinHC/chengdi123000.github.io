<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[FEniCS在docker中的使用]]></title>
      <url>/2018/01/07/FENICS%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>FEniCS在docker中的使用</p>
<a id="more"></a>
<h1 id="FEniCS在docker中的使用"><a href="#FEniCS在docker中的使用" class="headerlink" title="FEniCS在docker中的使用"></a>FEniCS在docker中的使用</h1><p>有限元是计算方法里很重要的一部分，目前有限元软件很多，不开源的像ANSYS, ABAQUS, Nastran, COMSOL都非常强大，开源的详见比较列表<sup><a href="#fn_1" id="reffn_1">1</a></sup>。</p>
<p>开源的FEM里有几个比较有意思：</p>
<ul>
<li>FEniCS 是FEM解PDE的程序包，学术货，语言层次很高级，流程上应用了代码自动生成技术。</li>
<li>Code-Aster是法国货，法国电力公司EDF开发的，所以有的代码注释是用法语写的，偏向结构和热机械分析。</li>
<li>Deal II是密歇根大学的开发的，官方教程比较齐全，并行能到了147k核。</li>
<li>Firedrake，FEM解PDE的程序包，和FEniCS有合作（2015 Wilkinson奖，DOLFIN-adjoint项目），更新，更现代软件工程化。</li>
</ul>
<blockquote id="fn_1">
<sup>1</sup>. <a href="http://htmlpreview.github.io/?https://github.com/kostyfisik/FEA-compare/blob/master/table.html" target="_blank" rel="noopener">FEM-compare-table</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<p>个人觉得FENICS更好玩一些。</p>
<h2 id="FEniCS的结构"><a href="#FEniCS的结构" class="headerlink" title="FEniCS的结构"></a>FEniCS的结构</h2><p>FENICS的结构</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/a/aa/Fenics-map.png" alt=""></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li><a href="https://bitbucket.org/fenics-project/" target="_blank" rel="noopener">FEniCS</a>: <strong>F</strong>inite <strong>E</strong>lement <strong>ni</strong>ce <strong>C</strong>omputational <strong>S</strong>oftware，关于这个名词参考网页<sup><a href="#fn_2" id="reffn_2">2</a></sup> </li>
<li><a href="https://bitbucket.org/fenics-project/dolfin/" target="_blank" rel="noopener">DOLFIN</a>: C++/Python库，<a href="http://www.logg.org/anders/" target="_blank" rel="noopener">Anders Logg</a> 和<a href="http://www.csc.kth.se/~jhoffman/Johan_Hoffman_KTH_Home/Home.html" target="_blank" rel="noopener">Johan Hoffman</a>写的，用于描述网格、求解器和双线性形式。</li>
<li><a href="https://bitbucket.org/fenics-project/fiat" target="_blank" rel="noopener">FIAT</a>: Finite element Automatic Tabulator, Python库，自动生成基函数表，但只针对区间、三角形和四面体。</li>
<li><a href="https://bitbucket.org/fenics-project/mshr" target="_blank" rel="noopener">mshr</a>: FEniCS的网格生成模块。只能生成三角网格。</li>
<li><a href="https://bitbucket.org/fenics-project/dijitso" target="_blank" rel="noopener">dijitso</a>: python模块，用于即时生成动态链接库（<em>.so, </em>.dll）</li>
<li><a href="https://bitbucket.org/fenics-project/testing" target="_blank" rel="noopener">Bamboo</a>: FEniCS的自动化测试系统。</li>
<li><a href="https://bitbucket.org/fenics-project/ffc" target="_blank" rel="noopener">FFC</a>: FEniCS Form Compiler, 代码生成软件包，可以生成DOLFIN可以调用的底层代码；</li>
<li><a href="https://bitbucket.org/fenics-project/ufl" target="_blank" rel="noopener">UFL</a>: Unified Form Language，FFC的输入的语言格式，一种特定领域的语言（domain specific language, DSL）。</li>
<li><a href="https://bitbucket.org/fenics-project/ufc-deprecated" target="_blank" rel="noopener">UFC</a>: Unified Form-assembly Code，一个c++界面，可以利用底层函数组装有限元的变分形式，2014年2月起已经被废弃，并被FFC取代。</li>
<li><a href="https://bitbucket.org/fenics-project/instant" target="_blank" rel="noopener">Instant</a>: python模块，可以嵌入c/c++代码，但是它在2017.2版本之后就退休（retire）了。</li>
<li><a href="https://bitbucket.org/fenics-project/dorsal-retired" target="_blank" rel="noopener">Dorsal</a>: 一个编译FEniCS的脚本集合，已退休，由cmake取代。</li>
<li><a href="https://www.featool.com/" target="_blank" rel="noopener">FEATool</a>: Finite Element Analysis multiphysics Toolbox，基于Matlab/Octave的有限元分析环境，外部接口包括网格（DistMesh, gmsh, triangle）和求解器（FeatFlow, FEniCS）。</li>
<li><a href="https://www.numfocus.org/" target="_blank" rel="noopener">NumFOCUS</a>: 是美国的一个非盈利组织（ 所谓501(c)(3)组织，免税），致力于促进世界级创新开源的科学计算。</li>
</ul>
<blockquote id="fn_2">
<sup>2</sup>. <a href="https://answers.launchpad.net/fenics/+question/204935" target="_blank" rel="noopener">Origin of the name “FEniCS”</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<h2 id="FEniCS的docker安装"><a href="#FEniCS的docker安装" class="headerlink" title="FEniCS的docker安装"></a>FEniCS的docker安装</h2><p>安装docker不详叙，可参考<a href="https://chengdi123000.github.io/2018/01/05/OpenFOAM%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">OpenFOAM在docker中的使用</a>中的前面部分。</p>
<p>启动docker engine服务之后，在<code>Docker Quickstart Terminal</code>或者<code>powershell</code>中输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkdir fenics</span><br><span class="line">cd fenics</span><br><span class="line"></span><br><span class="line">// -ti: 分配tty和进行交互（interaction）</span><br><span class="line">// -v: 映射文件夹$(pwd)到docker 镜像中的/home/fenics/shared</span><br><span class="line">// -w: docker镜像中的运行目录为/home/fenics/shared</span><br><span class="line">// quay.io是docker 镜像服务商</span><br><span class="line">// 如果是单纯下载镜像，可以运行：</span><br><span class="line">// docker pull quay.io/fenicsproject/stable</span><br><span class="line">docker run -ti -v $(pwd):/home/fenics/shared -w /home/fenics/shared quay.io/fenicsproject/stable:current</span><br></pre></td></tr></table></figure>
<p>然后就自动下载安装好了。并且进入了如下shell界面：</p>
<p><img src="/images/docker_FEniCS.PNG" alt="docker_FEniCS"></p>
<p>更详细的使用可以参考官网的容器教程：<sup><a href="#fn_3" id="reffn_3">3</a></sup></p>
<blockquote id="fn_3">
<sup>3</sup>. <a href="https://fenics-containers.readthedocs.io/en/latest/" target="_blank" rel="noopener">FEniCS in Docker</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<h2 id="FEniCS在docker中使用"><a href="#FEniCS在docker中使用" class="headerlink" title="FEniCS在docker中使用"></a>FEniCS在docker中使用</h2><h3 id="最简单版"><a href="#最简单版" class="headerlink" title="最简单版"></a>最简单版</h3><p>生成以下文件：</p>
<p><code>my-code.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dolfin <span class="keyword">import</span> *</span><br><span class="line">print(<span class="string">"Running FEniCS..."</span>)</span><br><span class="line">mesh = UnitSquareMesh(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">V = FunctionSpace(mesh, <span class="string">"P"</span>, <span class="number">1</span>)</span><br><span class="line">u = interpolate(Expression(<span class="string">'1 + x[0]*x[0] + 2*x[1]*x[1]'</span>, degree=<span class="number">2</span>), V)</span><br><span class="line"><span class="keyword">with</span> XDMFFile(<span class="string">"f.xdmf"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(u)</span><br></pre></td></tr></table></figure>
<p>由于进行了文件夹映射，所以可以直接放到<code>$(pwd)</code>中 ，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cat my-code.py</span><br><span class="line"><span class="comment"># from dolfin import *</span></span><br><span class="line"><span class="comment"># print("Running FEniCS...")</span></span><br><span class="line"><span class="comment"># mesh = UnitSquareMesh(10, 10)</span></span><br><span class="line"><span class="comment"># V = FunctionSpace(mesh, "P", 1)</span></span><br><span class="line"><span class="comment"># u = interpolate(Constant(1.0), V)</span></span><br><span class="line"><span class="comment"># with XDMFFile("f.xdmf") as f:</span></span><br><span class="line"><span class="comment">#     f.write(u)</span></span><br><span class="line">python3 my-code.py</span><br><span class="line"><span class="comment"># Running FEniCS...</span></span><br><span class="line"><span class="comment"># Calling DOLFIN just-in-time (JIT) compiler, this may take some time.</span></span><br><span class="line"><span class="comment"># --- Instant: compiling ---</span></span><br><span class="line">cat f.xdmf</span><br><span class="line"><span class="comment"># &lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="comment"># &lt;Xdmf Version="3.0"&gt;</span></span><br><span class="line"><span class="comment">#   &lt;Domain&gt;</span></span><br><span class="line"><span class="comment">#     &lt;Grid Name="mesh" GridType="Uniform"&gt;</span></span><br><span class="line"><span class="comment">#       &lt;Topology NumberOfElements="200" TopologyType="Triangle" NodesPerElement="3"&gt;</span></span><br><span class="line"><span class="comment">#         &lt;DataItem Dimensions="200 3" NumberType="UInt" Format="HDF"&gt;f.h5:/Mesh/mesh/topology&lt;/DataItem&gt;</span></span><br><span class="line"><span class="comment">#       &lt;/Topology&gt;</span></span><br><span class="line"><span class="comment">#       &lt;Geometry GeometryType="XY"&gt;</span></span><br><span class="line"><span class="comment">#         &lt;DataItem Dimensions="121 2" Format="HDF"&gt;f.h5:/Mesh/mesh/geometry&lt;/DataItem&gt;</span></span><br><span class="line"><span class="comment">#       &lt;/Geometry&gt;</span></span><br><span class="line"><span class="comment">#       &lt;Attribute Name="f_6" AttributeType="Scalar" Center="Node"&gt;</span></span><br><span class="line"><span class="comment">#         &lt;DataItem Dimensions="121 1" Format="HDF"&gt;f.h5:/VisualisationVector/0&lt;/DataItem&gt;</span></span><br><span class="line"><span class="comment">#       &lt;/Attribute&gt;</span></span><br><span class="line"><span class="comment">#     &lt;/Grid&gt;</span></span><br><span class="line"><span class="comment">#   &lt;/Domain&gt;</span></span><br><span class="line"><span class="comment"># &lt;/Xdmf&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以发现生成了<code>f.xdmf</code>和<code>f.h5</code>文件。可以用<code>paraview</code>打开如下：</p>
<p><img src="/images/FEniCS_demo1.png" alt="FEniCS_demo1"></p>
<h3 id="jupyter方式"><a href="#jupyter方式" class="headerlink" title="jupyter方式"></a>jupyter方式</h3><p>首先找到自己docker服务器的ip</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ip $(docker-machine active)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 我的是：192.168.99.100</span></span><br></pre></td></tr></table></figure>
<p>然后运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">mkdir fenics</span><br><span class="line">cd fenics</span><br><span class="line"><span class="meta">#</span><span class="bash">根据镜像建立一个container，并使其开始运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t，分配tty，使其不会退出，一直running</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --name notebook，把这个运行的实例叫做notebook，可以用docker ps -a 看到，最后一列。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v $(<span class="built_in">pwd</span>):/home/fenics/shared</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d detach模式，后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p $(docker-machine ip $(docker-machine active)):8888:8888 端口映射，把上述docker服务器的端口8888映射到本地8888</span></span><br><span class="line">docker run -it --name notebook -w /home/fenics -v $(pwd):/home/fenics/shared -w /home/fenics/shared -p $(docker-machine ip $(docker-machine active)):8888:8888  quay.io/fenicsproject/stable:current</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">建立配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在notebook container中输入</span></span><br><span class="line">jupyter notebook --generate-config</span><br><span class="line"><span class="meta">#</span><span class="bash"> Writing default config to: /root/.jupyter/jupyter_notebook_config.py</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置密码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在notebook container中输入</span></span><br><span class="line">jupyter notebook password</span><br><span class="line"><span class="meta">#</span><span class="bash"> Enter password: 比如123</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Verify password:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [NotebookPasswordApp] Wrote hashed password to /root/.jupyter/jupyter_notebook_config.json</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行notebook</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在notebook container中输入</span></span><br><span class="line">jupyter notebook --ip=0.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> [I 16:31:04.584 NotebookApp] Writing notebook server cookie secret to /home/fenics/.<span class="built_in">local</span>/share/jupyter/runtime/notebook_cookie_secret</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [I 16:31:04.825 NotebookApp] Serving notebooks from <span class="built_in">local</span> directory: /home/fenics/shared</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [I 16:31:04.825 NotebookApp] 0 active kernels</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [I 16:31:04.825 NotebookApp] The Jupyter Notebook is running at:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [I 16:31:04.825 NotebookApp] http://0.0.0.0:8888/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [I 16:31:04.825 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [W 16:31:04.826 NotebookApp] No web browser found: could not locate runnable browser.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">退出container的shell界面但是不关闭这个程序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在notebook container中输入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 按CTRL+P, CTRL+Q</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">再次进入container的shell界面</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker terminal中输入</span></span><br><span class="line">docker attach noteobook</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">退出container并使其停止运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在notebook container中输入</span></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除container</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker terminal中输入</span></span><br><span class="line">docker rm notebook</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如有必要，需要先停止container：`docker stop notebook`</span></span><br></pre></td></tr></table></figure>
<p>用浏览器打开<a href="http://192.168.99.100:8888，输入密码123即可登录，界面显示如下：" target="_blank" rel="noopener">http://192.168.99.100:8888，输入密码123即可登录，界面显示如下：</a></p>
<p><img src="/images/FEniCS_demo2.png" alt="FEniCS_demo2"></p>
<p>然后就可以运行一个常规算例了，参考<sup><a href="#fn_4" id="reffn_4">4</a></sup></p>
<blockquote id="fn_4">
<sup>4</sup>. <a href="https://github.com/funsim/fenics-tutorial-notebook/blob/master/fenics-tutorial.ipynb" target="_blank" rel="noopener">FEniCS tutorial jupyter notebook</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">from</span> fenics <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># Create mesh and define function space</span></span><br><span class="line">mesh = UnitSquareMesh(<span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">V = FunctionSpace(mesh, <span class="string">'P'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define boundary condition</span></span><br><span class="line">u_D = Expression(<span class="string">'1 + x[0]*x[0] + 2*x[1]*x[1]'</span>, degree=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boundary</span><span class="params">(x, on_boundary)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> on_boundary</span><br><span class="line"></span><br><span class="line">bc = DirichletBC(V, u_D, boundary)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define variational problem</span></span><br><span class="line">u = TrialFunction(V)</span><br><span class="line">v = TestFunction(V)</span><br><span class="line">f = Constant(<span class="number">-9.0</span>)</span><br><span class="line">a = dot(grad(u), grad(v))*dx</span><br><span class="line">L = f*v*dx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute solution</span></span><br><span class="line">u = Function(V)</span><br><span class="line">solve(a == L, u, bc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot solution</span></span><br><span class="line">plot(u)</span><br></pre></td></tr></table></figure>
<p>结果如图：</p>
<p><img src="/images/FEniCS_demo3.png" alt="FEniCS_demo3"></p>
]]></content>
      
        <categories>
            
            <category> FEniCS </category>
            
            <category> docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
            <tag> FEniCS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[建网站写博客]]></title>
      <url>/2018/01/07/2018-01-07-%E5%BB%BA%E7%BD%91%E7%AB%99%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<ul>
<li>用typora写markdown文档</li>
<li>利用HEXO建博客</li>
<li>用NexT主题</li>
<li>利用mathjax 支持latex</li>
<li>放在github.io上</li>
<li>修改默认宽度</li>
</ul>
<a id="more"></a>
<h1 id="建网站写博客"><a href="#建网站写博客" class="headerlink" title="建网站写博客"></a>建网站写博客</h1><p>貌似现在比较流行自己建博客网站，有了github pages（国内有类似的coding pages）之后，建站也不用申请空间了，维护也非常的方便。</p>
<h2 id="用typora写markdown文档"><a href="#用typora写markdown文档" class="headerlink" title="用typora写markdown文档"></a>用typora写markdown文档</h2><p>个人比较喜欢用typora写markdown文档。</p>
<p>网站：<a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></p>
<p>下载地址：<a href="https://typora.io/windows/typora-setup-x64.exe?" target="_blank" rel="noopener">https://typora.io/windows/typora-setup-x64.exe?</a></p>
<p>Markdown使用参考：<a href="http://support.typora.io/Markdown-Reference/" target="_blank" rel="noopener">http://support.typora.io/Markdown-Reference/</a></p>
<p>设置拷贝图片到指定目录：<a href="http://support.typora.io/Images/#copy-image-files-to-target-folder-when-insert-local-image" target="_blank" rel="noopener">http://support.typora.io/Images/#copy-image-files-to-target-folder-when-insert-local-image</a></p>
<p>我的markdown文件开头：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 建网站写博客</span><br><span class="line">date: 2018-01-07 23:16:30</span><br><span class="line">updated: 2018-01-07 23:16:30</span><br><span class="line">categories:  </span><br><span class="line"><span class="bullet">- </span>Website</span><br><span class="line"><span class="bullet">- </span>Blog</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">- </span>mathjax</span><br><span class="line">typora-root-url: ..</span><br><span class="line">typora-copy-images-to: ..\images</span><br><span class="line">---</span><br><span class="line">短摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"><span class="section"># 标题</span></span><br><span class="line">内容</span><br><span class="line">inline公式：$a=b+c$</span><br><span class="line">display公式：</span><br><span class="line">$$</span><br><span class="line">f=ma</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>这样可以直接用HEXO转化为静态网页，并且可以自动处理好图片拷贝和上传的问题。</p>
<h2 id="用HEXO建立静态网站"><a href="#用HEXO建立静态网站" class="headerlink" title="用HEXO建立静态网站"></a>用HEXO建立静态网站</h2><p>HEXO是一个利用node.js渲染markdown文件建立静态博客的工具。反正比较程序员向。</p>
<p>官网：<a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></p>
<h3 id="首先需要安装git"><a href="#首先需要安装git" class="headerlink" title="首先需要安装git"></a>首先需要安装git</h3><p>网址：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p>
<p>下载地址：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p>
<p>版本：最新版</p>
<p>安装选项：默认即可</p>
<p>安装完之后需要进行一下全局设置，打开开始菜单中的<code>git bash</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "name" #你的名字</span><br><span class="line">git config --global user.email "johndoe@example.com" #你的邮箱</span><br></pre></td></tr></table></figure>
<h3 id="其次需要安装node-js"><a href="#其次需要安装node-js" class="headerlink" title="其次需要安装node.js"></a>其次需要安装node.js</h3><p>nodejs官网：<a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a></p>
<p>下载地址：<a href="https://nodejs.org/dist/v8.9.4/node-v8.9.4-x64.msi" target="_blank" rel="noopener">https://nodejs.org/dist/v8.9.4/node-v8.9.4-x64.msi</a></p>
<p>版本：稳定LTS版，v8.9.4-x64</p>
<p>安装好之后开始菜单会有一个<code>node.js command prompt</code>的快捷方式，打开之后如下图所示：</p>
<p><img src="/images/Node.js_cmd_prompt.PNG" alt="Node.js_cmd_prompt"></p>
<p>然后就可以利用npm（nodejs package manager）来安装需要的软件包了。</p>
<h3 id="安装HEXO"><a href="#安装HEXO" class="headerlink" title="安装HEXO"></a>安装HEXO</h3><p>很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rem 安装hexo</span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h3 id="建立站点并测试"><a href="#建立站点并测试" class="headerlink" title="建立站点并测试"></a>建立站点并测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rem 新建一个站点文件夹，名为blog</span><br><span class="line">hexo init blog</span><br><span class="line">rem 进入blog文件夹</span><br><span class="line">cd blog</span><br><span class="line">rem 安装需要的软件包</span><br><span class="line">npm install</span><br><span class="line">rem 测试生成网站</span><br><span class="line">hexo g </span><br><span class="line">rem 测试访问网站，访问http://localhost:4000/</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>访问的网站默认如下：</p>
<p><img src="/images/HEXO_helloworld.PNG" alt="HEXO_helloworld"></p>
<p>此时只要是放入<code>blog/source/_posts</code>中的markdown文件都会被自动渲染成网页出现在这个界面上，只要重新运行一次<code>hexo g &amp;&amp; hexo s</code>即可。</p>
<ul>
<li><code>hexo g</code>等价于<code>hexo generate</code></li>
<li><code>hexo s</code>等价于<code>hexo server</code></li>
</ul>
<h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><p>国内由于网络原因对于npm支持不佳，可以采用cnpm，参考<a href="https://npm.taobao.org/" target="_blank" rel="noopener">taobao npm 镜像网站</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rem 安装cnpm</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">rem 然后用cnpm代替上面命令中的npm就可以了，比如：</span><br><span class="line">cnpm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">cnpm install</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h2 id="使用NexT主题"><a href="#使用NexT主题" class="headerlink" title="使用NexT主题"></a>使用NexT主题</h2><p>HEXO支持各种各样的主题，其中NexT主题因为是中国人做的还比较友好，并且支持很多国内的链接和网站，所以就选它了。</p>
<p>官网：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p>
<p>源代码：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>只需要3步：</p>
<ol>
<li>把主题文件下载到themes/next文件夹</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<ol>
<li>修改<code>blog/_config.yml</code>文件中的<code>theme</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//原来默认的是：</span></span><br><span class="line"><span class="string">//theme:</span> <span class="string">landscape</span></span><br><span class="line"><span class="string">//修改为：</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<ol>
<li>重新生成</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>blog这个站点目录里现在有两个文件需要配置：</p>
<ul>
<li>站点配置文件<code>blog\_config.yml</code></li>
<li>主题配置文件<code>blog\themes\next\_config.yml</code></li>
</ul>
<p>参考<a href="http://theme-next.iissnan.com/getting-started.html进行配置即可。" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html进行配置即可。</a></p>
<h2 id="利用Mathjax支持latex公式"><a href="#利用Mathjax支持latex公式" class="headerlink" title="利用Mathjax支持latex公式"></a>利用Mathjax支持latex公式</h2><p>NexT对公式的支持还算可以，简单的公式只要用以下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rem 安装相关包</span><br><span class="line">npm install hexo-math --save</span><br><span class="line">rem 卸载不兼容latex公式的渲染器</span><br><span class="line">npm uninstall hexo-render-marked --save</span><br><span class="line">rem 安装支持latex公式的渲染器</span><br><span class="line">npm install hexo-render-kramed --save</span><br></pre></td></tr></table></figure>
<p>然后保证站点配置文件<code>blog\_config.yml</code>下存在以下内容</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  engine:</span> <span class="string">mathjax</span></span><br></pre></td></tr></table></figure>
<p>并且在主题配置文件<code>blog\themes\next\_config.yml</code>中存在以下内容 </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>
<p>重新生成即可渲染绝大部分公式。</p>
<h3 id="额外设置"><a href="#额外设置" class="headerlink" title="额外设置"></a>额外设置</h3><p>对于少部分公式还是支持有问题，我采用以下方法解决的。</p>
<p>修改<code>blog\node_modules\kramed\lib\rules\inline.js</code>文件中的11行和20行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var inline = &#123;</span><br><span class="line">  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,      //修改这里</span><br><span class="line">  ...</span><br><span class="line">  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    //修改这里</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>上述<code>//</code>符号之后的注释不要。</p>
<p>上述修改的作用是使其正确处理latex公式中的<code>\\,\{,\},_</code>等标记。 </p>
<p>参考：<a href="http://xudongyang.coding.me/math-in-hexo/" target="_blank" rel="noopener">http://xudongyang.coding.me/math-in-hexo/</a></p>
<h2 id="网站部署到-github-pages上"><a href="#网站部署到-github-pages上" class="headerlink" title="网站部署到 github pages上"></a>网站部署到 github pages上</h2><p>网站不部署只能自己看到，部署之后所有人就都能看到了。</p>
<p>但是普通空间都是需要钱的，一个比较方便又免费的空间就是github pages了。</p>
<h3 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h3><p>分为两步：</p>
<ol>
<li>github账号的申请，这里不详谈，参考：<a href="https://github.com/join" target="_blank" rel="noopener">https://github.com/join</a></li>
<li>github pages 空间的申请，参考：<a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a></li>
<li>github pages 空间的申请</li>
</ol>
<p>假设你的id是<code>iamgod</code>，空间申请只要去<a href="https://github.com/new建立一个名为`iamgod.github.io`的仓库（repository）即可。" target="_blank" rel="noopener">https://github.com/new建立一个名为`iamgod.github.io`的仓库（repository）即可。</a></p>
<p>注意：不要添加任何文件，包括README.md</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>HEXO的部署可以参考：<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a></p>
<p>基本步骤如下：</p>
<ol>
<li>安装git部署器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rem 进入blog文件夹</span><br><span class="line">cd blog</span><br><span class="line">rem 安装git部署器</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ol>
<li>修改站点配置文件<code>blog\_config.yml</code>，可在末尾加上以下部分.</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/iamgod/iamgod.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<ol>
<li>运行部署命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rem 进入blog文件夹</span><br><span class="line">cd blog</span><br><span class="line">rem 先生成</span><br><span class="line">hexo generate</span><br><span class="line">rem 然后部署，此时它会要求你输入github的登录账号和密码</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>等一会儿访问<a href="https://iamgod.github.io就可以看到更新网站了。" target="_blank" rel="noopener">https://iamgod.github.io就可以看到更新网站了。</a></p>
<h2 id="修改NexT主题默认宽度"><a href="#修改NexT主题默认宽度" class="headerlink" title="修改NexT主题默认宽度"></a>修改NexT主题默认宽度</h2><p>参考：<a href="http://theme-next.iissnan.com/faqs.html#custom-content-width" target="_blank" rel="noopener">http://theme-next.iissnan.com/faqs.html#custom-content-width</a></p>
<p>编辑<code>blog\source\css\_variables\custom.styl</code>文件，添加以下内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 修改成你期望的宽度</span><br><span class="line">$content-desktop = 700px //我改成了1000px</span><br><span class="line"></span><br><span class="line">// 当视窗超过 1600px 后的宽度</span><br><span class="line">$content-desktop-large = 900px //我改成了1200 px</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Website </category>
            
            <category> Blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> website </tag>
            
            <tag> blog </tag>
            
            <tag> latex </tag>
            
            <tag> mathjax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[rhoCentralFoam解析]]></title>
      <url>/2018/01/05/rhoCentralFoam%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>rhoCentralFoam是OpenFOAM中一个基于密度的可压缩求解器，算超声速通常用它比较合适。但是网上缺乏对其程序的分析，本文结合开发者的原始文献对其进行简单分析。</p>
<a id="more"></a>
<h1 id="rhoCentralFoam解析"><a href="#rhoCentralFoam解析" class="headerlink" title="rhoCentralFoam解析"></a>rhoCentralFoam解析</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先明确一些关键概念。</p>
<h3 id="半隐式分离求解器"><a href="#半隐式分离求解器" class="headerlink" title="半隐式分离求解器"></a>半隐式分离求解器</h3><p>首先从代码来看这是一个半隐式(semi-implicit)的分离(segregate)求解器：</p>
<ul>
<li><p>半隐式的意思是代码中只有部分项是隐式的，而另一些项是显式的，参考文献<a href="people.clarkson.edu/~sfulton/pubs/sitd.pdf">Semi-Implicit Time Differencing</a>认为半隐式格式的时间步长其实不太有较大优势，除非显式部分的能量占比很小。</p>
<ul>
<li>这种半隐式体现在不同的项上，比如粘性项：<br>$\mathbf \tau = \nabla\cdot(\mu \nabla \mathbf u )+\mathbf\tau_{MC}=  \{ \nabla\cdot(\mu \nabla \mathbf u ) \}^{n+1} +\{ (\nabla\mathbf u)^T - \frac 2 3 (\nabla\cdot\mathbf u) \mathbf I\}^{n}$<ul>
<li>没有转置的第一项就可以隐式离散，但是后面的就不行，由于OpenFOAM实现方式的限制，暂时只能用显式离散。</li>
</ul>
</li>
<li>这种半隐式还体现在非线性项上，主要是为了把非线性方程线性化：<br>$\rho u u = [\rho u ]^{n} \times u^{n+1}$</li>
<li>其实非线性方程线性化有两种方法：Newton方法和Picard方法。Newton方法是对增量进行求解，通常会用到Jacobian矩阵或者其近似矩阵，而Picard方法是直接对全量求解，从实现角度来看可能更简单，但是收敛会更慢，不过从实践来讲，通常计算物理和计算数学界的人偏好用Jacobian矩阵，而CFD界的人似乎因为传统更喜欢用Picard迭代。</li>
</ul>
</li>
<li><p>分离的意思是它是先求解密度、再求解速度和能量方程的，而在求解密度的时候认为速度和能量是不变的，而求解速度的时候，密度已经更新过了，这会导致变量的一致性问题，比如文章中提到的温度T如果不做处理可能出现负值的问题。</p>
<h3 id="界面数值通量的处理和实现"><a href="#界面数值通量的处理和实现" class="headerlink" title="界面数值通量的处理和实现"></a>界面数值通量的处理和实现</h3><p>可压缩流的关键问题在于界面数值通量的处理，rhoCentralFoam采用的是KT或KNP格式，在<code>system/fvScheme</code>中有一个<code>fluxScheme</code>关键字（程序中的type是word ），如果是<code>Kurganov</code>，那么就是KNP中心上风格式，如果是<code>Tamdor</code>，则是KT中心格式。tutorial中自带算例一般是<code>Kurganov</code>，即KNP中心上风格式。</p>
</li>
</ul>
<p>在离散过程中，由于OpenFOAM本身没有提供同时取得界面两侧插值的功能，所以rhoCentralFoam是自己实现的。方法是利用辅助用途的表面张量场pos和neg来制定界面物理量的插值方向。pos和neg的源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*createFields.H*/</span></span><br><span class="line"><span class="comment">//line 64</span></span><br><span class="line">surfaceScalarField pos <span class="comment">//表面张量场</span></span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"pos"</span>,</span><br><span class="line">        runTime.timeName(),</span><br><span class="line">        mesh</span><br><span class="line">    ),</span><br><span class="line">    mesh,</span><br><span class="line">    dimensionedScalar(<span class="string">"pos"</span>, dimless, <span class="number">1.0</span>) <span class="comment">//无量纲</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">surfaceScalarField neg</span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"neg"</span>,</span><br><span class="line">        runTime.timeName(),</span><br><span class="line">        mesh</span><br><span class="line">    ),</span><br><span class="line">    mesh,</span><br><span class="line">    dimensionedScalar(<span class="string">"neg"</span>, dimless, <span class="number">-1.0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>具体的获取某个界面(face)某个方向的插值操作是通过interpolate函数完成的，函数定义如下面的代码，当传入的<code>faceFlux</code>是正的（如<code>pos</code>），那么就用这个<code>face</code>的<code>owner</code>侧的插值，否则用<code>face</code>的<code>neighbour</code>侧的插值，具体的插值算法又由<code>name</code>参数指定，系统会从<code>fvScheme</code>配置文件中找指定的插值方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*src\finiteVolume\interpolation\surfaceInterpolation\surfaceInterpolation\surfaceInterpolation.H*/</span></span><br><span class="line"><span class="comment">//line 98</span></span><br><span class="line">    <span class="comment">//- Interpolate field onto faces using scheme given by name in fvSchemes</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; //函数模板</span></span><br><span class="line"><span class="class">    //<span class="title">static</span>静态函数，<span class="title">tmp</span>对象避免对象传递时析构构造的开销</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">tmp</span>&lt;GeometricField&lt;Type, fvsPatchField, surfaceMesh&gt;&gt; <span class="title">interpolate</span></span></span><br><span class="line"><span class="class">    (</span></span><br><span class="line"><span class="class">        <span class="title">const</span> <span class="title">GeometricField</span>&lt;Type, fvPatchField, volMesh&gt;&amp; <span class="title">tvf</span>,</span></span><br><span class="line"><span class="class">        <span class="title">const</span> <span class="title">surfaceScalarField</span>&amp; <span class="title">faceFlux</span>,</span></span><br><span class="line"><span class="class">        <span class="title">const</span> <span class="title">word</span>&amp; <span class="title">name</span></span></span><br><span class="line"><span class="class">    );</span></span><br></pre></td></tr></table></figure>
<h2 id="权重以及文章中公式的错误"><a href="#权重以及文章中公式的错误" class="headerlink" title="权重以及文章中公式的错误"></a>权重以及文章中公式的错误</h2><p>文章和编程中有两个权重，一个是插值权重，也就是界面物理量和周围单元(owner和neighbour)物理量的关系：文章中公式11.5(公式11和12之间的未编号公式)如下：</p>
<script type="math/tex; mode=display">
\mathbf{\Psi}_f=(1-g_{f+})\mathbf{\Psi}_P+g_{f+}\mathbf{\Psi}_N\\

g_{f+}=\beta(r)(1-w_f)\\

\beta(r)=\frac{r+|r|}{1+r},\text{ van Leer limiter}\\

w_f = \frac{|\mathbf{S}_f\cdot\mathbf{d}_{fN}|}{|\mathbf{S}_f\cdot\mathbf{d}_{}|}     \text{  weighting coefficient}</script><p>其中$\mathbf{\Psi}_f, \mathbf{\Psi}_P, \mathbf{\Psi}_N$ 分别代表界面，owner和neighbour网格中心的物理量。</p>
<p>$g_{f+}$表示插值权重。</p>
<p>$w_f$ 是权重因子。</p>
<p>$\beta(r)$是限制器，而参数$r$ 表示两侧的梯度和平均梯度的函数。</p>
<p>另一个是重构的权重，只涉及界面两侧的量，KT和KNP的区别只在于重构权重的选取方式不一样。在文章中的表示方式是：</p>
<script type="math/tex; mode=display">
\sum_f{\phi_f\mathbf{\Psi}_f}=
\sum_f{[\alpha\phi_{f+}\mathbf{\Psi}_{f+}+(1-\alpha)\phi_{f-}\mathbf{\Psi}_{f-}+
\omega_f(\mathbf{\Psi}_{f-}-\mathbf{\Psi}_{f+})
]}</script><p>其中$\omega_f$是起耗散作用的，只有在对流项中使用，因为用得比较频繁，所以代码实现和文中公式有一些不一致，代码实现如下：</p>
<script type="math/tex; mode=display">
\sum_f{\phi_f\mathbf{\Psi}_f}=
\sum_f{[(\alpha\phi_{f+}+\omega_f)\mathbf{\Psi}_{f+}+((1-\alpha)\phi_{f-}-\omega_f)\mathbf{\Psi}_{f-}]}</script><p>此外，这个重构权重的公式有个错误就是扩散项的符号不对，扩散项中$\mathbf{\Psi}_{f\pm}$的权重和代码实现是相反的，个人认为代码实现应该是对的，文章中是错误的。</p>
<h2 id="fvc-div和fvc-ddt的量纲问题"><a href="#fvc-div和fvc-ddt的量纲问题" class="headerlink" title="fvc::div和fvc::ddt的量纲问题"></a>fvc::div和fvc::ddt的量纲问题</h2><p>还有一个问题是OF中的fvc::div($\phi,\alpha$)和数学$\nabla\cdot(\phi\alpha)$是不一样的，<code>fvc::div</code>除以了体积V：</p>
<script type="math/tex; mode=display">
\text{fvc::div}(\phi,\alpha)=\frac{\sum_f{\phi_f\alpha_f}}{V}</script><p>这点从代码可以看出：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*src/finiteVolume/finiteVolume/fvc/fvcSurfaceIntegrate.H*/</span></span><br><span class="line"><span class="comment">//line:104</span></span><br><span class="line">                ssf.dimensions()/dimVol,</span><br></pre></td></tr></table></figure></p>
<p>而fvc::ddt($\alpha$)和数学上一致，以Euler格式为例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*src\finiteVolume\finiteVolume\ddtSchemes\EulerDdtScheme\EulerDdtScheme.C*/</span></span><br><span class="line"><span class="comment">//line: 102</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">EulerDdtScheme</span>&lt;Type&gt;:</span>:fvcDdt</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; vf</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    dimensionedScalar rDeltaT = <span class="number">1.0</span>/mesh().time().deltaT();</span><br><span class="line"></span><br><span class="line">    IOobject ddtIOobject</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"ddt("</span>+vf.name()+<span class="string">')'</span>,</span><br><span class="line">        mesh().time().timeName(),</span><br><span class="line">        mesh()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mesh().moving())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tmp&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">new</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;</span><br><span class="line">            (</span><br><span class="line">                ddtIOobject,</span><br><span class="line">                rDeltaT*</span><br><span class="line">                (</span><br><span class="line">                    vf()</span><br><span class="line">                  - vf.oldTime()()*mesh().Vsc0()/mesh().Vsc()</span><br><span class="line">                ),</span><br><span class="line">                rDeltaT.value()*</span><br><span class="line">                (</span><br><span class="line">                    vf.boundaryField() - vf.oldTime().boundaryField()</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tmp&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">new</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;</span><br><span class="line">            (</span><br><span class="line">                ddtIOobject,</span><br><span class="line">                rDeltaT*(vf - vf.oldTime()) <span class="comment">//显然如果vf的量纲是D,那么ddt(vf)的量纲是D/T</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>翻译成公式是：</p>
<script type="math/tex; mode=display">
\text{fvc::ddt}(\alpha)=\frac{1}{\Delta t}(\alpha^n-\alpha^{n-1})</script><p>这样OpenFOAM的代码中的公式量纲才是正确的。</p>
<p>参考<sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<blockquote id="fn_1">
<sup>1</sup>. <a href="http://www.cfd-china.com/topic/703/fvc-div%E7%9A%84%E5%89%8D%E5%90%8E%E9%87%8F%E7%BA%B2%E5%85%B3%E7%B3%BB%E5%88%B0%E5%BA%95%E6%98%AF%E5%95%A5" target="_blank" rel="noopener">fvc::div的前后量纲关系到底是啥？</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<p>个人认为OpenFOAM很多时候的做法是为了减少计算量：</p>
<ul>
<li>比如喜欢用界面通量，避免存面矢量场，用面标量场就够了；</li>
<li>有些内部实现是不带单位的数组，而不是带单位的<code>dimensionedField</code></li>
</ul>
<h2 id="总体算法"><a href="#总体算法" class="headerlink" title="总体算法"></a>总体算法</h2><p>更多的细节参考文章中的算法，在文中第14页</p>
<ul>
<li>while t&lt;$t_{end}​$ do<ul>
<li>t := t+ dt</li>
<li>利用van Leer限制器，从单元场$\rho,\mathbf{\hat u},T$中插值得<ul>
<li>到 $\rho_{f \pm},\mathbf{\hat u}_{f\pm},T_{f\pm}$</li>
</ul>
</li>
<li>计算<ul>
<li>$\mathbf{u}_{f\pm}=\mathbf{\hat u}_{f\pm}/\rho_{f\pm}$</li>
<li>$p_{f\pm}=\rho_{f\pm} RT_{f\pm}$</li>
<li>$\phi_{f\pm}=\mathbf{S}_f\cdot\mathbf{u}_{f\pm}$</li>
<li>$c_{f\pm}=\sqrt{\gamma R T_{f\pm} }$</li>
</ul>
</li>
<li>根据公式7-13计算对流导数和$\nabla p$</li>
<li>更新$\mathbf{T}_{exp},\mu,k$</li>
<li>根据方程1求解密度$\rho$</li>
<li>根据方程18求解质量流率$\mathbf{\hat u}$(无粘动量预测步)</li>
<li>更新$\mathbf{u}=\mathbf{\hat u}/\rho​$</li>
<li>根据方程19求解速度$\mathbf{u}​$(扩散速度修正步)</li>
<li>根据方程20求解能量流率$\hat{E}​$(无粘能量预测步)</li>
<li>根据$\hat{E},\mathbf u,\rho$更新温度$T$</li>
<li>根据方程21求解温度$T$(扩散温度修正步)</li>
<li>更新压力$p=\rho R T​$</li>
</ul>
</li>
<li>end while</li>
</ul>
<p>但是文章是在OpenFOAM 1.5中实现的，在现在的OpenFOAM中的rhoCentralFoam实现有点儿不一样的地方，比如能量方程的求解不是求温度T了，而是直接求解内能e。</p>
<h2 id="粘性应力项"><a href="#粘性应力项" class="headerlink" title="粘性应力项"></a>粘性应力项</h2><p>根据文章内容和公式4，<code>rhoCentralFoam</code>没有考虑体积粘性，文中的公式为：</p>
<script type="math/tex; mode=display">
\mathbf T = -2\mu \times\text{dev}(\mathbf D)  \\

= -2\mu \times\text{dev}(\frac 1 2 [\nabla \mathbf u+\nabla (\mathbf u)^T])\\

= -2\mu\times \{\frac 1 2 [\nabla \mathbf u+\nabla (\mathbf u)^T]-\frac 1 3 tr(\nabla \mathbf u+\nabla (\mathbf u)^T)\mathbf I\}\\

= -\mu[\nabla \mathbf u+\nabla (\mathbf u)^T]-\frac 2 3\mu(\nabla\cdot \mathbf u) \mathbf I\\

= -\mu\nabla \mathbf u-\mu[\nabla (\mathbf u)^T+\frac 2 3 (\nabla\cdot \mathbf u) \mathbf I]</script><p>这个最终公式是有点奇怪的，一是它的符号和常规的推导是相反的，通常粘性应力是正的。二是它的形式和可压缩流的粘性应力有一定区别。</p>
<h3 id="关于可压缩流粘性应力、第二粘性系数、体积粘性"><a href="#关于可压缩流粘性应力、第二粘性系数、体积粘性" class="headerlink" title="关于可压缩流粘性应力、第二粘性系数、体积粘性"></a>关于可压缩流粘性应力、第二粘性系数、体积粘性</h3><p>参考文献<a href="https://link.springer.com/article/10.1007/s00707-015-1380-9" target="_blank" rel="noopener">A note on Stokes’ hypothesis</a>，<br>总应力$\mathbf S$可以表示为：</p>
<script type="math/tex; mode=display">
\mathbf S = -p_e \mathbf I + \mathbf T</script><p>其中$p_e$表示热力学平衡压力，负号表示压力向内为正。</p>
<p>而$\mathbf T$表示粘性应力，是变形率的函数，变形率可以用速度的梯度$\nabla\mathbf u$来表征，而根据应力应和刚体旋转部分不想关的要求，在将速度梯度进行加法分解之后，$\nabla\mathbf u=\mathbf E+\mathbf \Omega = \frac 1 2 (\nabla\mathbf u+(\nabla\mathbf u)^T)+\frac 1 2 (\nabla\mathbf u-(\nabla\mathbf u)^T)$，<br>再考虑到应力和应变率对称性的要求，应力的函数形式为：</p>
<script type="math/tex; mode=display">
\mathbf T = \lambda (\nabla \cdot \mathbf u) \mathbf I + 2\mu \mathbf E
=\lambda (\nabla \cdot \mathbf u) \mathbf I +\mu[\nabla\mathbf u+(\nabla\mathbf u)^T]</script><p>其中$\mu$被称为动力粘性系数，也就是通常所说的粘性系数。$\lambda$就是第二粘性系数。</p>
<p>再进一步地将$\mathbf E$分解为各向同性部分和偏量部分：</p>
<script type="math/tex; mode=display">
\mathbf E = \mathbf A+\mathbf D=\frac 1 3 (\nabla \cdot \mathbf u) \mathbf I +(\mathbf E-\mathbf A)</script><p>则粘性力可以表示为：</p>
<script type="math/tex; mode=display">
\mathbf T = (\lambda+\frac 2 3 \mu) (\nabla \cdot \mathbf u) \mathbf I + 2\mu \mathbf D
=\kappa(\nabla \cdot \mathbf u) \mathbf I + 2\mu \mathbf D</script><p>总应力可以表示为：</p>
<script type="math/tex; mode=display">
\mathbf S = [-p_e+(\lambda+\frac 2 3 \mu) (\nabla \cdot \mathbf u)] \mathbf I + 2\mu \mathbf D= [-p_e+\kappa (\nabla \cdot \mathbf u)] \mathbf I + 2\mu \mathbf D</script><p>其中$-p_e+(\lambda+\frac 2 3 \mu) (\nabla \cdot \mathbf u)$被称之为机械压力(mechanical pressure)。而$\kappa$被称为体积粘性系数，这就引入了Stokes假设</p>
<h3 id="Stokes-假设"><a href="#Stokes-假设" class="headerlink" title="Stokes 假设"></a>Stokes 假设</h3><p>明显可以看出，两种条件下机械压力和热力学平衡压力相同，那就是</p>
<ul>
<li>不可压缩流动：$\nabla \cdot \mathbf u =0$</li>
<li>满足Stokes 假设: $\kappa=\lambda+\frac 2 3 \mu=0$</li>
</ul>
<p>实际上</p>
<ul>
<li>对于单原子分子气体，动理学理论(kinetic theory)认为体积粘性为0，Stokes假设成立，少量试验证据也证实了这一点，而且一些研究认为动理学理论隐含假设了体积粘性为0；</li>
<li>对于多原子分子气体，由于存在内部自由度，而体积粘性和达到局部平衡的延迟有关，所以不为0，试验结果也发现体积粘性不可忽略，对于N2和O2，$\kappa = O(1)\mu$，对于CO2，$\kappa = O(1000)\mu$</li>
<li>对于许多液体而言，$\kappa &gt;&gt; \mu$</li>
<li>体积粘性的影响可以用无量纲数$\frac{\kappa\nabla\cdot\mathbf u}{p_e}​$来表征，对于绝大多数情况这个影响是可以忽略的，但是存在例外情况。<ul>
<li>CO2中的高超声速流动和激波（火星再入？）；</li>
<li>高频声波；</li>
</ul>
</li>
</ul>
<p>在rhoCentralFoam文章中，假设了体积粘性为0，那么是怎么实现的呢？</p>
<h3 id="粘性项的FVM编程实践"><a href="#粘性项的FVM编程实践" class="headerlink" title="粘性项的FVM编程实践"></a>粘性项的FVM编程实践</h3><p>在有限体积离散中，需要把尽可能多的项用采用Gauss公式用面积分的方式表达，上述式子中的$\mathbf D,\mathbf E$等量在物理上是好东西，但是在FVM实现中比较麻烦，尤其是难以表达成隐式方式，所以在FVM中还是尽量多地用$\nabla\cdot \mathbf u,\nabla \mathbf u$等表达方式。</p>
<p>因此，《The finite volume method in computational fluid dynamics: an advanced introduction to OpenFOAM and Matlab》中的公式3.37中，将粘性应力分为了两部分。</p>
<script type="math/tex; mode=display">
\frac \partial {\partial t}[\rho \mathbf u]
+\frac \partial {\partial x}[\rho \mathbf u \mathbf u] 
=
-\nabla p
+\{
\nabla\cdot[\mu\nabla\mathbf u]
\}_1
+\{
\nabla\cdot[\mu\nabla\mathbf u]^T
+\nabla(\lambda\nabla\cdot\mathbf u)
\}_2
+\mathbf f_b</script><p>引入假设$\kappa=\lambda+\frac 2 3 \mu=0$，上式可化为：</p>
<script type="math/tex; mode=display">
\frac \partial {\partial t}[\rho \mathbf u]
+\frac \partial {\partial x}[\rho \mathbf u \mathbf u] 
=
-\nabla p
+\{
\nabla\cdot[\mu\nabla\mathbf u]
\}_1
+\{
\nabla\cdot[\mu\nabla\mathbf u]^T
-\frac 2 3 \nabla(\mu\nabla\cdot\mathbf u)
\}_2
+\mathbf f_b</script><p>其中第1部分是可以用fvm::laplacian(mu,U)实现隐式处理，剩下的第2部分采用deferred correction approach的方法代入源项中处理。<br>在rhoCentralFoam的代码具体实现的时候也是分成两部分的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line:198</span></span><br><span class="line">        <span class="keyword">if</span> (!inviscid)</span><br><span class="line">        &#123;</span><br><span class="line">            solve</span><br><span class="line">            (</span><br><span class="line">                fvm::ddt(rho, U) - fvc::ddt(rho, U)</span><br><span class="line">              - fvm::laplacian(muEff, U)<span class="comment">//隐式处理</span></span><br><span class="line">              - fvc::div(tauMC)<span class="comment">//显式处理</span></span><br><span class="line">            );</span><br><span class="line">            rhoU = rho*U;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>一部分是隐式的fvm::laplacian(muEff, U)，另一部分是 显式的fvc::div(tauMC)，其计算如下。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volTensorField tauMC("tauMC", muEff*dev2(Foam::T(fvc::grad(U))));</span><br></pre></td></tr></table></figure></p>
<p>但是其中没有用到dev，而是用到了dev2，这俩是OpenFOAM中tensor类型的一种函数，其定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*src\OpenFOAM\primitives\Tensor\TensorI.H*/</span></span><br><span class="line"><span class="comment">// Line: 562</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//- Return the deviatoric part of a tensor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Cmpt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">Tensor</span>&lt;Cmpt&gt; <span class="title">dev</span>(<span class="title">const</span> <span class="title">Tensor</span>&lt;Cmpt&gt;&amp; <span class="title">t</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> t - SphericalTensor&lt;Cmpt&gt;::oneThirdI*tr(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- Return the deviatoric part of a tensor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Cmpt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">Tensor</span>&lt;Cmpt&gt; <span class="title">dev2</span>(<span class="title">const</span> <span class="title">Tensor</span>&lt;Cmpt&gt;&amp; <span class="title">t</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> t - SphericalTensor&lt;Cmpt&gt;::twoThirdsI*tr(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码翻译成公式是：</p>
<script type="math/tex; mode=display">
\tau_{MC} 
= \mu_{\text{eff}}\cdot \text{dev2}((\nabla\mathbf u)^T)
=\mu_{\text{eff}}\cdot 
\{
(\nabla\mathbf u)^T - \frac 2 3 tr((\nabla\mathbf u)^T) \mathbf I
\}\\
=\mu_{\text{eff}}\cdot 
\{
(\nabla\mathbf u)^T - \frac 2 3 (\nabla\cdot\mathbf u) \mathbf I
\}</script><p>所以可以看出，这个实现是和文章中的推导相符的，但是形式变化太大了。</p>
<h1 id="变量名对照"><a href="#变量名对照" class="headerlink" title="变量名对照"></a>变量名对照</h1><p>文章中的变量名和程序中很不一致。对照表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">code variable</th>
<th style="text-align:center">line No.</th>
<th style="text-align:center">dimension</th>
<th style="text-align:center">文章中的符号</th>
<th style="text-align:right">equation No.</th>
<th style="text-align:left">comment</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">rPsi</td>
<td style="text-align:center">80</td>
<td style="text-align:center">$L^2/T^2$</td>
<td style="text-align:center">$\frac{dp}{d\rho}=RT$</td>
<td style="text-align:right">无</td>
<td style="text-align:left">thermo模型中的变量psi的倒数</td>
</tr>
<tr>
<td style="text-align:center">phiv_pos</td>
<td style="text-align:center">93</td>
<td style="text-align:center">$L^3/T$</td>
<td style="text-align:center">$\phi_{f+}=\mathbf{u}_+\cdot \mathbf{S}_{f} $</td>
<td style="text-align:right">7</td>
<td style="text-align:left">正向体积流量</td>
</tr>
<tr>
<td style="text-align:center">phiv_neg</td>
<td style="text-align:center">94</td>
<td style="text-align:center">$L^3/T$</td>
<td style="text-align:center">$\phi_{f-}=\mathbf{u}_-\cdot \mathbf{S}_{f} $</td>
<td style="text-align:right">7</td>
<td style="text-align:left">反向体积流量</td>
</tr>
<tr>
<td style="text-align:center">ap</td>
<td style="text-align:center">108</td>
<td style="text-align:center">$L^3/T$</td>
<td style="text-align:center">$\psi_{f+}$</td>
<td style="text-align:right">8</td>
<td style="text-align:left">正向体积流量权重</td>
</tr>
<tr>
<td style="text-align:center">am</td>
<td style="text-align:center">113</td>
<td style="text-align:center">$L^3/T$</td>
<td style="text-align:center">$-\psi_{f-}$</td>
<td style="text-align:right">8</td>
<td style="text-align:left">负向体积流量权重的相反数</td>
</tr>
<tr>
<td style="text-align:center">a_pos</td>
<td style="text-align:center">119</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$\alpha=\frac{\psi_{f+}}{\psi_{f+}+\psi_{f-}}$</td>
<td style="text-align:right">9-KNP</td>
<td style="text-align:left">KNP格式中的$\alpha$，在KT格式中为1/2</td>
</tr>
<tr>
<td style="text-align:center">amaxSf</td>
<td style="text-align:center">121</td>
<td style="text-align:center">$L^3/T$</td>
<td style="text-align:center">$\max(\psi_{f+},\psi_{f-})$</td>
<td style="text-align:right">无</td>
<td style="text-align:left">编程需要构造出来的一个变量</td>
</tr>
<tr>
<td style="text-align:center">aSf</td>
<td style="text-align:center">123</td>
<td style="text-align:center">$L^3/T$</td>
<td style="text-align:center">$\omega_f= -\alpha\psi_{f-} \\ =-\frac{\psi_{f+}\psi_{f-}}{\psi_{f+}+\psi_{f-}}$</td>
<td style="text-align:right">10-KNP</td>
<td style="text-align:left">公式10-KNP展开，扩散体积通量，对于物质导数中的对流项是必须的，可与公式13对照；在KT格式中有所不同</td>
</tr>
<tr>
<td style="text-align:center">a_neg</td>
<td style="text-align:center">131</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1-\alpha$</td>
<td style="text-align:right">7</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">phiv_pos</td>
<td style="text-align:center">133</td>
<td style="text-align:center">$L^3/T$</td>
<td style="text-align:center">$\alpha\phi_{f+}$</td>
<td style="text-align:right">7</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">phiv_neg</td>
<td style="text-align:center">134</td>
<td style="text-align:center">$L^3/T$</td>
<td style="text-align:center">$(1-\alpha)\phi_{f-}$</td>
<td style="text-align:right">7</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">aphiv_pos</td>
<td style="text-align:center">136</td>
<td style="text-align:center">$L^3/T$</td>
<td style="text-align:center">$\alpha\phi_{f+}+\omega_f$</td>
<td style="text-align:right">7-变形</td>
<td style="text-align:left">原文公式7中$\mathbf{\Psi}_{f+}$的系数，但是原文$\omega_f$符号有错误</td>
</tr>
<tr>
<td style="text-align:center">aphiv_neg</td>
<td style="text-align:center">137</td>
<td style="text-align:center">$L^3/T$</td>
<td style="text-align:center">$(1-\alpha)\phi_{f-}-\omega_f$</td>
<td style="text-align:right">7-变形</td>
<td style="text-align:left">原文公式7中$\mathbf{\Psi}_{f-}$的系数，但是原文$\omega_f$符号有错误</td>
</tr>
<tr>
<td style="text-align:center">amaxSf(第二次使用)</td>
<td style="text-align:center">141</td>
<td style="text-align:center">$L^3/T$</td>
<td style="text-align:center"><script type="math/tex">\max(\mid\alpha\phi_{f+}+ \omega_f\mid, \\ \mid(1-\alpha)\phi_{f-}-\omega_f\mid)</script></td>
<td style="text-align:right">无</td>
<td style="text-align:left">中心格式预测的幅值最大的数值单向通量</td>
</tr>
<tr>
<td style="text-align:center">phi</td>
<td style="text-align:center">159</td>
<td style="text-align:center">$\frac M T$</td>
<td style="text-align:center">$(\alpha\phi_{f+}+\omega_f)\rho_+ \\ + ((1-\alpha)\phi_{f-}-\omega_f)\rho_{-}$</td>
<td style="text-align:right">无</td>
<td style="text-align:left">界面数值重构的质量通量</td>
</tr>
<tr>
<td style="text-align:center">phiUp</td>
<td style="text-align:center">167</td>
<td style="text-align:center">$\frac M {LT^2}$</td>
<td style="text-align:center">$(\alpha\phi_{f+}+\omega_f)[\rho\mathbf u]_+ \\ + ((1-\alpha)\phi_{f-}-\omega_f)[\rho\mathbf u]_- \\ +(\alpha p_++(1-\alpha)p_-)\mathbf S_f$</td>
<td style="text-align:right">无</td>
<td style="text-align:left">界面数值重构的动量通量</td>
</tr>
<tr>
<td style="text-align:center">tauMC</td>
<td style="text-align:center">176</td>
<td style="text-align:center">$\frac{M}{LT^2}$</td>
<td style="text-align:center">$\mu_{eff}[(\nabla\mathbf u)^T - \frac 2 3 (\nabla\cdot\mathbf u) \mathbf I]$</td>
<td style="text-align:right">4</td>
<td style="text-align:left">粘性应力的deferred correction显式部分</td>
</tr>
</tbody>
</table>
</div>
<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>程序和文献口心不一，把好好的NS方程改得面目全非。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>solver作者的原始文献<strong>Implementation of semi-discrete, non-staggered central schemes in a colocated, polyhedral, finite volume framework, for high-speed viscous flows</strong> DOI: 10.1002/fld.2069</li>
<li>《The finite volume method in computational fluid dynamics: an advanced introduction to OpenFOAM and Matlab》</li>
<li><strong>A note on Stokes’ hypothesis</strong> Acta Mech 226, 3555–3559 (2015)  DOI 10.1007/s00707-015-1380-9</li>
<li><a href="https://github.com/OpenFOAM/OpenFOAM-dev/tree/master/applications/solvers/compressible/rhoCentralFoam" target="_blank" rel="noopener">source code</a></li>
</ul>
<h3 id="注释的代码"><a href="#注释的代码" class="headerlink" title="注释的代码"></a>注释的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*rhoCentralFoam.C*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fvCFD.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"psiThermo.H"</span> <span class="comment">//热力学</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"turbulentFluidThermoModel.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fixedRhoFvPatchScalarField.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"directionInterpolate.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"localEulerDdtScheme.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fvcSmooth.H"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> NO_CONTROL</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"postProcess.H"</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"setRootCase.H"</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"createTime.H"</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"createMesh.H"</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"createFields.H"</span> <span class="comment">//pos,neg在此创建</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"createFieldRefs.H"</span> <span class="comment">//热力学场psi=drho/dp的创建</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"createTimeControls.H"</span></span></span><br><span class="line"></span><br><span class="line">    turbulence-&gt;validate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line">    <span class="comment">//读取fluxScheme,如果是Kurganov，则为KNP格式，如果是Tamdor，则是KT格式</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"readFluxScheme.H"</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function">dimensionedScalar <span class="title">v_zero</span><span class="params">(<span class="string">"v_zero"</span>, dimVolume/dimTime, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Courant numbers used to adjust the time-step</span></span><br><span class="line">    scalar CoNum = <span class="number">0.0</span>;</span><br><span class="line">    scalar meanCoNum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"\nStarting time loop\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (runTime.run())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// --- Directed interpolation of primitive fields onto faces</span></span><br><span class="line"></span><br><span class="line">        surfaceScalarField rho_pos(interpolate(rho, pos));</span><br><span class="line">        surfaceScalarField rho_neg(interpolate(rho, neg));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//U.name()表示采用U对应的插值方法</span></span><br><span class="line">        surfaceVectorField rhoU_pos(interpolate(rhoU, pos, U.name()));</span><br><span class="line">        surfaceVectorField rhoU_neg(interpolate(rhoU, neg, U.name()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//OpenFOAM喜欢采用rXxx表示xxx变量的倒数，不知道为什么。</span></span><br><span class="line">        <span class="comment">//psi=drho/dp (==1/(RT) for perfect gas)</span></span><br><span class="line">        <span class="comment">//rPsi = dp/drho (==RT for perfect gas)</span></span><br><span class="line">        <span class="function">volScalarField <span class="title">rPsi</span><span class="params">(<span class="string">"rPsi"</span>, <span class="number">1.0</span>/psi)</span></span>;</span><br><span class="line">        surfaceScalarField rPsi_pos(interpolate(rPsi, pos, T.name()));</span><br><span class="line">        surfaceScalarField rPsi_neg(interpolate(rPsi, neg, T.name()));</span><br><span class="line"></span><br><span class="line">        surfaceScalarField e_pos(interpolate(e, pos, T.name()));</span><br><span class="line">        surfaceScalarField e_neg(interpolate(e, neg, T.name()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不知为啥U_pos要这样计算而不是直接插值。</span></span><br><span class="line">        <span class="function">surfaceVectorField <span class="title">U_pos</span><span class="params">(<span class="string">"U_pos"</span>, rhoU_pos/rho_pos)</span></span>;</span><br><span class="line">        <span class="function">surfaceVectorField <span class="title">U_neg</span><span class="params">(<span class="string">"U_neg"</span>, rhoU_neg/rho_neg)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">p_pos</span><span class="params">(<span class="string">"p_pos"</span>, rho_pos*rPsi_pos)</span></span>;</span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">p_neg</span><span class="params">(<span class="string">"p_neg"</span>, rho_neg*rPsi_neg)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//phiv: volumetric flow across a face, [L^3/T]</span></span><br><span class="line">        surfaceScalarField phiv_pos("phiv_pos", U_pos &amp; mesh.Sf());// &amp;表示矢量点积</span><br><span class="line">        surfaceScalarField phiv_neg("phiv_neg", U_neg &amp; mesh.Sf());</span><br><span class="line"></span><br><span class="line">        volScalarField c("c", sqrt(thermo.Cp()/thermo.Cv()*rPsi));// 声速</span><br><span class="line">        surfaceScalarField cSf_pos</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"cSf_pos"</span>,</span><br><span class="line">            interpolate(c, pos, T.name())*mesh.magSf()</span><br><span class="line">        );</span><br><span class="line">        surfaceScalarField cSf_neg</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"cSf_neg"</span>,</span><br><span class="line">            interpolate(c, neg, T.name())*mesh.magSf()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//文献公式8</span></span><br><span class="line">        surfaceScalarField ap</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"ap"</span>,</span><br><span class="line">            max(max(phiv_pos + cSf_pos, phiv_neg + cSf_neg), v_zero)</span><br><span class="line">        );</span><br><span class="line">        surfaceScalarField am</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"am"</span>,</span><br><span class="line">            min(min(phiv_pos - cSf_pos, phiv_neg - cSf_neg), v_zero)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        surfaceScalarField a_pos("a_pos", ap/(ap - am));</span><br><span class="line"></span><br><span class="line">        surfaceScalarField amaxSf("amaxSf", max(mag(am), mag(ap)));</span><br><span class="line"></span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">aSf</span><span class="params">(<span class="string">"aSf"</span>, am*a_pos)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fluxScheme == <span class="string">"Tadmor"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            aSf = <span class="number">-0.5</span>*amaxSf;</span><br><span class="line">            a_pos = <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">a_neg</span><span class="params">(<span class="string">"a_neg"</span>, <span class="number">1.0</span> - a_pos)</span></span>;</span><br><span class="line"></span><br><span class="line">        phiv_pos *= a_pos;</span><br><span class="line">        phiv_neg *= a_neg;</span><br><span class="line"></span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">aphiv_pos</span><span class="params">(<span class="string">"aphiv_pos"</span>, phiv_pos - aSf)</span></span>;</span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">aphiv_neg</span><span class="params">(<span class="string">"aphiv_neg"</span>, phiv_neg + aSf)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reuse amaxSf for the maximum positive and negative fluxes</span></span><br><span class="line">        <span class="comment">// estimated by the central scheme</span></span><br><span class="line">        amaxSf = max(mag(aphiv_pos), mag(aphiv_neg));</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"centralCourantNo.H"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"readTimeControls.H"</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LTS) <span class="comment">//local time stepping</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"setRDeltaT.H"</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            #include <span class="string">"setDeltaT.H"</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上面是按原时刻计算的界面重构权重</span></span><br><span class="line">        runTime++;</span><br><span class="line">        <span class="comment">//下面计算出来的是新时刻的量</span></span><br><span class="line"></span><br><span class="line">        Info&lt;&lt; <span class="string">"Time = "</span> &lt;&lt; runTime.timeName() &lt;&lt; nl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 对流质量流量，含速度，用带扩散项的插值。</span></span><br><span class="line">        phi = aphiv_pos*rho_pos + aphiv_neg*rho_neg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对流动量流量部分用带扩散项的aphiv_pos插值</span></span><br><span class="line">        <span class="comment">// 压力部分用a_pos插值</span></span><br><span class="line">        surfaceVectorField phiUp</span><br><span class="line">        (</span><br><span class="line">            (aphiv_pos*rhoU_pos + aphiv_neg*rhoU_neg)</span><br><span class="line">          + (a_pos*p_pos + a_neg*p_neg)*mesh.Sf()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        surfaceScalarField phiEp</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"phiEp"</span>,</span><br><span class="line">            aphiv_pos*(rho_pos*(e_pos + <span class="number">0.5</span>*magSqr(U_pos)) + p_pos)</span><br><span class="line">          + aphiv_neg*(rho_neg*(e_neg + <span class="number">0.5</span>*magSqr(U_neg)) + p_neg)</span><br><span class="line">          + aSf*p_pos - aSf*p_neg </span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        volScalarField muEff("muEff", turbulence-&gt;muEff());</span><br><span class="line">        volTensorField tauMC("tauMC", muEff*dev2(Foam::T(fvc::grad(U))));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- Solve density</span></span><br><span class="line">        <span class="comment">//fvc::div和数学divergence operator不完全一样，会除以体积，这样量纲才对。</span></span><br><span class="line">        solve(fvm::ddt(rho) + fvc::div(phi));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- Solve momentum</span></span><br><span class="line">        solve(fvm::ddt(rhoU) + fvc::div(phiUp));</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        U.ref() =</span><br><span class="line">            rhoU()</span><br><span class="line">           /rho();</span><br><span class="line">        U.correctBoundaryConditions();</span><br><span class="line">        rhoU.boundaryFieldRef() == rho.boundaryField()*U.boundaryField();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!inviscid)</span><br><span class="line">        &#123;</span><br><span class="line">            solve</span><br><span class="line">            (</span><br><span class="line">                fvm::ddt(rho, U) - fvc::ddt(rho, U)<span class="comment">//注意一个是fvm::ddt，一个是fvc::ddt</span></span><br><span class="line">              - fvm::laplacian(muEff, U) <span class="comment">//隐式的部分，如果要显式实现，参考源代码206行中sigmaDotU的计算</span></span><br><span class="line">              - fvc::div(tauMC) <span class="comment">//显式的部分</span></span><br><span class="line">            );</span><br><span class="line">            rhoU = rho*U;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- Solve energy</span></span><br><span class="line">        surfaceScalarField sigmaDotU<span class="comment">//粘性力做功项</span></span><br><span class="line">        (</span><br><span class="line">            <span class="string">"sigmaDotU"</span>,<span class="comment">//但是其实这部分不用分开成两部分计算也可以哈。</span></span><br><span class="line">            (</span><br><span class="line">                fvc::interpolate(muEff)*mesh.magSf()*fvc::snGrad(U)<span class="comment">//粘性应力中Laplacian部分的计算</span></span><br><span class="line">              + fvc::dotInterpolate(mesh.Sf(), tauMC)</span><br><span class="line">            )</span><br><span class="line">          &amp; (a_pos*U_pos + a_neg*U_neg) <span class="comment">//为啥速度又要这么插值了？</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        solve</span><br><span class="line">        (</span><br><span class="line">            fvm::ddt(rhoE)</span><br><span class="line">          + fvc::div(phiEp)</span><br><span class="line">          - fvc::div(sigmaDotU)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        e = rhoE/rho - <span class="number">0.5</span>*magSqr(U);</span><br><span class="line">        e.correctBoundaryConditions();</span><br><span class="line">        thermo.correct();</span><br><span class="line">        rhoE.boundaryFieldRef() ==</span><br><span class="line">            rho.boundaryField()*</span><br><span class="line">            (</span><br><span class="line">                e.boundaryField() + <span class="number">0.5</span>*magSqr(U.boundaryField())</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!inviscid)</span><br><span class="line">        &#123;</span><br><span class="line">            solve</span><br><span class="line">            (</span><br><span class="line">                fvm::ddt(rho, e) - fvc::ddt(rho, e)</span><br><span class="line">              - fvm::laplacian(turbulence-&gt;alphaEff(), e)</span><br><span class="line">            );</span><br><span class="line">            thermo.correct();</span><br><span class="line">            rhoE = rho*(e + <span class="number">0.5</span>*magSqr(U));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.ref() =</span><br><span class="line">            rho()</span><br><span class="line">           /psi();</span><br><span class="line">        p.correctBoundaryConditions();</span><br><span class="line">        rho.boundaryFieldRef() == psi.boundaryField()*p.boundaryField();</span><br><span class="line"></span><br><span class="line">        turbulence-&gt;correct();</span><br><span class="line"></span><br><span class="line">        runTime.write();</span><br><span class="line"></span><br><span class="line">        Info&lt;&lt; <span class="string">"ExecutionTime = "</span> &lt;&lt; runTime.elapsedCpuTime() &lt;&lt; <span class="string">" s"</span></span><br><span class="line">            &lt;&lt; <span class="string">"  ClockTime = "</span> &lt;&lt; runTime.elapsedClockTime() &lt;&lt; <span class="string">" s"</span></span><br><span class="line">            &lt;&lt; nl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"End\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="从rhoCentralFoam中得到的启示"><a href="#从rhoCentralFoam中得到的启示" class="headerlink" title="从rhoCentralFoam中得到的启示"></a>从rhoCentralFoam中得到的启示</h1><p>OpenFOAM没有自带实现计算界面数值通量的方法（foam_extend中有一部分），所以往往需要通过一些interpolate操作将界面左右量计算出来，再自主实现一个计算数值通量的方法，最后再进行积分。</p>
<p>但让人觉得疑惑的是，目前OpenFOAM的时间递进方面只有单步方法，没有线性多步法，如RK之类的。</p>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
            <category> rhoCentralFoam </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> rhoCentralFoam </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenFOAM的不可压缩流算法]]></title>
      <url>/2018/01/05/OpenFOAM%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8E%8B%E7%BC%A9%E6%B5%81%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>对不可压缩流的几个经典算法及其在OpenFOAM中的实现进行了梳理。</p>
<p>主要针对OpenFOAM 5.x版本</p>
<a id="more"></a>
<h1 id="SIMPLE-PISO和PIMPLE算法"><a href="#SIMPLE-PISO和PIMPLE算法" class="headerlink" title="SIMPLE, PISO和PIMPLE算法"></a>SIMPLE, PISO和PIMPLE算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>均质-不可压缩-无体积力-常粘性</strong>的NS方程为：</p>
<script type="math/tex; mode=display">
{ {\partial \mathbf{u} } \over {\partial t} } + \mathbf{u} \cdot \nabla \mathbf{u} =
{-{1 \over \rho} \nabla p} + {\nu \nabla^2 \mathbf{u} }\\
\nabla\cdot \mathbf{u}=0</script><p>OpenFOAM和其他的CFD软件常用来解它的算法有：</p>
<ul>
<li>SIMPLE: Semi-Implicit Method of-Pressure Linked Equations，用于稳态计算</li>
<li>PISO:= Pressure Implicit Split Operator，用于瞬态计算，可以使用的Courant数往往小于1<sup><a href="#fn_1" id="reffn_1">1</a></sup></li>
<li>PIMPLE:= Merged PISO–SIMPLE，可以使用Courant数&gt;&gt;1</li>
</ul>
<p>但是找文献和教科书对的时候你会发现很多时候算法和OpenFOAM里的实现对不上。比如wiki和cfd-online上给的SIMPLE算法描述就是（<a href="https://en.wikipedia.org/wiki/SIMPLE_algorithm" target="_blank" rel="noopener">Wiki: SIMPLE Algorithm</a>）：</p>
<ol>
<li>修正边界条件；</li>
<li>计算速度和压力梯度；</li>
<li>求解离散动量方程（ discretized momentum equation），求得体心临时速度场；这一步是显式的</li>
<li>用体心临时速度场插值计算面心质量通量场；</li>
<li>计算压力修正方程（pressure correction equation），得到体心压力修正场；这一步是隐式的</li>
<li>对体心压力场进行亚松弛修正；</li>
<li>对压力场修正边界条件；</li>
<li>修正面心质量通量场；</li>
<li>修正体心速度场；</li>
<li>更新密度；</li>
</ol>
<p>但是明显OpenFOAM中的simpleFoam并没有求解过所谓的修正方程，而是自己玩了一个Picard迭代<sup><a href="#fn_9" id="reffn_9">9</a></sup>直接求的全量方程（你会发现OpenFOAM似乎从来就没求过修正量的Newton迭代，个人理解是因为OpenFOAM玩Newton迭代时边界条件不是很方便处理。）</p>
<p>于是我做了一点儿考古和分析。</p>
<h2 id="SIMPLE算法"><a href="#SIMPLE算法" class="headerlink" title="SIMPLE算法"></a>SIMPLE算法</h2><p>SIMPLE: Semi-Implicit Method of Pressure Linked Equations，这个方程的名字就满是问题，首先什么是半隐式方法（Semi-Implicit Method），什么又是压力联系方程（Pressure Linked Equations）？在原始文献<sup><a href="#fn_2" id="reffn_2">2</a></sup> 中是没有用SIMPLE这个名字的。搜索文献也很难找到压力联系方程的说法。我至今没有找到这个术语最开始的出处，查到最早的是他们自己1973年的文献<sup><a href="#fn_5" id="reffn_5">5</a></sup> 是叫SIMPLE了，但似乎大家都是以讹传讹地引用1972年的那篇文献。</p>
<p>根据一些参考文献<sup><a href="#fn_3" id="reffn_3">3</a></sup> 的分类法，SIMPLE, PISO都属于一类叫压力修正格式（Pressure Correction Schemes）的算法，其特征是构造一个压力场来满足不可压缩条件，再得到一个速度场，至于这个速度场能不能满足新得到的压力场，呵呵，要是能满足就不用再继续迭代了。由于求解的动量方程已经是线性化之后的了，所以你把这个速度对应的面心通量场再去线性化一次动量方程，如此往复才能最后得到稳态解。</p>
<h3 id="压力联系方程之到底是哪个方程"><a href="#压力联系方程之到底是哪个方程" class="headerlink" title="压力联系方程之到底是哪个方程"></a>压力联系方程之到底是哪个方程</h3><p>查来查去，发现不可压缩CFD解的主要是以下方程：</p>
<ul>
<li>压力修正方程（Pressure Correction Equation, PCE）<sup><a href="#fn_4" id="reffn_4">4</a></sup> : 两次迭代间压力需要的修正量的方程</li>
</ul>
<ol>
<li><script type="math/tex; mode=display">
\nabla^2 (p^{n+1}-p^n) =\frac 1 {\Delta t}\nabla\cdot U^*</script></li>
</ol>
<ul>
<li><p>压力泊松方程（Pressure Poisson Equation, PPE）<sup><a href="#fn_ 6" id="reffn_ 6"> 6</a></sup>: 动量方程求散度，消去速度散度项</p>
<p>稳定化的一阶欧拉时间离散时的形式。</p>
</li>
</ul>
<script type="math/tex; mode=display">
\nabla^2 p^{n+1} = \rho { {\nabla \cdot \mathbf{u}^n} \over {\Delta t} }-
\rho \nabla \cdot (\mathbf{u}^n \cdot \nabla \mathbf{u}^n)+
\mu \nabla^2 (\nabla \cdot \mathbf{u}^n)</script><p>​    速度场保持无散时的形式。</p>
<script type="math/tex; mode=display">
-\frac 1 \rho \nabla^2 p =  \nabla \cdot (\mathbf{u} \cdot \nabla \mathbf{u})</script><ul>
<li>压力联系方程（Pressure Linked Equation, PLE）：原始文献并没有说什么是PLE，参考另一篇文献<sup><a href="#fn_7" id="reffn_7">7</a></sup>的说法，压力联系方程的形式如下（符号定义参考文献）：</li>
</ul>
<script type="math/tex; mode=display">
\frac{\partial}{\partial x}\left( \gamma\frac{\partial p}{\partial x} \right) 
+\frac{\partial}{\partial y}\left( \gamma\frac{\partial p}{\partial y} \right) 
= \hat \epsilon
\\
\hat\epsilon = (\hat u_e- \hat u_w)/\Delta x +(\hat v_n - \hat v_s)/\Delta y</script><p>可见，所谓PLE非常诡异，它不是个微分方程，而是一个代数方程。对应到OpenFOAM里的simpleFoam则是<sup><a href="#fn_8" id="reffn_8">8</a></sup>：</p>
<script type="math/tex; mode=display">
\begin{equation}
\nabla \cdot (\mathbf{HbyA}^{n+1}) = \nabla \cdot(\frac{1}{A_{\mathrm{P},f} } \nabla p^{n+1})
\label{poss}
\end{equation}</script><p>同时，对比PLE和PPE，可以发现，二者都是把某种形式的动量方程带入了质量守恒方程得到的，但不同之处在于</p>
<ol>
<li>PLE是把<strong>线性化</strong>的<strong>离散</strong>动量方程中得到速度表达式带入了质量守恒方程，得到$\nabla\cdot(\frac 1 a \nabla p) = \dots $。<ol>
<li>大概是这么个过程：</li>
<li>线性化离散动量方程记为 $M\cdot u =  \nabla p $， $M$是一个矩阵。</li>
<li>先LDU加法分解： $M\cdot u = (D+L+U) \cdot u = \nabla p$</li>
<li>然后进行Jacobi迭代：$ D \cdot u = \nabla p - (L+U) \cdot u^0$</li>
<li>左边： $D$记为$A$ （实际上是对角系数除以单元体积，以保持量纲一致性）， 因为是对角阵，所以可以把$D^{-1}=A^{-1}$记为 $\frac 1 A$ ，OpenFOAM里实现为一个几何场而不是矩阵<code>fvMatrix</code>；</li>
<li>右边：$(L+U)\cdot u^0$记为 $H$ </li>
<li>这样$u = \frac 1 A \nabla p - \frac H A$ </li>
<li>然后再利用$\nabla \cdot u = 0 $</li>
<li>得到$\nabla\cdot(\frac 1 A \nabla p ) = \nabla \cdot \frac H A$ ，这就是PLE，也是实际OpenFOAM中求解的方程。</li>
<li>英语里$\frac H A$ 可以读作”H by A”</li>
<li>OpenFOAM里的$\frac 1 A$ 对应变量为<code>rUA</code> </li>
</ol>
</li>
<li>PPE是把动量方程直接求散度得到的，所以是$\nabla\cdot\nabla p=\dots$。</li>
</ol>
<h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ul>
<li>问：为啥要费劲心力去算$\mathbf{HbyA}$，再算PLE，直接离散PPE或者质量守恒方程不行么？</li>
<li><p>答：我也不知道</p>
<ul>
<li>但是玩FEM的家伙们就是这么干的（当然实际上他们也有很多流派，但是他们更多的是玩函数空间，LBB条件而不是玩方程系数，玩系数太low）</li>
<li>似乎只有玩FVM的人才玩PLE。</li>
<li><p>而且投影法<sup><a href="#fn_10" id="reffn_10">10</a></sup>那个流派的FVM也是玩的PPE，参考<a href="https://en.wikipedia.org/wiki/Projection_method_(fluid_dynamics" target="_blank" rel="noopener">Chorin’s_projection_method</a>#Chorin’s_projection_method)。</p>
</li>
<li><p>而且为了玩PLE，作为使用OpenFOAM的同位网格玩家，还必须引入Rhie-Chow插值这种大坑，虽然OpenFOAM似乎轻巧地避开了这个坑。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Semi-Implicit-Method半隐式方法"><a href="#Semi-Implicit-Method半隐式方法" class="headerlink" title="Semi-Implicit-Method半隐式方法"></a>Semi-Implicit-Method半隐式方法</h3><p>我认为之所以叫半隐式方法，是因为：</p>
<ul>
<li>求解过程中，求速度预测步的方程对于速度是隐式的，但对于压力是固定的显式离散，所以称之为半隐式。</li>
<li>求解压力方程时，压力是隐式离散的，但是此时的速度是固定不变的。</li>
<li>所以本质上这个半隐式等价于解耦算法。</li>
<li>文献<sup><a href="#fn_5" id="reffn_5">5</a></sup> 摘要中提到，SIMPLE的半隐式是和SIVA（SImultaneous Variable Adjustment）全隐算法相对的提法，其特点是每次迭代要同时更新周围的速度和压力。</li>
</ul>
<p>SIMPLE算法因此具有一些特性：</p>
<ul>
<li>解耦计算，内存占用小。</li>
</ul>
<ul>
<li>用于稳态计算，所以<code>timeStep</code>无意义，但通常设置<code>timeStep=1</code>，这样解算输出时间等于时间步数；</li>
<li>由于没有时间项来稳定化计算，需要加入松弛因子（在矩阵上加在和时间项几乎相同的位置），但是这个松弛因子在实现时搞不好会对最终稳态解产生影响。</li>
</ul>
<h3 id="关于consistent"><a href="#关于consistent" class="headerlink" title="关于consistent"></a>关于<code>consistent</code></h3><p>对于SIMPLE-C算法<sup><a href="#fn_16" id="reffn_16">16</a></sup>而言，比SIMPLE算法只多了一个步骤：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//applications/solvers/incompressible/pimpleFoam/pEqn.H +16</span></span><br><span class="line"><span class="keyword">if</span> (pimple.consistent())</span><br><span class="line">&#123;</span><br><span class="line">    rAtU = <span class="number">1.0</span>/max(<span class="number">1.0</span>/rAU - UEqn.H1(), <span class="number">0.1</span>/rAU); <span class="comment">//有max!</span></span><br><span class="line">    phiHbyA +=</span><br><span class="line">        fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf();</span><br><span class="line">    HbyA -= (rAU - rAtU())*fvc::grad(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/simpleFoam/pEqn.H +10</span></span><br><span class="line"><span class="keyword">if</span> (simple.consistent())</span><br><span class="line">&#123;</span><br><span class="line">  rAtU = <span class="number">1.0</span>/(<span class="number">1.0</span>/rAU - UEqn.H1()); <span class="comment">//没有max!</span></span><br><span class="line">  phiHbyA +=</span><br><span class="line">    fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf();</span><br><span class="line">  HbyA -= (rAU - rAtU())*fvc::grad(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，pimpleFoam和simpleFoam的<code>consistent</code>选项对<code>rAtU</code>的计算公式是有区别的！</p>
<p>其中修改了的变量有：</p>
<ul>
<li><p><code>rAtU</code></p>
<ul>
<li><code>1.0/rAU - UEqn.H1()</code>的实际含义应该是$[1/(\frac{1}{D})-(-(L+U)\cdot \mathbf{1})] = (L+D+U)\cdot \mathbf{1}$，也就是矩阵系数的行和，中间最多差一个网格体积的因子。</li>
<li><code>0.1/rAU</code>的含义应该是$\frac{1}{10} D$</li>
<li>由于系数矩阵元素的大小往往是对角项为负，非对角项为正，其行和为略小的负数（对于laplace方程，某些行和可能为0，但是对于动量方程，应该不为零）。所以为了避免除以0，<code>pimpleFoam</code>采用了<code>max</code>函数的技巧。</li>
<li>而对于<code>simpleFoam</code>，只取了第一项的倒数。</li>
</ul>
</li>
<li><p><code>phiHbyA</code></p>
<ul>
<li><p>按照<code>rAtU-rAU</code>的差值，和<code>grad(p)</code>对界面流量进行更新</p>
</li>
<li><p>把这项代入到pEqn的表达式中，可以发现和原来是一样的</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来的方程，如pisoFoam, icoFoam就采用了这个方程</span></span><br><span class="line">fvScalarMatrix pEqn</span><br><span class="line">(</span><br><span class="line">	fvm::laplacian(rAU, p) == fvc::div(phiHbyA)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//simpleFoam, pimpleFoam采用的方程，将phiHbyA改记为phiHbyA2</span></span><br><span class="line">fvScalarMatrix pEqn</span><br><span class="line">(</span><br><span class="line">	fvm::laplacian(rAtU(), p) == fvc::div(phiHbyA2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两者相减</span></span><br><span class="line">fvScalarMatrix pEqn</span><br><span class="line">(</span><br><span class="line">	fvm::laplacian(rAtU()-rAU, p) </span><br><span class="line">  == fvc::div(fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf())</span><br><span class="line">);</span><br><span class="line"><span class="comment">//可见二者是一致的。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>HbyA</code></p>
<ul>
<li>同上，按照<code>rAtU-rAU</code>的差值，对临时体心速度进行更新。</li>
<li>便于后面用<code>U = HbyA - rAtU()*fvc::grad(p);</code>去更新真正的体心速度！</li>
</ul>
</li>
<li><p>至此，正确性没有问题，但是为啥<code>rAtU</code>要这么改？！。 </p>
<ul>
<li><p>对于pimpleFoam中的<code>rAtU</code>，<code>max()</code>函数在分母，应该是取了较为稳定的一组系数，并避免了除以0。</p>
</li>
<li><p>对于simpleFoam而言，<code>rAU</code>是矩阵系数中的对角部分，而<code>rAtU</code>则是取了矩阵每一行系数的和。</p>
<ul>
<li><p>参考原始文献<sup><a href="#fn_16" id="reffn_16">16</a></sup> ，作者就是这么干的！</p>
</li>
<li><p>本质上你可以任意的分解：</p>
</li>
<li><script type="math/tex; mode=display">
M=L+D+U \\

M\cdot u = (L+D+U)\cdot u = (D_s+(M-D_s) )\cdot u = - \nabla p  \\</script></li>
<li><p>所以对于<code>consistent=false</code>的情形：</p>
</li>
<li><script type="math/tex; mode=display">
A=\frac 1 D \\
H=-(L+U)\cdot u^0</script></li>
<li><p>对于consistent=true的情形：</p>
</li>
<li><script type="math/tex; mode=display">
H_1 =- (L+U)\cdot \mathbf{1} \\
A'=D-H_1 = M\cdot \mathbf{1}</script></li>
<li><p>根据wiki上的说明，如果压力-速度耦合是解收敛的主要问题，SIMPLE-C算法可以加速收敛，SIMPLE-C比SIMPLE要快大概是120%-130%左右。</p>
</li>
<li><p>如果压力-速度耦合不是收敛的主要障碍，SIMPLE-C效率与SIMPLE差不多。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="关于H1和H的区别"><a href="#关于H1和H的区别" class="headerlink" title="关于H1和H的区别"></a>关于H1和H的区别</h4><ul>
<li>意义不一样：假设$M=(L+D+U)$，初值为$x^0$<ul>
<li>则$H_1 = H(x^0=\mathbf1)$</li>
<li>$H(x^0)=-(L+D)\cdot x^0$</li>
<li>$\mathbf 1$表示全是1的向量。</li>
</ul>
</li>
<li>都是定义在lduMatrix中的，但是<code>H1</code>是不带参数的，而<code>H</code>是带参数的。</li>
<li>实现的地方也不一样，一个在<code>lduMatrixATmul.C</code>，另一个在<code>lduMatrixTemplates.C</code>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//H1()</span></span><br><span class="line"><span class="comment">//src/OpenFOAM/matrices/lduMatrix/lduMatrix/lduMatrixATmul.C +298</span></span><br><span class="line">Foam::tmp&lt;Foam::scalarField &gt; Foam::lduMatrix::H1() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;scalarField &gt; tH1</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> scalarField(lduAddr().size(), <span class="number">0.0</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lowerPtr_ || upperPtr_)</span><br><span class="line">    &#123;</span><br><span class="line">        scalarField&amp; H1_ = tH1.ref();</span><br><span class="line"></span><br><span class="line">        scalar* __restrict__ H1Ptr = H1_.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ uPtr = lduAddr().upperAddr().begin();</span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ lPtr = lduAddr().lowerAddr().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ lowerPtr = lower().begin();</span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ upperPtr = upper().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label nFaces = upper().size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (label face=<span class="number">0</span>; face&lt;nFaces; face++)</span><br><span class="line">        &#123;</span><br><span class="line">            H1Ptr[uPtr[face]] -= lowerPtr[face];</span><br><span class="line">            H1Ptr[lPtr[face]] -= upperPtr[face];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tH1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//H(psi)</span></span><br><span class="line"><span class="comment">//src/OpenFOAM/matrices/lduMatrix/lduMatrix/lduMatrixTemplates.C +34</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:tmp&lt;Foam::Field&lt;Type&gt;&gt; Foam::lduMatrix::H(<span class="keyword">const</span> Field&lt;Type&gt;&amp; psi) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;Field&lt;Type&gt;&gt; tHpsi</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> Field&lt;Type&gt;(lduAddr().size(), Zero)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lowerPtr_ || upperPtr_)</span><br><span class="line">    &#123;</span><br><span class="line">        Field&lt;Type&gt; &amp; Hpsi = tHpsi.ref();</span><br><span class="line"></span><br><span class="line">        Type* __restrict__ HpsiPtr = Hpsi.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Type* __restrict__ psiPtr = psi.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ uPtr = lduAddr().upperAddr().begin();</span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ lPtr = lduAddr().lowerAddr().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ lowerPtr = lower().begin();</span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ upperPtr = upper().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label nFaces = upper().size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (label face=<span class="number">0</span>; face&lt;nFaces; face++)</span><br><span class="line">        &#123;</span><br><span class="line">            HpsiPtr[uPtr[face]] -= lowerPtr[face]*psiPtr[lPtr[face]];</span><br><span class="line">            HpsiPtr[lPtr[face]] -= upperPtr[face]*psiPtr[uPtr[face]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tHpsi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:tmp&lt;Foam::Field&lt;Type&gt;&gt;</span><br><span class="line">Foam::lduMatrix::H(<span class="keyword">const</span> tmp&lt;Field&lt;Type&gt;&gt;&amp; tpsi) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;Field&lt;Type&gt;&gt; tHpsi(H(tpsi()));</span><br><span class="line">    tpsi.clear();</span><br><span class="line">    <span class="keyword">return</span> tHpsi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>wiki和cfd-online上的SIMPLE算法是和simpleFoam不一致的。正确的描述可以参考openfoamwiki上的描述：<a href="http://openfoamwiki.net/index.php/OpenFOAM_guide/The_SIMPLE_algorithm_in_OpenFOAM#The_SIMPLE_algorithm" target="_blank" rel="noopener">the SIMPLE Algorithm</a></p>
<p>simple算法在OpenFOAM中的实现也是和版本相关的，比如foam-extend 4.0的simpleFoam里Jasak就采用了一种新的算法来避免时间步和松弛因子对解的影响。OpenFOAM.org和OpenFOAM.com的似乎还没变化。</p>
<p>此外，SIMPLE算法还有一些衍生算法：</p>
<ul>
<li>SIMPLEC: SIMPLE-Consistent</li>
<li>SIMPLER: SIMPLE-Revised</li>
</ul>
<h2 id="Rhie-Chow插值"><a href="#Rhie-Chow插值" class="headerlink" title="Rhie-Chow插值"></a>Rhie-Chow插值</h2><p>Rhie-Chow插值，有人又叫压力加权插值方法(pressure-weighted interpolation method, PWIM)，但是其实这个插值并不是用压力来加权的。</p>
<p>刚开始我以为这个插值的作用是来插值计算面心压力的，后来发现其实它是用来计算面心速度的插值方法。</p>
<p>本质上它等效于引入了4阶耗散项进入压力修正方程中，有利于计算的稳定化：</p>
<p>按照Rhie-Chow插值，均匀一维网格的面心速度表达式会含有P的三次导数成分。</p>
<script type="math/tex; mode=display">
U_e = \frac 1 2 (U_E+U_P)+\frac{\delta V}{4a_P\Delta x}[P_{EE}-3P_E+3P_P-P_W]</script><p>带入连续性方程之后，就会含有四次导数成分，成为稳定化压力方程的高阶耗散项，从而可以平抑压力波动：</p>
<script type="math/tex; mode=display">
\int_e^w{\frac {dU }{dx} dx} =U_e - U_w =  \frac 1 2 (U_E - U_W)+\frac{\delta V}{4a_P\Delta x}[P_EE-4P_E+6P_{P}-4P_W+P_{WW}]</script><p>详细的说明可以看参考文献<sup><a href="#fn_13" id="reffn_13">13</a></sup></p>
<p>而且玩高阶导数的人都应该知道，压力梯度都特别大的时候，高阶项会更大，所以有时候Rhie-Chow插值也会出问题。</p>
<h3 id="面心速度的作用"><a href="#面心速度的作用" class="headerlink" title="面心速度的作用"></a>面心速度的作用</h3><p>（注：面心速度（$\mathbf{u}_f$）和界面通量（程序里常用<code>phi</code>表示 ）仅相差一个面积，所以实际上差不多是同一回事儿。）</p>
<p>根据文献<sup><a href="#fn_11" id="reffn_11">11</a></sup> ，面心速度有三个作用：</p>
<ol>
<li>格式系数作用：构成关于体心速度的矩阵方程<code>UEqn</code>时，界面通量是系数的重要组成部分，系数不同，方程就不同，解就不同；</li>
<li>耦合作用：耦合速度和压力，在simple算法构造关于体心压力的矩阵方程时，需要用到界面通量；</li>
<li>质量守恒作用：界面通量应满足质量守恒。</li>
</ol>
<p>按照我的理解，在OpenFOAM中，这些作用在程序中分别由不同的变量承担了，并不是同一个面心速度了。</p>
<ol>
<li>格式系数作用：由于采用的是Picard迭代，所以OpenFOAM组成速度方程<code>UEqn</code>的矩阵系数是采用直接按<code>fvScheme</code>指定格式插值得到的界面通量<code>phi</code>在<code>fvm::div(phi,U)</code>生成的（准确地说在simpleFoam中第一次迭代用的插值phi，后面用的<code>pEqn.flux()</code>和<code>phiHbyA</code>构造的<code>phi</code>）。在<code>simpleFoam</code>中如以下代码所示。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UEqn.H</span></span><br><span class="line">tmp&lt;fvVectorMatrix&gt; tUEqn</span><br><span class="line">    (</span><br><span class="line">        fvm::div(phi, U) <span class="comment">//这里用的界面通量是phi</span></span><br><span class="line">      + MRF.DDt(U)</span><br><span class="line">      + turbulence-&gt;divDevReff(U)</span><br><span class="line">     ==</span><br><span class="line">        fvOptions(U)</span><br><span class="line">    );</span><br><span class="line">    fvVectorMatrix&amp; UEqn = tUEqn.ref();</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/cfdTools/incompressible/createPhi.H</span></span><br><span class="line">surfaceScalarField phi</span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"phi"</span>,</span><br><span class="line">        runTime.timeName(),</span><br><span class="line">        mesh,</span><br><span class="line">        IOobject::READ_IF_PRESENT,</span><br><span class="line">        IOobject::AUTO_WRITE</span><br><span class="line">    ),</span><br><span class="line">    fvc::flux(U) <span class="comment">//调用的是fvc::flux()</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/fvc/fvcFlux.C</span></span><br><span class="line"> Foam::tmp&lt;Foam::surfaceScalarField&gt; Foam::fvc::flux</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; vvf</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> scheme&lt;<span class="built_in">vector</span>&gt; <span class="comment">// scheme&lt;vector&gt;(mesh,name) 返回 tmp&lt;surfaceInterpolationScheme&gt;对象</span></span><br><span class="line">    (</span><br><span class="line">        vvf.mesh(),</span><br><span class="line">        <span class="string">"flux("</span> + vvf.name() + <span class="string">')'</span></span><br><span class="line">    )().dotInterpolate(vvf.mesh().Sf(), vvf); <span class="comment">//插值并点乘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pEqn.H</span></span><br><span class="line">    <span class="keyword">while</span> (simple.correctNonOrthogonal()) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (simple.finalNonOrthogonalIter())</span><br><span class="line">        &#123;</span><br><span class="line">            phi = phiHbyA - pEqn.flux(); <span class="comment">//更新phi</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>而耦合作用反映在<code>phiHbyA</code>这个界面通量中，它最终构成了<code>pEqn</code>中的源项部分，在OpenFOAM的simpleFoam求解器中，<code>phiHbyA</code>是用<code>fvc::flux(HbyA)</code> 构造的。<ol>
<li>但是值得注意的是，simpleFoam只构造出了不含压力梯度贡献的临时速度$u^*$ = <code>HbyA</code>，并且没有直接使用它，而是用它构造了<code>phiHbyA</code>。</li>
<li>simpleFoam没有在<code>pEqn</code>求解之前构造含有压力梯度贡献的<code>U</code>，这是在求解完压力方程后，用<code>U = HbyA - rAtU()*fvc::grad(p)</code> 构造的。</li>
<li>所以dyfluid上说<code>在OpenFOAM中，并没有直接采用Rhie-Chow插值的原始步骤。相反的，其通过对拉普拉斯项的离散巧妙的获得一种近似Rhie-Chow插值的原理。</code></li>
<li>因为原始步骤是通过$\nabla\cdot U=0$构造<code>pEqn</code>，而实际上因为<code>pEqn</code>是通过<code>phiHbyA</code> 和<code>rUA</code>构造的，所以跳过了原始的Rhie-Chow插值。</li>
<li>而因为<code>fvm::laplacian(rUA,p)</code>的实现已经是利用了周围相邻单元的压力，并没有原始构造方式中压力的奇偶失耦（odd-even decoupling）情况，所以认为是实现了Rhie-Chow插值的效果。</li>
<li>按照参考文献<sup><a href="#fn_18" id="reffn_18">18</a></sup> 的搞法（Listing 15.18），Rhie-Chow插值似乎是用于产生<code>phiHbyA</code>的，但是由于那本书严格地遵守了解PCE的思路，所以还不能完全相互比较。</li>
</ol>
</li>
<li>质量守恒作用其实是靠<code>pEqn</code>实现的PLE完成的，simpleFoam除了在<code>continuityErrs.H</code>之外不直接检查质量守恒，检查时也是用的<code>fvc::div(phi)</code>而不是速度<code>U</code>。 </li>
</ol>
<h2 id="PISO算法"><a href="#PISO算法" class="headerlink" title="PISO算法"></a>PISO算法</h2><p>PISO = Pressure Implicit Split Operator。同样的问题，什么是压力隐式(pressure implicit)，什么是算子分裂(split operator)。就icoFoam来看，我的理解是：</p>
<ul>
<li><p>压力隐式(pressure implicit)：求解的压力方程是隐式的（废话）；</p>
</li>
<li><p>算子分裂(split operator)：把$\frac {dx}{dt}|_t^{t+\Delta t}=O(x) = (O_1+O_2)(x)  $ 近似成$ \frac{dx}{dt}|_t^{t+\Delta t} = O_1(x’), \frac{dx’}{dt}|_t^{t+\Delta t}=O_2(x)$来求解</p>
<ul>
<li><p>原始文献<sup><a href="#fn_15" id="reffn_15">15</a></sup>中其实也就是解耦速度和压力的意思：</p>
</li>
<li><blockquote>
<p>The principle is here extended to apply to the coupling between variables, namely, the pressure and velocity, whereby operations involving different variables are split into a series of predictor-corrector steps.</p>
</blockquote>
</li>
<li><p>算子分裂的一个问题在于，它有时候<strong>不能保证到达稳态解的正确性</strong>！详见参考文献<sup><a href="#fn_14" id="reffn_14">14</a></sup> 。</p>
</li>
</ul>
</li>
</ul>
<p>算法的具体描述请参考<a href="http://openfoamwiki.net/index.php/OpenFOAM_guide/The_PISO_algorithm_in_OpenFOAM" target="_blank" rel="noopener">OpenFOAMwiki的PISO Algorithm</a> （这里的描述所用的版本有点老，和最新版OpenFOAM中使用的变量名有所不同）：</p>
<ol>
<li>Set the boundary conditions 施加边界条件.</li>
<li>Solve the discretized momentum equation to compute an intermediate velocity field. 解离散动量方程得到中间阶段的速度场$U^*$<ol>
<li>但是其实这一步可以设置<code>momentumPredictor=false</code>来跳过去。</li>
<li>因为最重要的其实是压力方程，这个速度场方程UEqn主要用来提取$A$和$H$，以构造后面压力方程要用的<code>phi</code></li>
<li>因为有非定常项，所以这里是没有松弛的！有松弛就不对了。</li>
</ol>
</li>
<li>Compute the mass fluxes at the cells faces，构造<code>phiHbyA</code>.<ol>
<li>与simple不同，这里的<code>phiHbyA</code>加入了<code>fvc::ddtCorr</code>项</li>
<li><code>fvc::ddtCorr</code>项的定义参考<a href="https://zh.scribd.com/doc/48195039/ddtPhiCorr" target="_blank" rel="noopener">这里</a>。</li>
</ol>
</li>
<li>Solve the pressure equation.解压力方程，其实应该是解的PLE</li>
<li>Correct the mass fluxes at the cell faces.更新<code>phi</code></li>
<li>Correct the velocities on the basis of the new pressure field. 更新<code>U</code></li>
<li>Update the boundary conditions.更新<code>U</code>的边界条件</li>
<li>Repeat from 3 for the prescribed number of times. 重复piso循环，<ol>
<li>这个是由<code>piso.correct()</code>控制的，而<code>piso.correct()</code>是由变量<code>label corrPISO_</code>控制的。</li>
<li>重复的时候，UEqn所引用的<code>U</code>是有更新的。所以用UEqn构造的<code>UEqn.A(), UEqn.H()</code>也可能会有所更新。</li>
</ol>
</li>
<li>Increase the time step and repeat from 1. 下一个时间步，这里是由<code>runTime.loop()</code>控制的。</li>
</ol>
<p>OpenFOAM中的PISO求解器其实有两个，最简单的是icoFoam，用的是PISO算法解层流。复杂一点的是pisoFoam，带有湍流模型。</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h4 id="solutionControl及其子类的继承关系"><a href="#solutionControl及其子类的继承关系" class="headerlink" title="solutionControl及其子类的继承关系"></a>solutionControl及其子类的继承关系</h4><ul>
<li>pisoControl是pimpleControl的子类！</li>
<li>pimpleContrl是solutionControl的子类</li>
<li>simpleControl是solutionControl的子类。</li>
</ul>
<h4 id="松弛"><a href="#松弛" class="headerlink" title="松弛"></a>松弛</h4><p>从代码中可以发现，pisoFoam和icoFoam对于压力和动量方程是没有进行松弛的。这是因为它要进行的是<strong>时间精确</strong>的模拟。</p>
<p>但是如果你用的ddt格式本来就不是时间精确的话，额，还是不要用PISO了，改用PIMPLE吧。加点松弛因子可能还稳定些。</p>
<h2 id="PIMPLE算法"><a href="#PIMPLE算法" class="headerlink" title="PIMPLE算法"></a>PIMPLE算法</h2><p>PIMPLE算法是SIMPLE和PISO的结合。因为PISO只有一个预测步，所以PISO的稳定性限制了它只能用于瞬态计算并且时间步不能取得太大，而SIMPLE没有时间项只能用于稳态计算（或者采用伪时间步方法用于瞬态计算）。PIMPLE算法的核心是把UEqn<strong>重新生成</strong>并解了很多次！</p>
<ul>
<li>pimpleFoam中的<code>#include &quot;UEqn.H&quot;</code> 语句是被包在<code>pimple.loop()</code>循环内的。</li>
<li>pisoFoam中的<code>#include &quot;UEqn.H&quot;</code>语句没有被包裹，每次<code>runTime.loop()</code>只运行一次。</li>
<li>pisoFoam中没有使用<code>consistent</code>关键字，所以没有SIMPLE-C修正。</li>
<li>pimpleFoam中使用了<code>consistent</code>关键字，所以和simpleFoam一样，对phiHbyA进行了SIMPLE-C处理。</li>
<li>simpleFoam中使用的<code>simple.loop()</code>而不是<code>runTime.loop()</code>，但是它调用了<code>runTime.loop()</code></li>
</ul>
<h3 id="PIMPLE里的三层循环"><a href="#PIMPLE里的三层循环" class="headerlink" title="PIMPLE里的三层循环"></a>PIMPLE里的三层循环</h3><p>总结起来，PIMPLE算法每个时间步（由<code>runTime.loop()</code>控制）有三层循环：</p>
<ul>
<li>外层<code>pimple.loop()</code>类似SIMPLE循环<ul>
<li>利用当前的<code>U</code>，生成并求解<code>UEqn</code></li>
<li>中层<code>pimple.correct()</code>，几乎就是PISO循环，负责压力求解<ul>
<li>利用<code>UEqn</code> 构造<code>rAU</code>, <code>HbyA</code></li>
<li><code>HbyA</code> 生成<code>phiHbyA</code>，加入<code>fvc::ddtCorr(U,phi)</code>修正。</li>
<li><code>adjustPhi()</code></li>
<li>利用<code>consistent</code>关键字对<code>phiHbyA</code>进行SIMPLE-C一致性修正</li>
<li><code>constrainPressure()</code></li>
<li>内层<code>pimple.correctNonOrthogonal()</code>非正交修正循环<ul>
<li>构造压力联系方程<code>pEqn</code></li>
<li><code>pEqn.setReference()</code></li>
<li>用新的<code>p</code>作为初始值求解<code>pEqn</code>，进行非正交修正。</li>
</ul>
</li>
<li>更新<code>U</code>和<code>phi</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>而SIMPLE算法没有中层循环，PISO算法没有外层循环。所以PIMPLE算法可以简化为PISO算法，但是由于SIMPLE算法中没有包含非定常项，所以PIMPLE算法要等同于SIMPLE算法需要使<code>ddt</code>项的格式需要指定为<code>steadyState</code>。</p>
<h2 id="一些编程细节"><a href="#一些编程细节" class="headerlink" title="一些编程细节"></a>一些编程细节</h2><p>此外在程序代码中还有好多稀奇古怪的乱七八糟玩意儿。</p>
<h3 id="solutionControl及其子类的变量命名规范"><a href="#solutionControl及其子类的变量命名规范" class="headerlink" title="solutionControl及其子类的变量命名规范"></a><code>solutionControl</code>及其子类的变量命名规范</h3><p>OpenFOAM里的求解控制类是<code>solutionControl</code> 及其子类<code>simpleControl</code>, <code>pisoControl</code>和<code>pimpleControl</code>。其中定义了很多变量，其命名规范是：</p>
<ul>
<li><code>label xxx_</code>表示迭代变量，比如<code>corr_,</code> <code>corrNonOrtho_</code>,pimpleControl中的 <code>corrPISO_</code>等。</li>
<li><code>label nXxx_</code>表示<strong>迭代上限次数</strong>，比如<code>nCorrNonOrtho_</code>（实际迭代次数是<code>nCorrNonOrtho_+1</code>，因为第一次求解不算所谓修正），pimpleControl中的<code>nCorrPIMPLE_</code>, <code>nCorrPISO_</code></li>
<li><code>bool yyy_</code>表示标志量，比如<code>transonic_</code>, <code>consistent_</code>, <code>momentumPredictor_</code></li>
<li><code>residualControl_</code> 残差控制。</li>
</ul>
<ul>
<li>以pimpleControl为例，其迭代循环变量和控制变量标志如下表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>含义</th>
<th>迭代量的变量名</th>
<th>迭代上限的变量名</th>
<th>配置文件中的关键字</th>
<th>默认值</th>
<th>判断是否执行的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>外部迭代，又叫PIMPLE迭代</td>
<td><code>label corr_</code></td>
<td><code>nCorrPIMPLE_</code></td>
<td><code>nOuterCorrectors</code></td>
<td>1</td>
<td><code>loop()</code></td>
</tr>
<tr>
<td>PISO压力修正循环</td>
<td><code>label corrPISO_</code></td>
<td><code>nCorrPISO_</code></td>
<td><code>nCorrectors</code></td>
<td>1</td>
<td><code>correct()</code></td>
</tr>
<tr>
<td>非正交修正</td>
<td><code>label corrNonOrtho_</code></td>
<td><code>nCorrNonOrtho_</code> <strong>这是实际迭代次数上限减1</strong></td>
<td><code>nNonOrthogonalCorrectors</code></td>
<td>0</td>
<td><code>correctNonOrthogonal()</code></td>
</tr>
<tr>
<td>是否执行动量预测步</td>
<td><code>bool momentumPredictor_</code></td>
<td></td>
<td><code>momentumPredictor</code></td>
<td>true</td>
<td><code>momentumPredictor()</code></td>
</tr>
<tr>
<td>一致性</td>
<td><code>bool consistent_</code></td>
<td></td>
<td><code>consistent</code></td>
<td>false</td>
<td><code>consistent()</code></td>
</tr>
<tr>
<td>跨声速</td>
<td><code>bool transonic</code></td>
<td></td>
<td><code>transonic</code></td>
<td>false</td>
<td><code>transonic()</code></td>
</tr>
<tr>
<td>是否在PISO循环外更新密度</td>
<td><code>bool SIMPLErho_</code></td>
<td></td>
<td><code>SIMPLErho</code></td>
<td>false</td>
<td><code>SIMPLErho()</code></td>
</tr>
<tr>
<td>仅在最后迭代启用湍流</td>
<td><code>bool turbOnFinalIterOnly_</code></td>
<td></td>
<td><code>turbOnFinalIterOnly</code></td>
<td>true</td>
<td><code>momentumPredictor()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="simpleFoam中phi变量的更新。"><a href="#simpleFoam中phi变量的更新。" class="headerlink" title="simpleFoam中phi变量的更新。"></a>simpleFoam中<code>phi</code>变量的更新。</h3><p>如果仔细的人应该会发现，<code>phi</code>这个变量在simpleFoam中是由<code>createFields.H</code>调用<code>createPhi.H</code>创建的，然后在<code>UEqn.H</code>中被<code>fvm::div(phi,U)</code>使用，那么在下一次迭代之前它是如何更新的呢？</p>
<p>我们发现它是在<code>pEqn.H</code>中更新的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pEqn.H</span></span><br><span class="line">	<span class="keyword">if</span> (simple.finalNonOrthogonalIter())</span><br><span class="line">        &#123;</span><br><span class="line">            phi = phiHbyA - pEqn.flux();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于adjustPhi-和-setReference"><a href="#关于adjustPhi-和-setReference" class="headerlink" title="关于adjustPhi, 和 setReference"></a>关于adjustPhi, 和 setReference</h3><p>adjustPhi和pRef针对的是压力方程为全Neuman边界的情况<sup><a href="#fn_12" id="reffn_12">12</a></sup>，这时解的存在唯一性可能会有两个问题:</p>
<ul>
<li>唯一性：方程系数矩阵M 列秩不满时，解有无穷多（例如$x_1+x_2=1,2x_1+2x_2=2$），互之间相差一组常数（或者一组常函数，或零空间元素），所以需要setReference</li>
<li>存在性：方程的增广矩阵秩和M的秩不一样时（例如$x_1+x_2=1,-x_1-x_2=-2$），存在相容性问题，需要<code>adjustPhi</code></li>
</ul>
<p>关于线性代数知识可以参考<sup><a href="#fn_23" id="reffn_23">23</a></sup></p>
<blockquote id="fn_23">
<sup>23</sup>. <a href="http://math.fudan.edu.cn/gdsx/JIAOAN/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84.pdf" target="_blank" rel="noopener">教案： 线性方程组</a><a href="#reffn_23" title="Jump back to footnote [23] in the text."> &#8617;</a>
</blockquote>
<h4 id="方程多解问题：setReference"><a href="#方程多解问题：setReference" class="headerlink" title="方程多解问题：setReference"></a>方程多解问题：setReference</h4><p>当方程为：</p>
<script type="math/tex; mode=display">
\Delta p = f \text{ on }\Omega \\


\nabla p \cdot \mathbf n = g \text{ on }\partial \Omega</script><p>首先，如果$p_1$是一个解，那么$p_2=p_1+const$也是方程的解，方程解不唯一，所以离散方程会有奇异性，无法求解。<br>解决方法是固定一个点的压力为给定值，就是设置<code>setReference</code>。</p>
<h4 id="方程相容性问题：adjustPhi"><a href="#方程相容性问题：adjustPhi" class="headerlink" title="方程相容性问题：adjustPhi"></a>方程相容性问题：adjustPhi</h4><p>p变量前面是直接加了微分的，所以需要对于全Neumann条件的情形还需要满足<strong>相容性条件</strong>：</p>
<script type="math/tex; mode=display">
\int_{\Omega}{f dV} =\int_{\Omega}{\Delta p dV} = \int_{ \partial\Omega}{\nabla p \cdot\mathbf n dS}

= \int_{ \partial\Omega}{g dS}</script><p>这就是adjustPhi去强制满足这个条件。<br>带入f和g的表达式</p>
<script type="math/tex; mode=display">
f= \nabla\cdot\mathbf u^*\\

g=0</script><p>可得：</p>
<script type="math/tex; mode=display">
\int_{\Omega}{\nabla \cdot \mathbf u^* dV} =\int_{\partial \Omega}{\mathbf u^*dS}= 0</script><p>你再看看adjustPhi出现的位置，是在pEqn.H中，对phiHbyA进行的调整。其实也就是这里的$\mathbf u^*$项。必须使其满足以上相容性条件。</p>
<h3 id="关于constrainPressure和constrainHbyA"><a href="#关于constrainPressure和constrainHbyA" class="headerlink" title="关于constrainPressure和constrainHbyA"></a>关于<code>constrainPressure</code>和<code>constrainHbyA</code></h3><p>从OpenFOAM的4.0版本开始，引入了<code>fixedFluxPressure,fixedFluxExtraoplatedPressure</code>边界条件，从而使入口的压力可以浮动，且边界压力梯度还可以根据计算情况进行调整，于是引入了<code>constrainPressure()</code>和<code>constrainHbyA()</code>函数。 </p>
<p>其说明可以参考<a href="http://caefn.com/" target="_blank" rel="noopener">Fumiya Nozaki’s CFD Blog</a>的这篇blog：<a href="http://caefn.com/openfoam/solvers-recent-changes" target="_blank" rel="noopener">Recent changes in the basics of the OpenFOAM solvers</a>和 <a href="http://caefn.com/openfoam/ja-bc-fixedfluxpressure" target="_blank" rel="noopener">fixedFluxPressure 境界条件</a>。 </p>
<h4 id="constrainPressure用于调整压力p的边界"><a href="#constrainPressure用于调整压力p的边界" class="headerlink" title="constrainPressure用于调整压力p的边界"></a><code>constrainPressure</code>用于调整压力p的边界</h4><p>可压缩流中边界速度$U_f$在离散生成<code>UEqn</code>之后可以表示为：</p>
<script type="math/tex; mode=display">
\begin{equation} 
\rho \boldsymbol{U}_f \cdot \boldsymbol{S}_f = \left(\frac{\rho \boldsymbol{H} }{A_p}\right)_f \cdot \boldsymbol{S}_f\;-\;\left(\frac{\rho}{A_p}\right)_f (\nabla p)_f \cdot \boldsymbol{S}_f. \tag{1} \label{eq:1} 
\end{equation}</script><p>所以界面法向压力梯度可以表示为：</p>
<script type="math/tex; mode=display">
\begin{equation} 
(\nabla p)_f \cdot \boldsymbol{n}_f = \frac{1}{|\boldsymbol{S}_f|\left(\frac{\rho}{A_p}\right)_f} \left(\left(\frac{\rho \boldsymbol{H} }{A_p}\right)_f \cdot \boldsymbol{S}_f\;-\;\rho \boldsymbol{U}_f \cdot \boldsymbol{S}_f \right). \tag{2} \label{eq:2} 
\end{equation}</script><p>将上述关系运用于压力边界条件，就是<code>constrainPressure</code>要干的事儿。</p>
<ul>
<li><code>void constrainPressure(p,rho=1,U,phiHbyA,rhorAU,MRF=NULLMRF)</code><ul>
<li>输出调整的其实是p</li>
<li>必要的输入有<code>U,phiHbyA,rhorAU</code></li>
</ul>
</li>
</ul>
<ul>
<li>p边界条件继承于<code>fixedFluxPressureFvPatchScalarField</code>的才会调整。</li>
</ul>
<h4 id="constrainHbyA-tHbyA-U-p-用于返回调整后的tHbyANew变量"><a href="#constrainHbyA-tHbyA-U-p-用于返回调整后的tHbyANew变量" class="headerlink" title="constrainHbyA(tHbyA,U,p)用于返回调整后的tHbyANew变量"></a><code>constrainHbyA(tHbyA,U,p)</code>用于返回调整后的<code>tHbyANew</code>变量</h4><ul>
<li>循环每个边界</li>
<li>当<code>U</code>的在这个边界的边界条件是<code>assignable()==false</code></li>
<li>且<code>p</code>的在这个边界是继承自<code>fixedFluxExtrapolatedPressureFvPatchScalarField</code></li>
<li><code>tHbyANew</code>的这个 这边界设置为和<code>U</code>的这个边界相同的值。</li>
<li>返回<code>tHbyANew</code></li>
<li>为什么要这么做：我也不知道。可能这样做了之后<code>constrainPressure()</code>得到的压力和<code>HbyA</code>在固定速度的边界与前述PLE方程就是一致的了，毕竟前面的<code>constrainPressure()</code>是利用了<code>HbyA</code>生成的<code>phiHbyA</code>的。</li>
<li>如果没有用到<code>fixedFluxExtrapolatedPressure</code>和 <code>fixedFluxPressure</code>边界条件，这两个函数其实相当于没有作用。</li>
</ul>
<h3 id="关于fvc-ddtCorr-和fvc-ddtPhiCorr"><a href="#关于fvc-ddtCorr-和fvc-ddtPhiCorr" class="headerlink" title="关于fvc::ddtCorr()和fvc::ddtPhiCorr()"></a>关于fvc::ddtCorr()和fvc::ddtPhiCorr()</h3><p>对于非稳态的求解器，如pimpleFoam, pisoFoam和icoFoam中，<code>phiHbyA</code>在构造时除了用到<code>HbyA</code> 向的插值，还会用到<code>fvc::ddtCorr()</code>，这一项主要是为了修正非定常和松弛因子对解的影响。而且这一项还是和OpenFOAM版本历史相关的！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OpenFOAM 5.x, 4.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +77</span></span><br><span class="line">            surfaceScalarField phiHbyA</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"phiHbyA"</span>,</span><br><span class="line">                fvc::flux(HbyA) <span class="comment">//这里用了fvc::flux函数，而不是原来的interpolate 和 &amp; 算符</span></span><br><span class="line">              + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi) <span class="comment">//用的是ddtCorr!</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"><span class="comment">//OpenFOAM 2.3.x, 2.4.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C  +73</span></span><br><span class="line">            surfaceScalarField phiHbyA</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"phiHbyA"</span>,</span><br><span class="line">                (fvc::interpolate(HbyA) &amp; mesh.Sf())</span><br><span class="line">              + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi) <span class="comment">//用的是ddtCorr</span></span><br><span class="line">            );</span><br><span class="line"><span class="comment">//OpenFOAM 2.2.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +73</span></span><br><span class="line">            surfaceScalarField phiHbyA<span class="comment">//用了新的变量名!</span></span><br><span class="line">            (</span><br><span class="line">                <span class="string">"phiHbyA"</span>,</span><br><span class="line">                (fvc::interpolate(HbyA) &amp; mesh.Sf()) </span><br><span class="line">              + fvc::ddtPhiCorr(rAU, U, phi) <span class="comment">//用的是ddtPhiCorr!</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//OpenFOAM 2.1.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +72</span></span><br><span class="line">            phi = (fvc::interpolate(U) &amp; mesh.Sf())</span><br><span class="line">                + fvc::ddtPhiCorr(rAU, U, phi);</span><br><span class="line"></span><br><span class="line"><span class="comment">//foam-extend 4.0</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +86</span></span><br><span class="line">            U = HUEqn.H()/aU; <span class="comment">//注意这里的HUEqn不包含非定常项</span></span><br><span class="line">            phi = (fvc::interpolate(U) &amp; mesh.Sf()); <span class="comment">//所以这里也不包含。</span></span><br></pre></td></tr></table></figure>
<p>太老的就不管了，因为根据OpenFOAM.org官网的<a href="https://openfoam.org/release/2-3-0/numerics/" target="_blank" rel="noopener">更新说明</a>，2.3.0版本时已经把<code>ddtPhiCorr</code>换成了<code>ddtCorr</code>。</p>
<p>首先找OpenFOAM 5.x的代码，看看<code>ddtCorr()</code>到底是干啥的 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/fvc/fvcDdt.C +183</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;GeometricField&lt;typename flux&lt;Type&gt;::type, fvsPatchField, surfaceMesh&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">ddtCorr</span></span></span><br><span class="line"><span class="class">(</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">GeometricField</span>&lt;Type, fvPatchField, volMesh&gt;&amp; <span class="title">U</span>,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">GeometricField</span></span></span><br><span class="line"><span class="class">    &lt;</span></span><br><span class="line"><span class="class">        typename flux&lt;Type&gt;::type,</span></span><br><span class="line"><span class="class">        fvsPatchField,</span></span><br><span class="line"><span class="class">        surfaceMesh</span></span><br><span class="line"><span class="class">    &gt;&amp; <span class="title">phi</span></span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> fv::ddtScheme&lt;Type&gt;::New <span class="comment">//根据变量名返回tmp&lt;ddtScheme&lt;Type&gt;&gt;的临时对象</span></span><br><span class="line">    (</span><br><span class="line">        U.mesh(),</span><br><span class="line">        U.mesh().ddtScheme(<span class="string">"ddt("</span> + U.name() + <span class="string">')'</span>)</span><br><span class="line">    ).ref().fvcDdtPhiCorr(U, phi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里涉及到RTS机制，</span></span><br><span class="line"><span class="comment">//为了简化，参考steadyState和经典的Euler格式是怎么做的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/ddtSchemes/steadyStateDdtScheme/steadyStateDdtScheme.C +305</span></span><br><span class="line"><span class="comment">//steadyState返回的是0，无修正，这很正常。</span></span><br><span class="line"><span class="comment">//返回值的量纲是：phi.dimensions()/dimTime</span></span><br><span class="line"><span class="comment">//对于不可压缩流应该是L^3/T^2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;typename steadyStateDdtScheme&lt;Type&gt;::fluxFieldType&gt;</span></span><br><span class="line"><span class="class"><span class="title">steadyStateDdtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCorr</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;fluxFieldType&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> fluxFieldType</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"ddtCorr("</span> + U.name() + <span class="string">','</span> + phi.name() + <span class="string">')'</span>,</span><br><span class="line">                mesh().time().timeName(),</span><br><span class="line">                mesh()</span><br><span class="line">            ),</span><br><span class="line">            mesh(),</span><br><span class="line">            dimensioned&lt;<span class="keyword">typename</span> flux&lt;Type&gt;::type&gt;</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"0"</span>,</span><br><span class="line">                phi.dimensions()/dimTime,</span><br><span class="line">                Zero</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Euler格式的修正</span></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/ddtSchemes/EulerDdtScheme/EulerDdtScheme.C +534</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;typename EulerDdtScheme&lt;Type&gt;::fluxFieldType&gt;</span></span><br><span class="line"><span class="class"><span class="title">EulerDdtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCorr</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    dimensionedScalar rDeltaT = <span class="number">1.0</span>/mesh().time().deltaT(); <span class="comment">//时间增量的倒数</span></span><br><span class="line"></span><br><span class="line">    fluxFieldType phiCorr</span><br><span class="line">    (</span><br><span class="line">        phi.oldTime() - fvc::dotInterpolate(mesh().Sf(), U.oldTime())</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp&lt;fluxFieldType&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> fluxFieldType</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"ddtCorr("</span> + U.name() + <span class="string">','</span> + phi.name() + <span class="string">')'</span>,</span><br><span class="line">                mesh().time().timeName(),</span><br><span class="line">                mesh()</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">this</span>-&gt;fvcDdtPhiCoeff(U.oldTime(), phi.oldTime(), phiCorr)</span><br><span class="line">           *rDeltaT*phiCorr</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//涉及到fvcDdtPhiCoeff系数，继续查找，发现这个函数位于ddtScheme中。</span></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.C +151</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;surfaceScalarField&gt; <span class="title">ddtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCoeff</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phiCorr</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;surfaceScalarField&gt; tddtCouplingCoeff = scalar(<span class="number">1</span>)</span><br><span class="line">      - min</span><br><span class="line">        (</span><br><span class="line">            mag(phiCorr)</span><br><span class="line">           /(mag(phi) + dimensionedScalar(<span class="string">"small"</span>, phi.dimensions(), SMALL)),</span><br><span class="line">            scalar(<span class="number">1</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    surfaceScalarField&amp; ddtCouplingCoeff = tddtCouplingCoeff.ref();</span><br><span class="line"></span><br><span class="line">    surfaceScalarField::Boundary&amp; ccbf =</span><br><span class="line">        ddtCouplingCoeff.boundaryFieldRef();</span><br><span class="line"></span><br><span class="line">    forAll(U.boundaryField(), patchi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">        (</span><br><span class="line">            U.boundaryField()[patchi].fixesValue()</span><br><span class="line">         || isA&lt;cyclicAMIFvPatch&gt;(mesh().boundary()[patchi])</span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            ccbf[patchi] = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InfoInFunction</span><br><span class="line">            &lt;&lt; <span class="string">"ddtCouplingCoeff mean max min = "</span></span><br><span class="line">            &lt;&lt; gAverage(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMax(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMin(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tddtCouplingCoeff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以OpenFOAM的<code>ddtCorr</code>的算法如下：</p>
<ol>
<li>首先用过去时间的通量$\phi^{n-1}$和速度$U^{n-1}$估算通量的修正$\phi^{c}$。</li>
</ol>
<ol>
<li><script type="math/tex; mode=display">
\phi^{c} = \phi^{n-1} - U_f(U^{n-1})\cdot \mathbf S_f</script></li>
<li><p>计算ddt耦合系数$K_c$：</p>
<script type="math/tex; mode=display">
K_c = 1 - \min\left( \frac {|\phi^c|}{|\phi^{n-1}|+\epsilon}, 1\right)</script><p>同时，应该注意到，ddt耦合系数$K_c$是一个大于0的无量纲界面张量场！它的边界条件也被特殊地处理了，对于固定速度边界或cyclicAMI边界，它的值是0.</p>
</li>
<li><p>输出修正量$\phi^k = K_c\phi^c/\Delta t$</p>
</li>
</ol>
<p>但是为什么这么计算耦合系数$K_c$和通量$\phi^c$，我也不知道！ </p>
<ul>
<li><a href="https://www.cfd-online.com/Forums/openfoam-solving/60096-ddtphicorr.html#post516511" target="_blank" rel="noopener">cfd-online上一个叫eugene的id提到</a><code>ddtCorr</code>实质上是文献<sup><a href="#fn_19" id="reffn_19">19</a></sup>中的所谓Choi Correction，对应的原始文献是<sup><a href="#fn_20" id="reffn_20">20</a></sup> ，但发帖者认为<code>fvcDdtPhiCoeff = 1</code>时是完整的Choi Correction，但此时OpenFOAM会不稳定，所以用了一个经验性的<code>fvcDdtPhiCoeff()</code>函数来限制这个Choi Correction。</li>
</ul>
<h4 id="Jasak的搞法"><a href="#Jasak的搞法" class="headerlink" title="Jasak的搞法"></a>Jasak的搞法</h4><p>Jasak似乎玩了另外的花样。在foam-extend 4.0中，Jasak的icoFoam和OpenFOAM.org以及OpenFOAMplus的icoFoam就不一样了。</p>
<ul>
<li><p>Jasak的icoFoam把<code>UEqn</code>分成了<code>HUEqn</code>和<code>ddtUEqn</code>两部分：</p>
</li>
<li><ul>
<li><code>HUEqn</code>： 对流和扩散项</li>
<li><code>ddtUEqn</code>：非定常项；</li>
</ul>
</li>
<li><p>动量预测步：<code>HUEqn + ddtUEqn == -grad(p)</code></p>
</li>
<li><p>PISO循环中：<code>H</code>从<code>HUEqn.H()</code>中产生！与时间步完全无关。</p>
</li>
<li><p>速度更新：</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://github.com/Unofficial-Extend-Project-Mirror/foam-extend-foam-extend-4.0/blob/master/applications/solvers/incompressible/icoFoam/icoFoam.C +113</span></span><br><span class="line"><span class="comment">// Note: cannot call H(U) here because the velocity is not complete</span></span><br><span class="line"><span class="comment">// HJ, 22/Jan/2016</span></span><br><span class="line">U = <span class="number">1.0</span>/(aU + ddtUEqn.A())*</span><br><span class="line">(</span><br><span class="line">    U*aU - fvc::grad(p) + ddtUEqn.H()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Jasak 认为这使得代码更加清晰了（时间导数算子中完全去掉了<code>ddtPhiCorr</code>和<code>ddtCorr</code>）。而且<strong>完全消除了时间步和松弛因子对结果的影响</strong>。结果对比参考文献<sup><a href="#fn_17" id="reffn_17">17</a></sup></p>
<h4 id="投影法"><a href="#投影法" class="headerlink" title="投影法"></a>投影法</h4><p>另外一种选择是用投影法，参考文献<sup><a href="#fn_21" id="reffn_21">21</a></sup>。 投影法在同位网格上可以避免Rhie-Chow插值，从而避免这个<code>ddtCorr()</code>的问题。 他们也做了数值试验来观察这个质量通量修正项（mass flux correction term）对PISO算法的效果。发现扔掉这一项，PISO算法的耗散大大降低。</p>
<h4 id="OpenFOAMplus的搞法"><a href="#OpenFOAMplus的搞法" class="headerlink" title="OpenFOAMplus的搞法"></a>OpenFOAMplus的搞法</h4><p>OpenFOAMplus在v1706中的<code>ddtScheme</code>加入了一个<code>scalar ddtPhiCoeff_</code>的定义。从而使<code>ddtCorr()</code>的实现更加复杂化。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://develop.openfoam.com/Development/OpenFOAM-plus/blob/master/src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.H</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ddtScheme</span></span></span><br><span class="line"><span class="class">:</span></span><br><span class="line">    <span class="keyword">public</span> tmp&lt;ddtScheme&lt;Type&gt;&gt;::refCount</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> fvMesh&amp; mesh_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Input for fvcDdtPhiCoeff (-1 default)</span></span><br><span class="line">        scalar ddtPhiCoeff_; <span class="comment">//ebf654f2这个集成rhoPimpleAdiabaticFoam的提交中才出现的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>而此时更改为了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://develop.openfoam.com/Development/OpenFOAM-plus/blob/master/src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.C +151</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;surfaceScalarField&gt; <span class="title">ddtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCoeff</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phiCorr</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;surfaceScalarField&gt; tddtCouplingCoeff</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> surfaceScalarField</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"ddtCouplingCoeff"</span>,</span><br><span class="line">                U.mesh().time().timeName(),</span><br><span class="line">                U.mesh()</span><br><span class="line">            ),</span><br><span class="line">            U.mesh(),</span><br><span class="line">            dimensionedScalar(<span class="string">"one"</span>, dimless, <span class="number">1.0</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    surfaceScalarField&amp; ddtCouplingCoeff = tddtCouplingCoeff.ref();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ddtPhiCoeff_ &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ddtCouplingCoeff -= min</span><br><span class="line">        (</span><br><span class="line">            mag(phiCorr)</span><br><span class="line">           /(mag(phi) + dimensionedScalar(<span class="string">"small"</span>, phi.dimensions(), SMALL)),</span><br><span class="line">            scalar(<span class="number">1</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ddtCouplingCoeff =</span><br><span class="line">            dimensionedScalar(<span class="string">"ddtPhiCoeff"</span>, dimless, ddtPhiCoeff_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    surfaceScalarField::Boundary&amp; ccbf = ddtCouplingCoeff.boundaryFieldRef();</span><br><span class="line"></span><br><span class="line">    forAll(U.boundaryField(), patchi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">        (</span><br><span class="line">            U.boundaryField()[patchi].fixesValue()</span><br><span class="line">         || isA&lt;cyclicAMIFvPatch&gt;(mesh().boundary()[patchi])</span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            ccbf[patchi] = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InfoInFunction</span><br><span class="line">            &lt;&lt; <span class="string">"ddtCouplingCoeff mean max min = "</span></span><br><span class="line">            &lt;&lt; gAverage(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMax(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMin(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tddtCouplingCoeff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样使得可以这个系数可以手工调整。</p>
<p>他们所引用的参考文献<sup><a href="#fn_22" id="reffn_22">22</a></sup> 暂时没找到全文</p>
<h3 id="关于p-pFinal的选择"><a href="#关于p-pFinal的选择" class="headerlink" title="关于p,pFinal的选择"></a>关于<code>p,pFinal</code>的选择</h3><p>仔细的哥们儿会发现simpleFoam里用的是<code>pEqn.solve()</code>，到了icoFoam, pisoFoam和pimpleFoam里用的就是<code>pEqn.solve(mesh.solver(p.select(piso/pimple.finalInnerIter())))</code>。</p>
<p>这里的区别，还是看代码吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/finiteVolume/cfdTools/general/solutionControl/pimpleControl/pimpleControlI.H +92</span></span><br><span class="line"><span class="comment">//最后一步内迭代，也就是最后一次用PISO求解压力且是非正交修正的最后一步时返回true，否则返回false</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Foam::pimpleControl::finalInnerIter() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">       corrPISO_ == nCorrPISO_</span><br><span class="line">    &amp;&amp; corrNonOrtho_ == nNonOrthCorr_ + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/OpenFOAM/fields/GeometricFields/GeometricField/GeometricField.C +985</span></span><br><span class="line"><span class="comment">//true，也就是最后一次迭代时返回名字`pFinal`，否则返回名字`p`</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>, <span class="title">template</span>&lt;class&gt; <span class="title">class</span> <span class="title">PatchField</span>, <span class="title">class</span> <span class="title">GeoMesh</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:word Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;::select</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">bool</span> final</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (final)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name() + <span class="string">"Final"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/OpenFOAM/matrices/solution/solution.C +353</span></span><br><span class="line"><span class="comment">// 返回name对应的solver controls dictionary</span></span><br><span class="line"><span class="keyword">const</span> Foam::dictionary&amp; Foam::solution::solver(<span class="keyword">const</span> word&amp; name) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; <span class="string">"Lookup solver for "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solvers_.subDict(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/fvMatrices/fvMatrix/fvMatrixSolve.C +55</span></span><br><span class="line"><span class="comment">//按这个solverControls来解</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:SolverPerformance&lt;Type&gt; Foam::fvMatrix&lt;Type&gt;::solve</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; solverControls</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>结论：simpleFoam是稳态求解器，所以没有pFinal一说，所以用不着这套复杂的机制。</p>
<h3 id="关于收敛判据和求解控制"><a href="#关于收敛判据和求解控制" class="headerlink" title="关于收敛判据和求解控制"></a>关于收敛判据和求解控制</h3><p>对于不可压缩流动而言， 收敛判据只取决于两个问题，</p>
<ol>
<li>连续性方程是否得到满足，在多大程度上得到满足？<ol>
<li>OpenFOAM里是用<code>#include &quot;continuityErrs.H&quot;</code>来计算、记录和输出这一项的。<ol>
<li>程序开始时还需要用 <code>include &quot;initContinuityErrs.H&quot;</code> 初始化一下。</li>
<li>它用的是<code>phi</code>而不是<code>U</code></li>
<li>它会记录累计误差<code>cumulativeContErr</code>，全场流量平衡误差<code>globalContErr</code>，以及局部误差的和<code>sumLocalContErr</code>（最后一项几乎等价于速度场散度的L1模：$|\nabla\cdot U|_{L1}$）</li>
</ol>
</li>
<li>事实上这点比较简单，因为每次计算压力的时候都是力图使连续性方程得到满足的。</li>
<li>而且这一项与非定常项无关。</li>
</ol>
</li>
<li>动量方程在多大程度上得到满足：<ol>
<li>这点在OpenFOAM里是通过对动量方程的求解来满足的。</li>
<li>其实OpenFOAM并没有对其进行严格地度量（指L1, L2模这样的数学度量）。</li>
<li>对于稳态算法SIMPLE，看<strong>最终一步</strong>的动量方程的的<strong>初始残差</strong>；</li>
<li>对于非稳态算法（PISO, PIMPLE等）<strong>输出</strong>中的<strong>每个时间步最后一次外迭代</strong>时，动量方程的<strong>初始残差</strong>可以认为是一个度量，但是它并不完全一致和严格。<ol>
<li><strong>每个时间步</strong> 是因为非稳态算法一般是需要进行时间精确模拟的。如果这个时间步没有收敛，这个时间步就不对，并且会影响到下一个时间步。</li>
<li><strong>最后一次</strong> 是因为前面的算是中间过程，最后并不保存下来；</li>
<li><strong>外迭代</strong>是因为内迭代是解耦计算，有时候看上去残差很小，可能并没有卵用，一耦合残差又超级大。<ol>
<li>对SIMPLE对应着<code>simple.loop()</code></li>
<li>对PIMPLE对应着<code>pimple.loop()</code></li>
</ol>
</li>
<li><strong>初始残差</strong>是因为OpenFOAM输出的残差都是线性求解器输出的，而其中线性求解器输出的只有初始残差是和非线性残差是一致的。<ol>
<li>经过线性求解器的迭代，线性残差可能会很小，甚至到机器零；</li>
<li>但是这个解只有对初始解产生的矩阵系数是对的，如果把矩阵系数按照得到的解重新计算，得到的残差才算是非线性残差（严格说来也不完全一样，但是差不多啦）；</li>
<li>这个非线性残差小才算是收敛 ；</li>
<li>另外，即使非线性残差小不代表误差小；</li>
<li>时间步很大时，网格很粗时，即使残差为0，<strong>误差</strong>也可能很大；</li>
</ol>
</li>
<li>实际得到的解因为是最后一次外迭代完成之后的解，一般来说其非线性残差可能会比输出中的初始残差更小一些。但是这个数据并没有被计算和输出。</li>
</ol>
</li>
<li>参考<a href="https://chengdi123000.github.io/2018/01/04/OpenFOAM%E7%9A%84%E6%AE%8B%E5%B7%AE%E5%AE%9A%E4%B9%89/">OpenFOAM的残差定义</a></li>
</ol>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_1">
<sup>1</sup>. <a href="https://holzmann-cfd.de/publications/mathematics-numerics-derivations-and-openfoam" target="_blank" rel="noopener">MATHEMATICS, NUMERICS, DERIVATIONS AND OPENFOAM®</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. <strong>Patankar, S. V. and Spalding, D.B. (1972)</strong>, “A calculation procedure for heat, mass and momentum transfer in three-dimensional parabolic flows”, Int. J. of Heat and Mass Transfer, Volume 15, Issue 10, October 1972, Pages 1787-1806<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. <a href="https://mycourses.aalto.fi/pluginfile.php/458332/mod_folder/content/0/CHEM-E7160%20Pressure%20Correction%20Scheme.pdf?forcedownload=1" target="_blank" rel="noopener">Pressure Correction Scheme for Incompressible Fluid Flow </a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. S.V. Patankar. Numerical Heat Transfer and Fluid Flow. Hemisphere, 1980<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_5">
<sup>5</sup>. Caretto L.S., Gosman A.D., Patankar S.V., Spalding D.B. (1973) Two calculation procedures for steady, three-dimensional flows with recirculation. In: Cabannes H., Temam R. (eds) Proceedings of the Third International Conference on Numerical Methods in Fluid Mechanics. Lecture Notes in Physics, vol 19. Springer, Berlin, Heidelberg<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_6">
<sup>6</sup>. <a href="http://thevisualroom.com/poisson_for_pressure.html" target="_blank" rel="noopener">http://thevisualroom.com/poisson_for_pressure.html</a><a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_7">
<sup>7</sup>. Lee S L, Tzong R Y. Artificial pressure for pressure-linked equation[J]. International journal of heat and mass transfer, 1992, 35(10): 2705-2716.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_8">
<sup>8</sup>. <a href="http://dyfluid.com/RhieChow.html" target="_blank" rel="noopener">http://dyfluid.com/RhieChow.html</a><a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_9">
<sup>9</sup>. <a href="http://www4.ncsu.edu/eos/users/w/white/www/white/ma587/lec24.pdf" target="_blank" rel="noopener">Nonlinear Systems: Picard and Newton methods</a> <a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_10">
<sup>10</sup>. <a href="https://books.google.com/books?id=fvX_umNtz_cC&amp;lpg=PA514&amp;ots=qdoBREZy6u&amp;dq=%E6%8A%95%E5%BD%B1%E7%AE%97%E6%B3%95%20sIMPLE&amp;pg=PA514#v=onepage&amp;q=%E6%8A%95%E5%BD%B1%E7%AE%97%E6%B3%95%20sIMPLE&amp;f=false" target="_blank" rel="noopener">林建忠，《流体力学》</a><a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_11">
<sup>11</sup>. DISCUSSION ON MOMENTUM INTERPOLATION METHOD FOR COLLOCATED GRIDS OF INCOMPRESSIBLE FLOW. Bo Yu, Wen-Quan Tao, Jin-Jia Wei, Yasuo Kawaguchi, Toshio Tagawa &amp; Hiroyuki Ozoe. Numerical Heat Transfer, Part B: Fundamentals Vol. 42 , Iss. 2,2002<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_12">
<sup>12</sup>. <a href="http://web.stanford.edu/class/cs205b/lectures/lecture16.pdf" target="_blank" rel="noopener">CS205b/CME306 Lecture 16</a><a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_13">
<sup>13</sup>. <a href="http://www.fem.unicamp.br/~im450/palestras&amp;artigos/CFD of Turbulence_Chalmers_Un/chapter_6-1.pdf" target="_blank" rel="noopener">Collocated grids </a><a href="#reffn_13" title="Jump back to footnote [13] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_14">
<sup>14</sup>. <a href="http://www.math.ucla.edu/~wotaoyin/splittingbook/ch3-macnamara-strang.pdf" target="_blank" rel="noopener">Operator Splitting</a><a href="#reffn_14" title="Jump back to footnote [14] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_15">
<sup>15</sup>. Issa, R. I. (1986). Solution of the implicitly discretised fluid flow equations by operator-splitting. <em>Journal of computational physics</em>, <em>62</em>(1), 40-65.<a href="#reffn_15" title="Jump back to footnote [15] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_16">
<sup>16</sup>. Van Doormaal, J. P., &amp; Raithby, G. D. (1984). Enhancements of the SIMPLE method for predicting incompressible fluid flows. <em>Numerical heat transfer</em>, <em>7</em>(2), 147-163.<a href="#reffn_16" title="Jump back to footnote [16] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_17">
<sup>17</sup>. <a href="http://foam-u.fr/wp-content/uploads/2017/02/Invited_1stOFDayFrance_Jasak.pdf" target="_blank" rel="noopener">Numerics Improvements and Validation Results: FOAM-Extend Update on Work-in-Progress</a><a href="#reffn_17" title="Jump back to footnote [17] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_18">
<sup>18</sup>. Moukalled, F., Mangani, L., &amp; Darwish, M. (2016). The finite volume method in computational fluid dynamics.<a href="#reffn_18" title="Jump back to footnote [18] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_19">
<sup>19</sup>. <a href="http://nht.xjtu.edu.cn/paper/en/2002206.pdf" target="_blank" rel="noopener">Yu, B., Tao, W. Q., Wei, J. J., Kawaguchi, Y., Tagawa, T., &amp; Ozoe, H. (2002). Discussion on momentum interpolation method for collocated grids of incompressible flow. <em>Numerical Heat Transfer: Part B: Fundamentals</em>, <em>42</em>(2), 141-166.</a><a href="#reffn_19" title="Jump back to footnote [19] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_20">
<sup>20</sup>. S. K. Choi, Note on the Use of Momentum Interpolation Method for Unsteady Flows, Numer. Heat Transfer A, vol. 36, pp. 545-550, 1999.<a href="#reffn_20" title="Jump back to footnote [20] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_21">
<sup>21</sup>. Vuorinen, V., Keskinen, J. P., Duwig, C., &amp; Boersma, B. J. (2014). On the implementation of low-dissipative Runge–Kutta projection methods for time dependent flows using OpenFOAM®. <em>Computers &amp; Fluids</em>, <em>93</em>, 153-163.<a href="#reffn_21" title="Jump back to footnote [21] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_22">
<sup>22</sup>. Knacke, T. (2013). Potential effects of Rhie &amp; Chow type interpolations in airframe noise simulations. In: Schram, C., Dénos, R., Lecomte E. (ed):   Accurate and efficient aeroacoustic prediction approaches for  airframe noise, VKI LS 2013-03.<a href="#reffn_22" title="Jump back to footnote [22] in the text."> &#8617;</a>
</blockquote>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> SIMPLE </tag>
            
            <tag> PISO </tag>
            
            <tag> PIMPLE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MASA的安装]]></title>
      <url>/2018/01/05/MASA%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>MASA (Manufactured Analytical Solution Abstraction) 的安装<br><a id="more"></a></p>
<h1 id="MASA的安装"><a href="#MASA的安装" class="headerlink" title="MASA的安装"></a>MASA的安装</h1><p>MASA (Manufactured Analytical Solution Abstraction) 是一个经过验证的虚构解验证程序库，用C++写的，并提供C, python, Fortran90等其他语言的接口。可以用于对常见偏微分方程的模拟程序进行代码验证（Code Verification）。</p>
<p>它所包含的方程有：</p>
<ol>
<li>Heat Equation</li>
<li>Laplace’s Equation</li>
<li>Euler Equations (with and without thermal equilibrium chemistry)</li>
<li>Navier-Stokes Equations</li>
<li>Reynolds Averaged Navier Stokes with Various Turbulence Models</li>
</ol>
<p>MASA 网址: <a href="https://github.com/manufactured-solutions/MASA.git" target="_blank" rel="noopener">https://github.com/manufactured-solutions/MASA.git</a></p>
<p>MASA 文档: <a href="http://manufactured-solutions.github.io/MASA/" target="_blank" rel="noopener">http://manufactured-solutions.github.io/MASA/</a></p>
<h2 id="下载和编译"><a href="#下载和编译" class="headerlink" title="下载和编译"></a>下载和编译</h2><pre><code>cd
git clone https://github.com/manufactured-solutions/MASA.git MASA_src
cd MASA_src

# check tools
which gcc gfortran g++
</code></pre><p>但是这个文件夹中没有常见的configure, CMakeLists.txt和Makefile，所以不知道怎么编译。</p>
<p>经过搜索，发现这个库应该用 <a href="https://en.wikipedia.org/wiki/GNU_Build_System" target="_blank" rel="noopener">GNU Build System</a> 来编译。</p>
<p>GNU Build System的整个流程如下图所示：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/84/Autoconf-automake-process.svg" alt="flowchart of build tools"></p>
<p>所以需要的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 切换到root</span><br><span class="line">yum install libtool autoconf automake gcc-gfortran swig  python-devel -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 切换回来</span><br><span class="line">su ofuser</span><br><span class="line">cd</span><br><span class="line">cd MASA_src</span><br><span class="line">autoreconf -i</span><br><span class="line">./configure --prefix=$HOME/lib/MASA \</span><br><span class="line">--enable-python-interfaces \</span><br><span class="line">--enable-fortran-interfaces \</span><br><span class="line">--enable-static \</span><br><span class="line">--enable-warn-all \</span><br><span class="line">--enable-coverage \</span><br><span class="line">--enable-strict-tests \</span><br><span class="line">make</span><br><span class="line">make check #FAIL: f_insh</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>一些关于库使用的输出:</p>
<pre><code>----------------------------------------------------------------------
Libraries have been installed in:
   /home/ofuser/lib/MASA/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the `-LLIBDIR&#39;
flag during linking and do at least one of the following:
   - add LIBDIR to the `LD_LIBRARY_PATH&#39; environment variable
     during execution
   - add LIBDIR to the `LD_RUN_PATH&#39; environment variable
     during linking
   - use the `-Wl,-rpath -Wl,LIBDIR&#39; linker flag
   - have your system administrator add LIBDIR to `/etc/ld.so.conf&#39;

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
Libraries have been installed in:
   /home/ofuser/lib/MASA/lib64/python2.7/site-packages/masa

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the `-LLIBDIR&#39;
flag during linking and do at least one of the following:
   - add LIBDIR to the `LD_LIBRARY_PATH&#39; environment variable
     during execution
   - add LIBDIR to the `LD_RUN_PATH&#39; environment variable
     during linking
   - use the `-Wl,-rpath -Wl,LIBDIR&#39; linker flag
   - have your system administrator add LIBDIR to `/etc/ld.so.conf&#39;

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>某些包编译需要MetaPhysicL软件包。如没有MetaPhysicL包，有一个<code>f_insh</code>会测试失败。</p>
<p>最新版已经修复bug。</p>
]]></content>
      
        <categories>
            
            <category> MMS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MMS </tag>
            
            <tag> MASA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FEniCS的概念笔记]]></title>
      <url>/2018/01/05/FEniCS%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>FEniCS的概念: 函数空间，弱形式，边界条件，伴随。</p>
<a id="more"></a>
<h1 id="FEniCS的概念笔记"><a href="#FEniCS的概念笔记" class="headerlink" title="FEniCS的概念笔记"></a>FEniCS的概念笔记</h1><p>FEniCS学术味太重，看<sup><a href="#fn_handbook" id="reffn_handbook">handbook</a></sup> 都要吐了。不过好处是怎么实现的给你讲得明明白白的，而且逻辑比较一致。</p>
<blockquote id="fn_handbook">
<sup>handbook</sup>. <a href="https://fenicsproject.org/pub/documents/book/fenics-book-2010-05-07.pdf" target="_blank" rel="noopener">FEniCS Handbook </a><a href="#reffn_handbook" title="Jump back to footnote [handbook] in the text."> &#8617;</a>
</blockquote>
<h2 id="有限元思路"><a href="#有限元思路" class="headerlink" title="有限元思路"></a>有限元思路</h2><p>有限元思路的理解有很多种。</p>
<h3 id="加权余量的duck-typing-思路"><a href="#加权余量的duck-typing-思路" class="headerlink" title="加权余量的duck typing 思路"></a>加权余量的duck typing 思路</h3><blockquote>
<p>“If it walks like a duck and it quacks like a duck, then it must be a duck.”</p>
</blockquote>
<p>同样的</p>
<blockquote>
<p>如果一个解左看像真解，右看像真解，那么我们就当它是真解。</p>
</blockquote>
<p>这个思路导出的就是加权余量法。如果不同权函数的加权积分等于0，那么就算找到真解了。</p>
<p>这个思路的问题是没有对权函数的选取提出指导意见。但是要求权函数尽量相互之间不一样（数学意义上最不一样的往往就是正交函数系！正交=垂直，相当于上下看、左右看再前后看）</p>
<h3 id="函数空间思路"><a href="#函数空间思路" class="headerlink" title="函数空间思路"></a>函数空间思路</h3><p>这个思路更数学化。</p>
<ul>
<li>首先我们假设解是存在于某个解空间$V$时的，但是这个空间太大（<strong>无限维</strong>），我们找不到。</li>
<li>于是我们就构造一个<strong>有限维度</strong>解空间的子空间$V_h\subset V$，叫<strong>有限</strong>元空间，在里面找。<ul>
<li>因为这个空间是我们构造的，所以可以对其进行很多控制，比如选择网格大小、多项式阶数什么的。</li>
<li>由于有限元空间是解空间的子空间，所以我们对解空间证明了一些结论（比如存在唯一收敛稳定性啥的），在有限元空间也是成立的。<ul>
<li>但是这是有例外的，比如混合有限元解鞍点问题时，原空间满足LBB条件，有限元空间如果选取不当可能不满足LBB条件。</li>
<li>所以构造Stokes方程的混合有限元的空间时，LBB条件就成了<strong>指导性原则</strong>。</li>
</ul>
</li>
<li>还有例外就是non-conformal FEM，有限元空间和解空间并不一致，比如DG，是通过inteface flux弱耦合进去的。</li>
</ul>
</li>
<li>有了有限元空间，我们再构造试函数空间$\hat V​$，为了简化，通常取$\hat V = V​$。这样能少占用一些内存啥的。<ul>
<li>恰好，一些数学证明对于很多方程（自伴随算子什么的），这么构造试函数可以带来很多优良的特性。</li>
<li>那就这么干了。</li>
<li>例外：Petrov-Galerkin，$\hat V \ne V$</li>
</ul>
</li>
<li>例外：广义Galerkin方法，弱形式中的算子$a(u,v)$也是可以变的（$a_h(u,v)$），只要收敛就好。</li>
</ul>
<h2 id="函数空间"><a href="#函数空间" class="headerlink" title="函数空间"></a>函数空间</h2><p>函数空间<sup><a href="#fn_function_space" id="reffn_function_space">function_space</a></sup>太重要了，如果说FVM是玩各种重构，那么FEM就是玩各种函数空间（FDM似乎是玩各种差分、导数和Taylor展开）。</p>
<blockquote id="fn_function_space">
<sup>function_space</sup>. <a href="http://www4.ncsu.edu/~zhilin/TEACHING/MA587/chap7.pdf" target="_blank" rel="noopener">Theoretical Foundations of the Finite Element Method</a><a href="#reffn_function_space" title="Jump back to footnote [function_space] in the text."> &#8617;</a>
</blockquote>
<h3 id="按性质分类"><a href="#按性质分类" class="headerlink" title="按性质分类"></a>按性质分类</h3><ul>
<li>线性空间：linear space，又叫vector space，加减数乘之后还在里面。</li>
<li>距离空间（metric space）：定义了距离（距离是二元算符）的空间<ul>
<li>距离：$d(u,v)$满足三条性质的叫metric <ul>
<li>距离非负</li>
<li>距离为0，二者相等</li>
<li>三角不等式$d(u,v+w)\le d(u,v)+d(u,w)$</li>
</ul>
</li>
<li>常见的距离对于数组来说就是差的某种模，比如这个：$\sum_i{|u_i-v_i|}​$</li>
<li>距离对于函数空间而言也可以是类似的，比如$d(u,v)=\max_{x\in\Omega}|u(x)-v(x)|​$。</li>
</ul>
</li>
<li>范数空间（normed space），范数是一元算符<ul>
<li>范数：$||u(x)||=d(u,\theta)=\max_{x\in\Omega}|u(x)|$，其中$\theta$是0元素，且满足一下性质：<ul>
<li>非负，且$||u(x)||=0\equiv u(x)=0$</li>
<li><strong>齐次性</strong> $||\alpha u(x)||=|\alpha| ||u(x)||$</li>
<li>三角不等式$||u+v||\le ||u||+||v||$</li>
</ul>
</li>
<li>范数可以诱导出距离：$d(u,v)= ||u-v||$。</li>
<li><strong>齐次性</strong> 是范数所特有的！<ul>
<li>范数可以诱导出非齐次的距离：$d(x,y) = \frac{||x-y||}{1+||x-y||}​$</li>
<li>这个距离始终小于1，且是平移不变的。</li>
</ul>
</li>
</ul>
</li>
<li>完备（completeness）：柯西数列收敛<ul>
<li>对于metric space而言。</li>
<li>收敛（convergence）：$\lim_{n\to+\infty}{x_n} = x$表示对任意$\epsilon&gt;0$，存在N使得$d(x_n,x)&lt;\epsilon$对任意$n&gt;N$成立 。也就是这堆数<strong>与$x$之间越来越近</strong>。 </li>
<li>柯西数列Cauchy sequence：对任意$\epsilon&gt;0$，存在N使得$d(x_n,x_{n-1})&lt;\epsilon$对任意$n&gt;N$成立 。也就是这堆数<strong>相互之间</strong>越来越近。</li>
<li>比如实数空间就是完备的。</li>
</ul>
</li>
<li>完备范数空间（Banach空间）<ul>
<li>完备范数可以诱导完备距离</li>
<li>完备距离之所以重要，是因为我们可以用变细的网格和更高的阶数（$h_n\to 0, \Delta t \to 0, p\to +\infty$）构造数值解的柯西列，只要它们相互之间越来越近，那么可以保证，它一定收敛于Banach空间中的<strong>真解</strong>。<ul>
<li>真解我们往往是不知道的，所以对真解的误差（Error）往往是我们无法衡量的。</li>
<li>但是我们可以构造并检验柯西列的收敛性</li>
<li>这是逼近真解的<strong>构造性算法</strong>的前提条件。</li>
</ul>
</li>
</ul>
</li>
<li>内积空间：inner product空间<ul>
<li>内积<ul>
<li>共轭对称性：$(f,g)=\overline{(g,f)}$</li>
<li>线性性：$(ax+by,z) = a(x,z)+b(y,z)$</li>
<li>正定：$(x,y)\ge0$且$ (x,x)=0\Leftrightarrow  x=0$</li>
<li>例如：$(f,g)=\int_\Omega{f\cdot gdx}$</li>
</ul>
</li>
<li>显然，内积可以诱导出范数，从而诱导出距离。<ul>
<li>例如：$||x||=(x,x)$，距离$d(x,y)=\frac{(x-y,x-y)}{1+(x-y,x-y)}$</li>
</ul>
</li>
<li>有了内积空间，我们可以定义角度！从而可以定义<strong>正交性</strong>！<ul>
<li>想想角度的cos值小于1，对应着Cauchy-Schwartz不等式$(u,v)\le||u||\times||v||$</li>
</ul>
</li>
<li>内积可以帮助我们定义双线性形式。</li>
<li>例子：内积对应于数组向量是点乘或者加权点乘，对应于函数则是积分或者加权积分。</li>
</ul>
</li>
<li>完备内积空间：Hilbert空间<ul>
<li>有了内积可以保证我们可以构造出一个具有正交完备性的空间元素序列</li>
<li>这个序列就可以作为基逼近空间内的任意元素。</li>
<li>并且这个逼近在某种意义上还是最佳逼近。<ul>
<li>对于有限维度的Hilbert空间，有时候存在Gibbs问题。</li>
</ul>
</li>
</ul>
</li>
<li>带导数的完备内积空间（Sobolev空间），直到n阶导数存在且术语$L^2$空间 ，标记为$H^n(\Omega)$<ul>
<li>内积变了：<ul>
<li>$(u,v)_{H^1(\Omega)}=\int_{\Omega}{(uv+u’v’)\text dx}$</li>
</ul>
</li>
<li>此时存在$ H^1$semi-norm，比如$||\nabla u||$，这个半模有一些线性性质，但是半模等于0，这个函数可以不等于0。<ul>
<li>CFD领域津津乐道的总变差（Total variation, TV）就类似一种一阶导数的半模。</li>
</ul>
</li>
<li>Sobolev嵌入定理：$H^{m+j} \subset C^j$，如果$2m&gt;n$的话 。其中 $n$是空间维度。<ul>
<li>2维：m=2，就是说$u\in H^2\subset C^0$，$u$是连续的，但是$u_x$不一定连续，但是$u_x$一定平方可积。</li>
<li>3维：m=2。结论相同。</li>
</ul>
</li>
<li>$H^m_0(\Omega)$的下标$_0$表示齐次边界条件的Sobolev空间（严格来说，是函数的trace，即在边界处的值为0）。通常用来表示模型问题的解空间。</li>
</ul>
</li>
<li>不连续的Sobolev空间（Broken Sobolev空间）<sup><a href="#fn_broken_sobolev" id="reffn_broken_sobolev">broken_sobolev</a></sup><ul>
<li>Sobolev空间又有一个衍生产物，间断Galerkin的解就在其中，这个空间的性质决定了DG类算法的一些重要性质，如存在唯一性，误差估计等。</li>
</ul>
</li>
</ul>
<blockquote id="fn_broken_sobolev">
<sup>broken_sobolev</sup>. <a href="https://www.researchgate.net/profile/Zhiqiang_Cai3/publication/265243578_A_Note_on_Discontinuous_Galerkin_Methods/links/5536a80b0cf218056e953013/A-Note-on-Discontinuous-Galerkin-Methods.pdf" target="_blank" rel="noopener">A Note on Discontinuous Galerkin Methods</a><a href="#reffn_broken_sobolev" title="Jump back to footnote [broken_sobolev] in the text."> &#8617;</a>
</blockquote>
<h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3><ul>
<li>伴随Adjoint：<ul>
<li>伴随往往是指算子，比如Laplacian算子$\Delta = \nabla\cdot \nabla $就是一个算子，把一个函数映射成另一个函数</li>
<li>对于Hilbert空间，因为定义了内积，所以$A$的伴随算子$A^<em>$的定义是：$(Ax,y)_1 = (x,A^</em>y)_2$<ul>
<li>注意：上式左边的算子$A$可以是把 Hilbert空间2的向量$x$映射到了Hilbert空间1的向量 $Ax$，然后按照Hilbert空间1的内积$(\cdot,\cdot)_1$计算的。</li>
<li>伴随算子是反过来的。</li>
<li>对于两个有限坐标空间而言，算子总是可以表示为矩阵，此时$A^*=\bar A^T$，即原矩阵的厄米特矩阵（Hermitian，即共轭转置）</li>
<li>实际上算子还需要是有界的。<ul>
<li>有界和无界算子在很多地方差异较大。</li>
</ul>
</li>
</ul>
</li>
<li>如果算子是自伴随（self-adjoint）的，会有很多很好的性质。比如矩阵是对称的，可以收敛更快。</li>
<li>模算子（normal operator）：$AA^<em>=A^</em>A$，类似于单位正交距阵。<ul>
<li>模算子都是自伴随的，反之不成立。</li>
</ul>
</li>
</ul>
</li>
<li>对偶dual：对偶指的空间对偶<ul>
<li>范数空间的所有连续线性泛函构成的空间，就是它的dual space。</li>
<li>定义虽然是这样，但是由于试线性泛函，所以通常每个泛函空间的元素都可以表示为$F_{w}(f)=\int_\Omega{f(x)w(x)\text d x}$的形式，那么$w(x)$构成的空间其实也是函数空间，并且同构于那个dual space。于是这个函数空间本身就被叫做了dual space。</li>
<li>所以dual space的空间元素本来应该是一堆泛函，但是实际上按照是一堆函数来处理。</li>
<li>dual space的原空间是一堆函数，dual space本身又当成是一堆函数，于是可以对来对去玩更多花样。</li>
<li>范数空间的dual是Banach空间，即使它本身不是。</li>
<li>$L^p$的对偶空间是$L^{p’}$，$\frac{1}{p}+\frac{1}{p’}=1$，p=1和$\infty$时除外。</li>
</ul>
</li>
<li>导数derivative<ul>
<li>Gateaux derivative，方向导数的推广，原算子和得到的导数算子都不一定是线性算子。</li>
<li>Fréchet derivative，Banach空间的导数概念，原算子不一定是线性算子，结果得到的导数算子必须是线性算子。<ul>
<li>某个点方向导数存在，导数不一定存在。</li>
<li>同样的，某个函数空间的某个地方Gateaux导数存在，并不代表Fréchet 导数就存在。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="按常见具体内容举例"><a href="#按常见具体内容举例" class="headerlink" title="按常见具体内容举例"></a>按常见具体内容举例</h3><ul>
<li>数域：Field，本身就是1维的线性空间，常表示为$\mathbf F$<ul>
<li>实数：$\mathbf R$</li>
<li>复数：$\mathbf C$</li>
</ul>
</li>
<li>坐标空间：coordinate space，就是数组排成一列（或者一行），是最基本的。通常计算机里的vector, list之类的东西应该归属于坐标空间，虽然名字也叫向量。<ul>
<li>实数坐标空间：real coordinate space，符号：$\mathbf{R}^n​$，常用来表示n维欧氏空间（Euclidean space）</li>
<li>复数坐标空间：complex coordinate space，符号$\mathbf{C}^n$</li>
<li>无限维坐标空间：$\mathbf F^\infty $</li>
</ul>
</li>
<li>矩阵：数域组成的m*n矩阵，表示维$\mathbf F^{m\times n}$</li>
<li>多项式空间：多项式的系数为数域$\mathbf F$，且变量为$x$时，记作$\mathbf F[x]$，可以扩展到多变量$\mathbf F[x_1,x_2, \dots]$<ul>
<li>最常用的实系数多项式空间表示为$\mathbf P_n$，$n$表示最高阶数（degree）</li>
<li>多项式空间也是电脑最喜欢用的空间，因为只涉及到加减乘法，算起来快，参考以下图。</li>
<li><img src="http://latkin.org/blog/wp-content/uploads/2014/11/FLOPchart1.png" alt="benchmark results"></li>
<li>关于统计Flops，参考<a href="http://icl.utk.edu/papi/" target="_blank" rel="noopener">http://icl.utk.edu/papi/</a></li>
</ul>
</li>
<li>函数空间：$f:X\to V$，记作$V^X$</li>
<li>连续函数空间：$C^m(\Omega)$，m阶连续可导函数的空间，基于每个点的定义的，也就是每个点都要m阶导数存在且连续。</li>
<li>$L^p(\Omega)$空间：p次方可积函数空间，p不等于2时，它是Banach空间而不一定是Hilbert空间<ul>
<li>$L^2(\Omega)$空间：square integratable function space.</li>
<li>p-norm：$||f||_p = (\int_S|f|^p\text ds)^{1/p}&lt;\infty$ </li>
</ul>
</li>
<li>$l^p$空间：定义了p-norm的<strong>无限维</strong>坐标空间<ul>
<li>p-norm: $||x||_p = (\sum_i{|x_i|^p})^{1/p}$</li>
</ul>
</li>
</ul>
<h2 id="弱形式"><a href="#弱形式" class="headerlink" title="弱形式"></a>弱形式</h2><p>weak form就是一些表达式加权积分后成立，我们就认为在它的弱形式成立。</p>
<ul>
<li>举个例子：</li>
</ul>
<p>Legendre多项式，在[-1,1]区间上有如下关系。</p>
<script type="math/tex; mode=display">
{\displaystyle \int _{-1}^{1}P_{m}(x)P_{n}(x)\,\mathrm {d} x={\frac {2}{2n+1}}\delta _{mn}}</script><p>那么我们假设在[-1,1]上有3阶多项式空间$P^3([-1,1])$，那么这个多项式空间和$P_0,P_1,P_2,P_3$ 四个Legendre多项式张成的空间是一样的。</p>
<p>那么在$\int_{-1}^1{f(x)v(x)}\text d x, v(x) \in P^3([-1,1])$ 的弱形式下，4阶Legendre多项式$P_4(x) = \frac 1 8 (35x^4-30x^2+3)$ 和函数$g(x) = 0 $的意义是一样的。</p>
<p>也就是说，如果我们用3阶多项式空间去解一个精确解是$P_4(x)$的方程，我们可能会得到0，并且还无法分辨0是不是真解。</p>
<ul>
<li>举个例子2：</li>
</ul>
<p>弱形式还可以应用于导数。</p>
<p>比如$\int gv w \text d  x = \int f’ v w \text dx$</p>
<p>那么在弱形式的意义下，$f’=g$，尽管实际上$f’,g$可能完全不一样。 </p>
<ul>
<li>总结</li>
</ul>
<p>FEM求弱形式的逻辑：</p>
<p>FEM只能找到具体求解之前确定的有限元空间$\Omega_{h,p}$ 内的弱解，那么：</p>
<ol>
<li>如果真解在其中，那么必然能找到。</li>
<li>如果真解不在其中，那么在很多情况下可以证明：<ol>
<li>找到的弱解是有限元空间$V_h$中<strong>最接近</strong>真解的<ol>
<li>因为误差的投影为0，几何意义是垂直；</li>
<li>点到平面垂线最短。</li>
</ol>
</li>
<li>随着单元数增加，$h$减小，或者阶数$p$增加，找到的弱解会<strong>趋近于</strong>真解，误差（的某种模）会越来越小，因为函数空间会越来越完备。</li>
</ol>
</li>
</ol>
<h2 id="组装矩阵"><a href="#组装矩阵" class="headerlink" title="组装矩阵"></a>组装矩阵</h2><p>双线性形式$a(u,v)$对应着一个矩阵，只要选定函数空间$u_i \in V, v_j\in \hat V$，那么矩阵$A$的元素为$a_{ij}=a(u_i,v_j)$。具体积分怎么弄就是另一回事儿了。</p>
<p>线性形式$L(v)$对应着一个向量，其元素同理为$L_i=L(v_j)$。</p>
<h3 id="积分法Quadrature"><a href="#积分法Quadrature" class="headerlink" title="积分法Quadrature"></a>积分法Quadrature</h3><p>quadrature和integral是两个概念，虽然中文都可以叫积分，但是quadrature主要是数值积分。最常见的是Gauss积分法，但是其实数学家和FEM家们能玩出无数花样。</p>
<ul>
<li>1维<sup><a href="#fn_1d_quad" id="reffn_1d_quad">1d_quad</a></sup><ul>
<li>最常用的是Gauss quadrature，这其实是一类积分法，插值点是非均匀分布的。<ul>
<li>$\int_{a}^{b}{f\text dx}=\int_{a}^{b}{wg\text dx} \approx \sum_{i=1}^N{w_ig(x_i)}$</li>
<li>其中的$x_i$叫插值点（abscissas）通常是一些特征函数的零点或者极值点</li>
<li>最常用的区间是[-1,1]，也有[0,$+\infty$)，[0,1]的。</li>
<li>根据权重不同，有不同的积分法，分别可以达到不同的精度。通常可以达到$2N-1$次以下的多项式精确积分。</li>
<li>积分法一般是以Gauss-XXX-YYY命名，XXX是Lobatto，Radau或者留空，表示点的排布是否包括部分或全部端点，YYY一般是一种多项式的名字，积分点就取得它的零点或者极值点。<ul>
<li>Lobatto积分，包含端点的贡献。</li>
<li>Radau积分，包含左端点，不含右端点</li>
<li>什么都不选，通常不包含端点。</li>
<li>其他名字的：Clenshaw-Curtis quadrature：Chebyshev极值点</li>
</ul>
</li>
<li>半无限域的<ul>
<li>Gauss-Laguerre积分：[0,$+\infty$)</li>
<li>Gauss-Hermite积分：[0,$+\infty$)。</li>
</ul>
</li>
</ul>
</li>
<li>此外还有Newton-Cotes积分，均匀分布插值点。</li>
</ul>
</li>
<li>2维<ul>
<li>如果是四边形单元，1维积分法的向量积可以用。</li>
<li>如果是三角形单元<ul>
<li>可以当成有节点重合的四边形单元</li>
<li>寻找对称积分规则<sup><a href="#fn_polyquad" id="reffn_polyquad">polyquad</a></sup>。</li>
</ul>
</li>
</ul>
</li>
<li>3维<ul>
<li>同二维，用低维扩展或者重新寻找对称积分规则。</li>
</ul>
</li>
<li>其他<ul>
<li>其他积分方法，比如Monte Carlo之类的也是可行的。</li>
</ul>
</li>
</ul>
<blockquote id="fn_1d_quad">
<sup>1d_quad</sup>. <a href="https://link.springer.com/content/pdf/bbm%3A978-1-4612-0101-4%2F1.pdf" target="_blank" rel="noopener">Quadature rules</a><a href="#reffn_1d_quad" title="Jump back to footnote [1d_quad] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_polyquad">
<sup>polyquad</sup>. <a href="https://github.com/vincentlab/Polyquad" target="_blank" rel="noopener">Polyquad</a><a href="#reffn_polyquad" title="Jump back to footnote [polyquad] in the text."> &#8617;</a>
</blockquote>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p>FEM里边界条件有两种，以泊松方程</p>
<script type="math/tex; mode=display">
\begin{split}- \nabla^{2} u &= f \quad {\rm in} \ \Omega, \\
u &= a \quad {\rm on} \ \Gamma_{D}, \\
\nabla u \cdot n &= g \quad {\rm on} \ \Gamma_{N}. \\\end{split}</script><p>的双线性形式</p>
<script type="math/tex; mode=display">
a(u, v) = L(v) \quad \forall \ v \in \hat{V},</script><p>为例：</p>
<ul>
<li>本质边界条件：essential boundary condition: 施加在函数空间里，比如函数空间$V$要求满足$u=a \text{ on } \Gamma_D$</li>
<li>自然边界条件：natural boundary condition：施加在变分形式里，比如$L(v)=\int_\Omega{fv\text{d}\mathbf{x}}+\int_{\Gamma_N}gv\text{d}s$<ul>
<li>变分形式里的话就不用管了，按式子积分就是了。</li>
</ul>
</li>
</ul>
<h4 id="本质边界条件"><a href="#本质边界条件" class="headerlink" title="本质边界条件"></a>本质边界条件</h4><p>本质边界条件一般是直接调整矩阵系数。</p>
<h5 id="保对称性特殊处理"><a href="#保对称性特殊处理" class="headerlink" title="保对称性特殊处理"></a>保对称性特殊处理</h5><p>书中6.3节</p>
<p>对于对称问题，直接施加Dirichlet BC是不对称的。所以FEniCS玩了一些技巧。</p>
<p>在单元矩阵中，对I自由度直接施加Dirchlet BC得到的是设置系数$a_{I,I}=1, a_{I,J\ne I}=0, b_{I}=b_D$，但是对称性要求$a_{J\ne I,I}=a_{I,J\ne I}=0$，所以需要用Gauss消去法，在设置完第$I$行之后，对第$J$行进行操作，使其$a_{J\ne I,I}=0$。</p>
<p>然后往全局矩阵里装。最后还有一个扫尾工作，需要对全局矩阵的LHS和RHS进行调整，加上减去的一些东西（这部分我没看懂）。</p>
<p>另一种方法是从全局矩阵中抽出BC对应的DOF不解，但是会使全局矩阵维度不一致。FEniCS没有采用这种方法。</p>
<p>首次设置系数是在<code>DirichletBC::apply()</code>函数，但是对称化是在<code>SystemAssembler</code></p>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>求解分为非线性部分、定常部分和线性代数部分。</p>
<h3 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h3><h4 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h4><p>对$R(x)=0$，记$J=\frac{\partial R}{\partial x}, J_{ij}=\frac{\partial R_i}{\partial x_j}$</p>
<p>牛顿法为：</p>
<p>$x_{n+1} = x_n - J^{-1} R(x_n)$</p>
<p>牛顿法理论上是2次收敛。</p>
<ul>
<li>可以衍生出非精确牛顿法（inexact Newton method），还有一些准牛顿法（quasi-Newton method）之类的方法减少计算代价。</li>
<li>可以和线性代数部分结合起来，比如Newton-Krylov方法。</li>
</ul>
<h4 id="Picard迭代"><a href="#Picard迭代" class="headerlink" title="Picard迭代"></a>Picard迭代</h4><p>$R(x)=0$，将其变形为$x=F(x)$</p>
<p>Picard迭代为$x_{n+1}=F(x_n)$</p>
<p>对$F(x)$的要求是有压缩性，并且解为其不动点</p>
<h3 id="非定常"><a href="#非定常" class="headerlink" title="非定常"></a>非定常</h3><h4 id="需要考虑的点"><a href="#需要考虑的点" class="headerlink" title="需要考虑的点"></a>需要考虑的点</h4><p>NASA在考察ODEs的RK时，有以下考虑：</p>
<ol>
<li>Order condition，满足精度需要达到的系数满足的关系。</li>
<li>Simplifying Assumptions，如果系数满足某些条件，可以在实现时简化</li>
<li>Error：p-阶方法，全局误差是p阶，局部误差是p+1阶，对非常刚性的奇异摄动问题，stiffly-accurate问题能给出更好的解。</li>
<li>Linear Stability，常规的A，L稳定性以及其他S,D稳定性等</li>
<li>Nonlinear Stability，不懂</li>
<li>Internal Stability，IMEX方法的稳定性与内部稳定性有关。</li>
<li>Dense output，步内插值</li>
<li>Conservation, Symplecticity and Symmetry，所有一致的DIRK,SDIRK，ESDIRK都保证1阶线性首次积分守恒。二次和三次积分守恒很难了。辛（Symplecticity ）DIRK方法有的可以保证某些二次积分守恒。对于可逆的方程适合用对称的RK方法（时间步可以取负）。</li>
<li>Dissipation and Dispersion Accuracy 色散耗散特性</li>
<li>Memory Economization如何省内存，结论是不用省，大头不在RK本身。</li>
<li>Regularity 对稳态解是否会产生新的稳态（R1）或者稳定震荡（R2）。RK保持R1或者R2的话不会超过2阶。</li>
<li>Boundary and Smoothness Order Reduction 当$f(t,u)=A(t,u)u$中$A(t,u)$是间断的时候会怎样。一般会有order reduction。</li>
<li>Efficiency</li>
<li>Solvability 可解性，按IRK离散得到的非线性代数方程组是否存在唯一解。这是有条件的。</li>
<li>Implementation </li>
<li>Step-Size Control 一般用embed output配合PID类控制器来控制</li>
<li>Iteration Control 关键是非线性迭代时什么时候更新Jacobian。</li>
<li>Stage-Value Predictors 非线性迭代的初值估计</li>
<li>Discontinuities，探测、确定断点、重新积分</li>
<li>Software 实现的软件</li>
</ol>
<h4 id="常用的算法"><a href="#常用的算法" class="headerlink" title="常用的算法"></a>常用的算法</h4><ul>
<li>线性单步法（single-stage method）<ul>
<li>常用SSP-RK，参考<sup><a href="#fn_SSP_RK" id="reffn_SSP_RK">SSP_RK</a></sup></li>
<li>NASA 2016年报告推荐了一种ESDIRK4(3)6L[2]SA 算法（显式第一步、对角相同、隐式RK，4阶、内嵌3阶、6步，L-stable，中间步精度是2阶，stiffly-accurate方法！）<sup><a href="#fn_NASA_RK" id="reffn_NASA_RK">NASA_RK</a></sup></li>
</ul>
</li>
</ul>
<blockquote id="fn_NASA_RK">
<sup>NASA_RK</sup>. <a href="https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20160005923.pdf" target="_blank" rel="noopener">NASA/TM–2016–219173: Diagonally Implicit Runge-Kutta Methods for Ordinary Differential Equations. A Review</a><a href="#reffn_NASA_RK" title="Jump back to footnote [NASA_RK] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_SSP_RK">
<sup>SSP_RK</sup>. <a href="http://www.cfm.brown.edu/people/sg/SSPpage/sspsite/" target="_blank" rel="noopener">http://www.cfm.brown.edu/people/sg/SSPpage/sspsite/</a><a href="#reffn_SSP_RK" title="Jump back to footnote [SSP_RK] in the text."> &#8617;</a>
</blockquote>
<ul>
<li>线性多步法（multi-stage method）<ul>
<li>常用BDF2，BDF1=Euler，BDF2是L-stable的，更高阶的不是L-stable的。</li>
</ul>
</li>
<li>还有别的，比如 Exponential integrators方法之类的。</li>
<li>显式/隐式<ul>
<li>显式：时间步长短，每步代价小<ul>
<li>编程简单，并行简单</li>
<li>非定常适合，如LES</li>
<li>限制不在流动求解时适合，如燃烧。</li>
</ul>
</li>
<li>隐式：时间步长可稍长一些，每步代价大<ul>
<li>定场求解</li>
<li>编程复杂，并行也复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线性代数的求解"><a href="#线性代数的求解" class="headerlink" title="线性代数的求解"></a>线性代数的求解</h3><ul>
<li>LU，QR等<ul>
<li>稠密小矩阵可以用</li>
</ul>
</li>
<li>Krylov，小矩阵不明显，通常n&gt;1000性能开始显现，常用于稀疏矩阵，可以与Newton法结合形成Newton-Krylov方法。<ul>
<li>CG, BiCG,GMRES</li>
<li>不限制内存的话GMRES性能几乎是最好的</li>
<li>新方法IDR(s)</li>
<li>preconditioner是Krylov的性能关键<ul>
<li>ILU</li>
<li>physics-based.</li>
</ul>
</li>
</ul>
</li>
<li>Multigrid<ul>
<li>理论时间O(n)</li>
<li>AMG</li>
<li>FAS</li>
<li>Multi-p</li>
</ul>
</li>
</ul>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><h2 id="CFD中的FEM"><a href="#CFD中的FEM" class="headerlink" title="CFD中的FEM"></a>CFD中的FEM</h2><h3 id="不可压缩"><a href="#不可压缩" class="headerlink" title="不可压缩"></a>不可压缩</h3><p>主要是鞍点问题，压力和速度采用不同的单元解决。合适的单元满足LBB条件即可。</p>
<h3 id="可压缩"><a href="#可压缩" class="headerlink" title="可压缩"></a>可压缩</h3><h4 id="SUPG"><a href="#SUPG" class="headerlink" title="SUPG"></a>SUPG</h4><p>属于连续Galerkin方法，test function有特殊处理。</p>
<p>边界处理（没看懂）</p>
<p>特色软件：<a href="https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20160007758.pdf" target="_blank" rel="noopener">HPCMP CREATE™-AV Conservative Field Finite Element (COFFE)</a></p>
<h4 id="DG"><a href="#DG" class="headerlink" title="DG"></a>DG</h4><p>和FVM很相似。边界按间断进行处理</p>
<p>边界条件（艹TMD没看懂，水太深）</p>
<h5 id="Flux-Reconstruction"><a href="#Flux-Reconstruction" class="headerlink" title="Flux Reconstruction"></a>Flux Reconstruction</h5><p>这个思想在PyFR的<a href="https://freddie.witherden.org/pages/publications/posters/ukmac2013.pdf" target="_blank" rel="noopener">海报</a>里写得很直白了。</p>
<ol>
<li>solution point是求解$u$所用</li>
<li>flux point是计算$f$所用</li>
<li>界面$f$不同</li>
<li>间断分解修正得到统一的$f^*$</li>
<li>构造修正函数$g$，并用$f-f^*$做scaling</li>
<li>用$g$修正那个$f$</li>
<li>对$f$求导得$\nabla \cdot f$，带入显式求解器，更新u</li>
</ol>
<p>PyFR的特点是利用了新的软件技术来减少代码量。</p>
<h2 id="FE方法的一些理论问题"><a href="#FE方法的一些理论问题" class="headerlink" title="FE方法的一些理论问题"></a>FE方法的一些理论问题</h2><p>理论问题主要是指解的存在性、唯一性、收敛性和稳定性。</p>
<h3 id="LBB条件"><a href="#LBB条件" class="headerlink" title="LBB条件"></a>LBB条件</h3><p>鞍点问题稳定性的inf-sup条件，又叫LBB条件（Ladyzenskaja-Babuška-Brezzi condition）<sup><a href="#fn_LBB1" id="reffn_LBB1">LBB1</a></sup>。</p>
<blockquote id="fn_LBB1">
<sup>LBB1</sup>. <a href="http://cims.nyu.edu/~kellen/cfd/FEM_Stokes_Inf_Sup_Notes.pdf" target="_blank" rel="noopener">FEM Stokes Inf Sup Notes</a><a href="#reffn_LBB1" title="Jump back to footnote [LBB1] in the text."> &#8617;</a>
</blockquote>
<p>鞍点问题来自于连续性方程 $\nabla\cdot u = 0$。</p>
<p>LBB条件对于连续的方程弱形式成立，但是对于离散之后的方程并不一定成立，需要对解空间进行一定的选择。</p>
<p>LBB条件由很多等效的提法，一种实用的提法是：解的空间要恰当地大和小，使LBB不等式满足，使得算子B零空间有非零元素。</p>
<p>从连续LBB到离散LBB，根据Fortin’s Lemma，可以引入特别的restriction operator，把连续空间映射到离散空间。</p>
<p>可选组合有：P/U = P2/P1,P1-bubble/P1</p>
<p>此外还需要考虑Lax-Milgram定理<sup><a href="#fn_LBB2" id="reffn_LBB2">LBB2</a></sup> ，它描述了解的存在唯一性和方程算子椭圆性之间的关系。</p>
<p>不过混合有限元解的存在唯一性的还需要考虑LBB条件。</p>
<blockquote id="fn_LBB2">
<sup>LBB2</sup>. <a href="http://people.maths.ox.ac.uk/suli/mixed_FEM_lectures.pdf" target="_blank" rel="noopener">mixed FEM lectures</a><a href="#reffn_LBB2" title="Jump back to footnote [LBB2] in the text."> &#8617;</a>
</blockquote>
<h3 id="Petrov-Galerkin"><a href="#Petrov-Galerkin" class="headerlink" title="Petrov-Galerkin"></a>Petrov-Galerkin</h3><p>传统的Galerkin方法上，FE空间和试函数空间相同（边界条件可不同），但是算子并不随FE空间改变（如果算子也随着发生改变，那么叫做广义Galerkin方法）</p>
<p>Petrov-Galerkin中的FE空间和试函数空间不仅边界条件不同，函数本身也不同。</p>
<p>由于试函数空间的偏移，可以起到类似上风的作用，增加求解对流问题或者双曲问题的稳定性。</p>
]]></content>
      
        <categories>
            
            <category> FEniCS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> FEniCS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenFOAM在docker中的使用]]></title>
      <url>/2018/01/05/OpenFOAM%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>利用docker在windows中使用OpenFOAM。利用共享文件夹功能在windows中进行前后处理。<br><a id="more"></a></p>
<h1 id="OpenFOAM在docker中的使用"><a href="#OpenFOAM在docker中的使用" class="headerlink" title="OpenFOAM在docker中的使用"></a>OpenFOAM在docker中的使用</h1><p>操作系统：windows 10 Pro/Home</p>
<p>docker版本：docker有两种，一种是社区版Community Edition，一种是商业版。我们采用免费的社区版，但是由于docker本质上是一个Linux程序，所以即使是社区版，在windows下使用时需要首先用虚拟机运行一个Linux平台（通常是Moby Linux），根据虚拟机平台的不同，也是有两种选择：</p>
<ul>
<li>docker for windows，这个版本是主推的版本，可以利用windows10的HyperV虚拟化平台。但是windows10需要Pro版或者旗舰版才能开启HyperV虚拟化。</li>
<li>docker toolbox，这个版本是比较老的，利用的是Oracle的VirtualBox进行虚拟化，但是可以在Windows10 Home版本下运行，或者在windows 7等老版本操作系统下运行。</li>
</ul>
<p>两个版本我都会介绍到。</p>
<h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>下面分别介绍docker for windows和docker toolbox的安装</p>
<h3 id="docker-for-windows"><a href="#docker-for-windows" class="headerlink" title="docker for windows"></a>docker for windows</h3><p>对于可以开启HyperV虚拟化的windows 10 Pro或者旗舰版而言，docker for windows是最好的选择。</p>
<p>网址: <a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p>
<p>下载: <a href="https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe" target="_blank" rel="noopener">Docker for Windows Installer.exe</a></p>
<p>版本: Docker version 17.09.0, 社区版中的最新稳定版。</p>
<p>安装指南: <a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/</a></p>
<p>一路点击OK,next 安装完成后，运行<code>Docker for Windows</code>. 它会花费一些时间启动 <code>docker engine</code>. 等提示启动完成后，右键单击<code>开始</code>按钮，选择”Windows Powershell”。打开Powershell命令行。（用cmd也是可以的）</p>
<p>运行如下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"><span class="comment">## Docker version 17.09.0-ce, build afdb6d4</span></span><br><span class="line">docker-compose --version</span><br><span class="line"><span class="comment">## docker-compose version 1.16.1, build 6d1ac219</span></span><br><span class="line">docker-machine --version</span><br><span class="line"><span class="comment">## docker-machine.exe version 0.12.2, build 9371605</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## Hello from Docker!</span></span><br><span class="line"><span class="comment">## This message shows that your installation appears to be working correctly.</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## To generate this message, Docker took the following steps:</span></span><br><span class="line"><span class="comment">##  1. The Docker client contacted the Docker daemon.</span></span><br><span class="line"><span class="comment">##  2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span></span><br><span class="line"><span class="comment">##     (amd64)</span></span><br><span class="line"><span class="comment">##  3. The Docker daemon created a new container from that image which runs the</span></span><br><span class="line"><span class="comment">##     executable that produces the output you are currently reading.</span></span><br><span class="line"><span class="comment">##  4. The Docker daemon streamed that output to the Docker client, which sent it</span></span><br><span class="line"><span class="comment">##     to your terminal.</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## To try something more ambitious, you can run an Ubuntu container with:</span></span><br><span class="line"><span class="comment">##  $ docker run -it ubuntu bash</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## Share images, automate workflows, and more with a free Docker ID:</span></span><br><span class="line"><span class="comment">##  https://cloud.docker.com/</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## For more examples and ideas, visit:</span></span><br><span class="line"><span class="comment">##  https://docs.docker.com/engine/userguide/</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment">## CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span></span><br><span class="line"><span class="comment">## 32a621d46d34        hello-world         "/hello"            24 seconds ago      Exited (0) 23 seconds ago                       clever_agnesi</span></span><br><span class="line">docker rm <span class="number">32</span>a621d46d34 <span class="comment">#change it to your container ID</span></span><br><span class="line"><span class="comment">## 32a621d46d34 </span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment">## CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span></span><br></pre></td></tr></table></figure>
<h3 id="docker-toolbox安装"><a href="#docker-toolbox安装" class="headerlink" title="docker toolbox安装"></a>docker toolbox安装</h3><p>网址和安装指南：<a href="https://docs.docker.com/toolbox/toolbox_install_windows/" target="_blank" rel="noopener">https://docs.docker.com/toolbox/toolbox_install_windows/</a></p>
<p>下载：<a href="https://download.docker.com/win/stable/DockerToolbox.exe" target="_blank" rel="noopener">https://download.docker.com/win/stable/DockerToolbox.exe</a></p>
<p>这个docker toolbox也要求至少是64位的windows 操作系统，win 7 以上。并且在BIOS中开启了虚拟化（Virtualization，和HyperV不同）</p>
<p>docker toolbox安装时会安装VirtualBox。</p>
<p>安装完成后会出现以下几个图标：</p>
<p><img src="https://docs.docker.com/toolbox/images/icon-set.png" alt=""></p>
<p>双击“Docker Quickestart”可以启动MSYS2 ，用如下命令进行测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"><span class="meta">#</span>Docker version 17.10.0-ce, build f4ffd25</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker-compose --version</span><br><span class="line"><span class="meta">#</span>docker-compose version 1.16.1, build 6d1ac219</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker-machine --version</span><br><span class="line"><span class="meta">#</span>docker-machine.exe version 0.13.0, build 9ba6da9</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Hello from Docker!</span><br><span class="line"><span class="meta">#</span>This message shows that your installation appears to be working correctly.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>To generate this message, Docker took the following steps:</span><br><span class="line"><span class="meta">#</span> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"><span class="meta">#</span> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span><br><span class="line"><span class="meta">#</span>    (amd64)</span><br><span class="line"><span class="meta">#</span> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line"><span class="meta">#</span>    executable that produces the output you are currently reading.</span><br><span class="line"><span class="meta">#</span> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line"><span class="meta">#</span>    to your terminal.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta">#</span> $ docker run -it ubuntu bash</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"><span class="meta">#</span> https://cloud.docker.com/</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>For more examples and ideas, visit:</span><br><span class="line"><span class="meta">#</span> https://docs.docker.com/engine/userguide/</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta">#</span>CONTAINER ID        IMAGE                                   COMMAND             CREATED             STATUS                         PORTS               NAMES</span><br><span class="line"><span class="meta">#</span>a8e15cba83b6        hello-world                             "/hello"            10 seconds ago      Exited (0) 10 seconds ago                          musing_hamilton</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker rm a8e15cba83b6</span><br><span class="line"><span class="meta">#</span>a8e15cba83b6</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta">#</span>CONTAINER ID        IMAGE                                   COMMAND             CREATED             STATUS                         PORTS               NAMES</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>至此，docker就安装好了。</p>
<h2 id="下载OpenFOAM的-docker-image"><a href="#下载OpenFOAM的-docker-image" class="headerlink" title="下载OpenFOAM的 docker image"></a>下载OpenFOAM的 docker image</h2><p>很简单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker pull openfoamplus/of_v1706_centos73 # OF+</span><br><span class="line"><span class="meta">#</span> or</span><br><span class="line"><span class="meta">#</span> docker pull openfoam/openfoam5-paraview54 # OF5</span><br><span class="line"><span class="meta">#</span> list images</span><br><span class="line">docker image ls</span><br><span class="line"><span class="meta">#</span> REPOSITORY                       TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line"><span class="meta">#</span> hello-world                      latest              f2a91732366c        6 weeks ago         1.85kB</span><br><span class="line"><span class="meta">#</span> openfoamplus/of_v1706_centos73   latest              9b81f0cd518b        6 months ago        1.76GB</span><br></pre></td></tr></table></figure>
<h2 id="映射共享文件夹并测试OpenFOAM"><a href="#映射共享文件夹并测试OpenFOAM" class="headerlink" title="映射共享文件夹并测试OpenFOAM"></a>映射共享文件夹并测试OpenFOAM</h2><p>共享文件夹是与docker交换数据最方便的工具。windows下的docker可以通过虚拟机的功能配合docker工具自带的映射功能，实现映射共享文件夹的功能。为了避免问题过于复杂化，本文的共享文件夹位于<code>C:\Users\cheng</code>目录之下，这样可以避免对虚拟机的大幅变动。如果需要共享位于其他位置的文件夹，使用docker toolbox的请参考<a href="http://support.divio.com/local-development/docker/how-to-use-a-directory-outside-cusers-with-docker-toolbox-on-windows" target="_blank" rel="noopener">How to use a directory outside C:\Users with Docker Toolbox on Windows</a>，使用docker for windows的可以参考：<a href="https://rominirani.com/docker-on-windows-mounting-host-directories-d96f3f056a2c" target="_blank" rel="noopener">Docker on Windows — Mounting Host Directories</a></p>
<ul>
<li>docker for windows: 采用powershell</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cd c:\Users\cheng</span><br><span class="line"></span><br><span class="line">mkdir OpenFOAM</span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-i -t \</span><br><span class="line">--name myOFplus_1706 \</span><br><span class="line">-v <span class="string">"/c/Users/cheng/OpenFOAM:/home/ofuser/OpenFOAM"</span> \</span><br><span class="line">openfoamplus/of_v1706_centos73 \</span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的代码在进入bash后输入</span></span><br><span class="line">su ofuser</span><br><span class="line">cd </span><br><span class="line">mkdir -p <span class="variable">$FOAM_RUN</span></span><br><span class="line">run</span><br><span class="line">cp -r <span class="variable">$FOAM_TUTORIALS</span>/incompressible/icoFoam/cavity .</span><br><span class="line">./Allrun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要临时退出，但不中断执行</span></span><br><span class="line"><span class="comment"># 按Ctrl+p, Ctrl+q</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 再次进入docker image的bash</span></span><br><span class="line">docker attach myOFplus_1706</span><br></pre></td></tr></table></figure>
<ul>
<li>docker toolbox: 采用“Docker Quickestart”启动的仿bash界面。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cd c:\Users\cheng</span><br><span class="line"></span><br><span class="line">mkdir OpenFOAM</span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-i -t \</span><br><span class="line">--name myOFplus_1706 \</span><br><span class="line">-v "/c/Users/cheng/OpenFOAM:/home/ofuser/OpenFOAM" \</span><br><span class="line">openfoamplus/of_v1706_centos73 \</span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 下面的代码在进入bash后输入</span><br><span class="line">su ofuser</span><br><span class="line">cd </span><br><span class="line">mkdir -p $FOAM_RUN</span><br><span class="line">run</span><br><span class="line">cp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity .</span><br><span class="line">./Allrun</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 想要临时退出，但不中断执行</span><br><span class="line"><span class="meta">#</span> 按Ctrl+p, Ctrl+q</span><br></pre></td></tr></table></figure>
<h2 id="docker-中的OpenFOAM环境"><a href="#docker-中的OpenFOAM环境" class="headerlink" title="docker 中的OpenFOAM环境"></a>docker 中的OpenFOAM环境</h2><p>以下命令在docker中可以查看出安装环境</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cd </span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">echo $WM_PROJECT_DIR #OpenFOAM安装位置</span><br><span class="line"><span class="meta">#</span>/opt/OpenFOAM/OpenFOAM-v1706</span><br><span class="line">echo $WM_THIRD_PARTY_DIR #第三方软件文件夹位置</span><br><span class="line"><span class="meta">#</span>/opt/OpenFOAM/ThirdParty-v1706</span><br><span class="line">echo $WM_PROJECT_VERSION</span><br><span class="line"><span class="meta">#</span>v1706</span><br><span class="line">echo $WM_PROJECT_USER_DIR #OpenFOAM用户文件夹位置</span><br><span class="line"><span class="meta">#</span>/home/ofuser/OpenFOAM/ofuser-v1706</span><br><span class="line"></span><br><span class="line">echo $WM_OPTIONS #编译配置</span><br><span class="line"><span class="meta">#</span>linux64GccDPInt32Opt </span><br><span class="line"><span class="meta">#</span>编译配置为</span><br><span class="line"><span class="meta">#</span> linux64:64位Linux版本</span><br><span class="line"><span class="meta">#</span> DP:双精度</span><br><span class="line"><span class="meta">#</span> Gcc: GCC编译器</span><br><span class="line"><span class="meta">#</span> Int32: 32位整型</span><br><span class="line"><span class="meta">#</span> Opt: 性能优化版本，没有调试信息。</span><br><span class="line"></span><br><span class="line">g++ --version #采用的编译器版本</span><br><span class="line"><span class="meta">#</span>g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-11)</span><br><span class="line"><span class="meta">#</span>Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line"><span class="meta">#</span>This is free software; see the source for copying conditions.  There is NO</span><br><span class="line"><span class="meta">#</span>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line">mpirun --version # 采用的mpi版本</span><br><span class="line"><span class="meta">#</span>mpirun (Open MPI) 1.10.4</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Report bugs to http://www.open-mpi.org/community/help/</span><br></pre></td></tr></table></figure>
<h1 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h1><p>可以用paraview 进行后处理</p>
<h2 id="paraview-安装"><a href="#paraview-安装" class="headerlink" title="paraview 安装"></a>paraview 安装</h2><ul>
<li>网址：<a href="https://www.paraview.org/" target="_blank" rel="noopener">https://www.paraview.org/</a></li>
<li>下载地址：<a href="https://www.paraview.org/paraview-downloads/download.php?submit=Download&amp;version=v5.4&amp;type=binary&amp;os=Windows&amp;downloadFile=ParaView-5.4.1-Qt5-OpenGL2-Windows-64bit.exe" target="_blank" rel="noopener">https://www.paraview.org/paraview-downloads/download.php?submit=Download&amp;version=v5.4&amp;type=binary&amp;os=Windows&amp;downloadFile=ParaView-5.4.1-Qt5-OpenGL2-Windows-64bit.exe</a></li>
<li>版本：最新稳定版：5.4.1</li>
</ul>
<p>安装很容易。</p>
<p>由于windows版本的paraview没有编译安装OpenFOAM专用reader，所以需要在shell中，位于算例文件目录下用<code>touch a.foam</code>建立一个文件（一些教程中的<code>touch a.OpenFOAM</code>无效）。</p>
<p>后处理结果如下：</p>
<p><img src="/images/U_mag_comparison.png" alt="U_mag_comparison"></p>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenFOAM输出完整矩阵]]></title>
      <url>/2018/01/04/OpenFOAM%E8%BE%93%E5%87%BA%E5%AE%8C%E6%95%B4%E7%9F%A9%E9%98%B5/</url>
      <content type="html"><![CDATA[<p>输出单CPU算例带耦合边界条件的fvScalarMatrix中的完整矩阵信息。<br><a id="more"></a></p>
<h1 id="OpenFOAM输出完整矩阵"><a href="#OpenFOAM输出完整矩阵" class="headerlink" title="OpenFOAM输出完整矩阵"></a>OpenFOAM输出完整矩阵</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>OpenFOAM采用的特殊矩阵模式导致输出完整矩阵很困难。本文尝试解决的是输出单CPU算例带耦合边界条件的问题中的fvScalarMatrix的问题。</p>
<p>首先，需要限定是单CPU，否则可能存在CPU间的processorFvPatch耦合界面边界条件，fvScalarMatrix将无法包含所有的边界条件相关的源项。</p>
<p>其次耦合边界条件中仅支持cyclic类边界条件，jumpCyclic边界条件可能存在线性代数上的一致性问题，暂时不考虑。</p>
<p>再次，输出限于fvScalarMatrix，fvVectorMatrix的情况类似，但是涉及到更加复杂一些的操作。</p>
<p>最后，采用<code>cnpy</code>库输出为numpy支持的npy或npz格式，便于进一步分析，具体模式为COO模式，同时<code>cnpy</code>还提供了npy2mat, npz2mat, mat2npz等工具用于与matlab交换数据。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>需要首先安装一个<code>cnpy</code>的小程序库，用于生成numpy和matlab可以直接读取的文件。</p>
<ul>
<li>网址: <a href="https://github.com/rogersce/cnpy" target="_blank" rel="noopener">https://github.com/rogersce/cnpy</a></li>
<li>命令行:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在root账户下</span></span><br><span class="line">yum install cmake git -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># `su ofuser`到ofuser账户， check tools</span></span><br><span class="line">cmake --version</span><br><span class="line">g++ --version</span><br><span class="line">git --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># clone, configure, build and install</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/rogersce/cnpy.git cnpy_src</span><br><span class="line"><span class="built_in">cd</span> cnpy_src</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DENABLE_STATIC=ON -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/lib/cnpy</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>实际程序中<code>#include</code>如下代码：<code>dumpFvScalarMatrix.H</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fvCFD.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cyclicFvPatch.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cnpy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">path: 想要储存的文件名</span></span><br><span class="line"><span class="comment">Eqn: fvScalarMatrix 的常量引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpFvScalarMatrix</span><span class="params">( <span class="keyword">const</span> fvScalarMatrix&amp; Eqn,fileName filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (filepath.hasExt() == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      filepath = filepath.ext(<span class="string">"npz"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">const</span> label nCells = Eqn.diag().size();</span><br><span class="line">	<span class="keyword">const</span> label nFaces = Eqn.lower().size();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> scalar* <span class="keyword">const</span> __restrict__ diagPtr = Eqn.diag().begin();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> label* <span class="keyword">const</span> __restrict__ uPtr = Eqn.lduAddr().upperAddr().begin();</span><br><span class="line">	<span class="keyword">const</span> label* <span class="keyword">const</span> __restrict__ lPtr = Eqn.lduAddr().lowerAddr().begin();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> scalar* <span class="keyword">const</span> __restrict__ upperPtr = Eqn.upper().begin();</span><br><span class="line">	<span class="keyword">const</span> scalar* <span class="keyword">const</span> __restrict__ lowerPtr = Eqn.lower().begin();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;scalar&gt; AA(nCells+<span class="number">2</span>*nFaces);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;scalar&gt; S(nCells);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;scalar&gt; x0(nCells);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;label&gt; JR(nCells+<span class="number">2</span>*nFaces);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;label&gt; JC(nCells+<span class="number">2</span>*nFaces);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">auto</span> psi=Eqn.psi();</span><br><span class="line">    <span class="keyword">auto</span> s=Eqn.source();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// diag</span></span><br><span class="line">	<span class="keyword">for</span>(label cell=<span class="number">0</span>;cell&lt;nCells;cell++)</span><br><span class="line">	&#123;</span><br><span class="line">		AA[cell]=diagPtr[cell];</span><br><span class="line">		JR[cell]=cell;</span><br><span class="line">		JC[cell]=cell;</span><br><span class="line">         S[cell]=s[cell];</span><br><span class="line">         x0[cell]=psi[cell];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Upper</span></span><br><span class="line">	<span class="keyword">for</span>(label face=<span class="number">0</span>;face&lt;nFaces;face++)</span><br><span class="line">	&#123;</span><br><span class="line">		AA[face+nCells]=upperPtr[face];</span><br><span class="line">		JR[face+nCells]=uPtr[face];</span><br><span class="line">		JC[face+nCells]=lPtr[face];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Lower</span></span><br><span class="line">	<span class="keyword">for</span>(label face=<span class="number">0</span>;face&lt;nFaces;face++)</span><br><span class="line">	&#123;</span><br><span class="line">		AA[face+nCells+nFaces]=lowerPtr[face];</span><br><span class="line">		JR[face+nCells+nFaces]=lPtr[face];</span><br><span class="line">		JC[face+nCells+nFaces]=uPtr[face];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//边界贡献</span></span><br><span class="line">    <span class="keyword">auto</span> I = Eqn.internalCoeffs();</span><br><span class="line">    <span class="keyword">auto</span> B = Eqn.boundaryCoeffs();</span><br><span class="line">    <span class="keyword">auto</span> psib = psi.boundaryField();</span><br><span class="line">    forAll(psib,patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> fvPatch&amp; pp = psib[patchI].patch();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pp.coupled()) <span class="comment">//耦合边界</span></span><br><span class="line">        &#123;</span><br><span class="line">          	<span class="keyword">if</span>(isA&lt;cyclicFvPatch&gt;(pp)) <span class="comment">//只处理循环边界</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">const</span> cyclicFvPatch&amp; pnp= (refCast&lt;<span class="keyword">const</span> cyclicFvPatch&gt;(pp)).neighbPatch();</span><br><span class="line">              forAll(pp,faceI)</span><br><span class="line">            &#123;</span><br><span class="line">                label cellI = pp.faceCells()[faceI];</span><br><span class="line">                label cellJ = pnp.faceCells()[faceI];</span><br><span class="line">                AA[cellI] += I[patchI][faceI];</span><br><span class="line">                AA.push_back(B[patchI][faceI]);</span><br><span class="line">                JR.push_back(cellI);</span><br><span class="line">                JC.push_back(cellJ);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//其他非循环边界的耦合边界，统统报错退出</span></span><br><span class="line">            &#123;</span><br><span class="line">              SeriousError&lt;&lt;<span class="string">"Only support cyclic coupled BC!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//非耦合边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            forAll(pp,faceI)</span><br><span class="line">            &#123;</span><br><span class="line">                label cellI = pp.faceCells()[faceI];</span><br><span class="line">                AA[cellI] += I[patchI][faceI];</span><br><span class="line">                S[cellI] += B[patchI][faceI];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	cnpy::npz_save(filepath,<span class="string">"AA"</span>,&amp;AA[<span class="number">0</span>],&#123;AA.size()&#125;,<span class="string">"w"</span>);</span><br><span class="line">	cnpy::npz_save(filepath,<span class="string">"JR"</span>,&amp;JR[<span class="number">0</span>],&#123;JR.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line">	cnpy::npz_save(filepath,<span class="string">"JC"</span>,&amp;JC[<span class="number">0</span>],&#123;JC.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line">	cnpy::npz_save(filepath,<span class="string">"S"</span>,&amp;S[<span class="number">0</span>],&#123;S.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line">	cnpy::npz_save(filepath,<span class="string">"x0"</span>,&amp;x0[<span class="number">0</span>],&#123;x0.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="基于-icoFoam的源代码建立myIcoFoam"><a href="#基于-icoFoam的源代码建立myIcoFoam" class="headerlink" title="基于 icoFoam的源代码建立myIcoFoam"></a>基于 icoFoam的源代码建立myIcoFoam</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line">cd ..</span><br><span class="line">mkdir -p applications/solvers</span><br><span class="line">cd applications/solvers</span><br><span class="line"><span class="meta">#</span><span class="bash"> I put my solver here.</span></span><br><span class="line">pwd # /OF/OpenFOAM/-v1706/applications/solvers</span><br><span class="line">cp $FOAM_SOLVERS/incompressible/icoFoam -r .</span><br><span class="line">mv icoFoam myIcoFoam</span><br><span class="line">cd myIcoFoam</span><br><span class="line">mv icoFoam.C myIcoFoam.C</span><br><span class="line">sed -i s/icoFoam/myIcoFoam/g myIcoFoam.C</span><br><span class="line">sed -i s/icoFoam/myIcoFoam/g Make/files</span><br><span class="line">sed -i s/FOAM_APPBIN/FOAM_USER_APPBIN Make/files</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line">wmake</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> run</span></span><br><span class="line">run</span><br><span class="line">cd cavity</span><br><span class="line">foamJob -screen myIcoFoam</span><br></pre></td></tr></table></figure>
<h3 id="修改myIcoFoam的代码，输出pEqn的矩阵"><a href="#修改myIcoFoam的代码，输出pEqn的矩阵" class="headerlink" title="修改myIcoFoam的代码，输出pEqn的矩阵"></a>修改myIcoFoam的代码，输出pEqn的矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myIcoFoam.C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fvCFD.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pisoControl.H"</span></span></span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dumpFvScalarMatrix.H"</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">                  <span class="keyword">if</span> (piso.finalNonOrthogonalIter())</span><br><span class="line">                &#123;</span><br><span class="line">                    phi = phiHbyA - pEqn.flux();</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">//添加</span></span><br><span class="line">				<span class="keyword">if</span> (runTime.timeIndex()==<span class="number">2</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					Info&lt;&lt; <span class="string">"TimeIndex = 2, output matrix pEqn"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">					dumpFvScalarMatrix(pEqn,<span class="string">"Eqn.npz"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Make/options 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -I$(LIB_SRC)/finiteVolume/lnInclude \</span><br><span class="line">    -I$(LIB_SRC)/meshTools/lnInclude \</span><br><span class="line">    -I$(HOME)/lib/cnpy/include </span><br><span class="line"></span><br><span class="line">EXE_LIBS = \</span><br><span class="line">    -lfiniteVolume \</span><br><span class="line">    -lmeshTools \</span><br><span class="line">    -Wl,-rpath -Wl,$(HOME)/lib/cnpy/lib -L$(HOME)/lib/cnpy/lib -lcnpy</span><br></pre></td></tr></table></figure>
<h3 id="python后处理"><a href="#python后处理" class="headerlink" title="python后处理"></a>python后处理</h3><p>python需要安装scipy，在docker下比较简单的方法是到root账户下进行安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进root账户</span></span><br><span class="line">cd</span><br><span class="line">curl "https://bootstrap.pypa.io/get-pip.py" -o "get-pip.py"</span><br><span class="line">python get-pip.py</span><br><span class="line">pip install scipy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回到ofuser账户</span></span><br><span class="line">su ofuser</span><br><span class="line">cd</span><br><span class="line">python -c "import scipy as sp;print(sp.version.version)"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.0.0</span></span><br></pre></td></tr></table></figure>
<p>python后处理代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br><span class="line">data = np.load(<span class="string">"Eqn.npz"</span>)</span><br><span class="line"></span><br><span class="line">AA,JR,JC,S,x0 = data[<span class="string">'AA'</span>],data[<span class="string">'JR'</span>],data[<span class="string">'JC'</span>],data[<span class="string">'S'</span>],data[<span class="string">'x0'</span>]</span><br><span class="line">N = S.shape[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> coo_matrix</span><br><span class="line">sm = coo_matrix((AA,(JR,JC)),shape=(N,N))</span><br><span class="line">m = sm.toarray()</span><br><span class="line"><span class="keyword">print</span> m.shape</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://sssslide.com/www.slideshare.net/fumiyanozaki96/openfoam-32087641" target="_blank" rel="noopener">OpenFOAM －空間の離散化と係数行列の取り扱い（Spatial Discretization and Coefficient Matrix）－byFumiya Nozaki</a>中的第38页。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenFOAM的耦合边界处理]]></title>
      <url>/2018/01/04/OpenFOAM%E7%9A%84%E8%80%A6%E5%90%88%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>关于OpenFOAM中耦合边界的具体实现</p>
<a id="more"></a>
<h1 id="OpenFOAM的耦合边界处理"><a href="#OpenFOAM的耦合边界处理" class="headerlink" title="OpenFOAM的耦合边界处理"></a>OpenFOAM的耦合边界处理</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>首先，在计算机里，大量的矩阵其实是稀疏矩阵，而矩阵的表示方式都是非零元素（non-zero elements）和索引（index，即元素所在行列号，本文按照c语言的约定，从0开始）分开的。这是稀疏矩阵算法的特殊性，所以指明OpenFOAM中的矩阵时，需要<strong>同时指定非零元素的存放之处和索引</strong>的存放之处。</p>
<p>其实OpenFOAM中的还算简单，FEM程序中的索引更加复杂化。似乎索引的储存、管理和处理是PDE程序和ODE程序比较大的区别点。常规的计算物理讲算法太细，讲程序组织比较少。低阶程序的索引相对简单，高阶必然涉及到每个单元更多的自由度，索引的管理就复杂很多。</p>
<p>而常见的稀疏矩阵的表示方式有：</p>
<ol>
<li><p>序列对角模式：对于对角阵而言，如果是按照对角顺序储存非零元素，可以无需储存索引；</p>
</li>
<li><p>坐标对角模式：对于对角阵而言，如果没有按照对角顺序储存非零元素，需要一列坐标指定对角元素顺序；</p>
</li>
<li><p>COO坐标模式：有三列数组，一列储存非零元素，一列储存行号，一列储存列号，是最广义可用的稀疏矩阵储存模式，但是往往有信息的冗余；</p>
</li>
<li><p>CSR/CSC压缩行/列模式：一列储存非零元素（先从上到下行号递增，再从左到右列号递增），一列储存行号，一列储存压缩后的列号，这也是OpenFOAM的<code>lduAddress</code>类实际采用的储存格式；</p>
</li>
<li><p>Banded，带状储存模式：对于带状结构，可以采用此种模式，对于一维问题，矩阵一般来说都是带状的，但是对于三维问题，很难是窄带结构的；</p>
</li>
</ol>
<p>实际上，OpenFOAM采用的是一种极为特殊的分割储存的COO模式，常见教材称之为LDU分裂模式，常记为$A=L+D+U$，其中$L,D,U​$分别代表矩阵$A$的下三角部分（行号大于列号），对角部分和上三角部分（行号小于列号）。但是其实它远比上述LDU分裂（或者称之为LDU加法分解，注意与矩阵的LU乘法分解的区别）要复杂得多。</p>
<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>OpenFOAM是内含线性代数求解器的，这使其分析难度剧增，很闹搞清楚它的线性代数求解器是怎么工作的。</p>
<p>OpenFOAM的线性代数求解逻辑是矩阵分块思想和边界单独储存思想。而且有一些进化过程中的遗留和原始痕迹。</p>
<p>首先矩阵的主要部分是和网格拓扑相关的L、D、U矩阵，由<code>lduMatrix</code>矩阵处理的（但是它不像另一个非常相似的类<code>LduMatrix&lt;DType,LUType&gt;</code>） ，存的所有系数全是scalar类型的，并且存有lduAddr()来处理L、U矩阵的索引。</p>
<p>固定的来自网格的L、U索引带来的问题就是无法处理耦合边界条件，因为在网格的数据结构中，耦合边界条件和其他边界条件时一样的，但是实际上，耦合边界条件相当于另一边还有网格，应该和内部界面一样的处理方式才对。耦合边界条件包括cyclic和processor两大类。都不好处理。</p>
<p>于是OpenFOAM的设计思路是采用单独处理边界条件的方式。OpenFOAM的边界条件相关系数是存在fvMatrix中的，<code>fvMatrix&lt;Type&gt;</code>是<code>lduMatrix</code>的子类，请注意它可以是非标量的，这使其设计进一步复杂化。fvMatrix中有internalCoeffs和boundaryCoeffs两个成员，储存相关系数，在后面的求解时，内部系数会事先加在对角项中，外部系数会事先加到源项中，这样就构成了完整的方程组。</p>
<p>对于耦合边界而言，内部系数是一样的，但是外部系数不同，外部系数要乘以外部的单元值再加到源项上。</p>
<p>此外，由于内外系数加的位置在方程的两侧，所以有时候会引入一些正负符号上的差异。</p>
<p>而且，<code>lduMatrix</code>为了实现BiCG类的Krylov求解器，是支持<code>Tmul()</code>操作的，这导致当它要处理耦合边界的时候，还需要用耦合边界的内部系数乘以外部单元值。这些操作都非常的诡异。</p>
<p>但是OpenFOAM就是这么实现的，我感觉这种情况多半是有Legacy code的问题。而且这也导致了OpenFOAM的耦合求解器一直有问题，很难求解可压缩流动的方程。</p>
<h2 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h2><p>首先引入以下记号和符号：</p>
<ul>
<li><p>$N_i$，第i个处理器中的单元数，$\sum_i {N_i} = N$为单元总数。由于OpenFOAM是cell-center based FVM，所以$N$就是求解的自由度数，也就是待求解变量集合$x$的维度；</p>
<ul>
<li><p>同理，$x​$也可以视为各个处理器上待求解变量$x_i​$的垂直连接（vertical concatenation）$x=x_0||x_1||x_2||x_3||\dots||x_{N-1}​$</p>
</li>
<li><script type="math/tex; mode=display">
x= \begin{bmatrix} 
    x_0\\
    x_1\\
    \vdots\\
    x_i\\
    \vdots\\
    x_{N-1}
     \end{bmatrix}</script></li>
</ul>
</li>
<li><p>$F_i$为第i个处理器中的总面数（一般等于网格中的owner数），$K_i$为内部面数（一般等于网格中的neighbour数），$P_i$为边界面数（$F_i=K_i+P_i$）</p>
<ul>
<li>但是边界面分为两种，耦合边界（coupled BC, 在OpenFOAM中等价于interface，<code>fvPatch::coupled()</code>返回<code>true</code>）和非耦合边界（普通边界），第i个处理器中的第c号耦合边界的面数记为$ C_{i,c}$，第r号普通边界的面数记为$R_{i,r}$。</li>
<li>耦合边界和普通边界的相同点和区别在于，他们都有一些面，实现为<code>patchField()</code>，每个面的owner对应的内部单元<code>internalField()</code>，但是普通边界的面外侧没有单元，而耦合边界外侧是它所对应的另一个耦合边界，在实现的时候记为<code>neighbPatch()</code>， <code>neighbPatch</code> 是有内部单元的，这些<code>neighbPatch</code>的内部单元在原耦合边界中实现为<code>patchNeighbourField()</code></li>
<li>有了<code>internalField()</code>和<code>patchNeighbourField()</code>，耦合边界的处理起来很多时候其实就和内部边界面差不多了。</li>
<li>网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。</li>
<li>简单的情况下（没有AMI, ACMI等复杂的边界条件时），整个问题总的面数为$F=\sum_i{F_i}-\sum_{i}\sum_c{C_{i,c}}$</li>
</ul>
</li>
<li><p>记总的矩阵为$A$，大小为$N\times N$，按处理器可以分裂为$A_i$和耦合系数矩阵$I^C_{i,c}$和$B^C_{i,c}$。排列如下：</p>
</li>
<li><script type="math/tex; mode=display">
A= \begin{bmatrix} 
    A_0 & 0\\
   0 &A_1 & 0 \\
 0 &0 & A_2 & 0\\
   0 &\vdots &\vdots &\vdots  \\
   0 &\dots & \dots &\dots &A_i &0 \\
   0 &\dots &\dots &\dots &\dots &A_{N-1}
     \end{bmatrix} + 
O</script><ul>
<li>$A_i=L_i+D_i+U_i+I_i$，采用LDU分裂模式表示。</li>
<li>$C$表示Coupling耦合部分，也就是不在<code>lduMatrix::lduAddr()</code>表示范围内的部分，包括处理器之间的耦合边界的系数</li>
<li>一个简化描述如下</li>
<li><img src="/images/演示文稿1.jpg" alt="演示文稿1"></li>
</ul>
</li>
<li><p>源项为$s$，同理也可以按处理器分裂为$s_i$。</p>
</li>
<li><p>总体的方程为$A\cdot x=s$，展开之后应该是$L+D+U$</p>
</li>
<li><p>但是在每个处理器上调用<code>lduMatrix::solve()</code>时为$A_i\cdot x_i  = A’_i\cdot x-\sum_{j}\sum_c{B^C_{j,c}x^0_j}= s_i $</p>
<ul>
<li>$A_i = A’_i+\sum I^N = L_i+D_i+U_i+I^N_{i,c}$</li>
<li>网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。</li>
<li><img src="/images/lduMatrix_solve_diagram.png" alt="lduMatrix_solve_diagram"></li>
<li>上式中C23和C32都被储存了起来，但是其实调用<code>lduMatrix::solve()</code>时C23才是有用的，C32其实已经被加到对角项中了。但是计算<code>Tmul()</code>函数时会用到C32。</li>
<li>注意：<code>fvMatrix::solve()</code>调用时会玩些花样，修改对角项和源项之后，再调用<code>lduMatrix::solve()</code>。这是非常诡异的行为。</li>
</ul>
</li>
</ul>
<h2 id="各种情况下的矩阵组成"><a href="#各种情况下的矩阵组成" class="headerlink" title="各种情况下的矩阵组成"></a>各种情况下的矩阵组成</h2><h3 id="单一处理器无耦合边界情况"><a href="#单一处理器无耦合边界情况" class="headerlink" title="单一处理器无耦合边界情况"></a>单一处理器无耦合边界情况</h3><p>单一处理器，无耦合边界，仅有普通边界。</p>
<p>此时方程$A\cdot x= s$可分解为：</p>
<p>$[L+(D+\sum_n{I^N_n})+U]\cdot x = s’ + \sum_n{ b^N_n}$</p>
<p>其中$L,D,U$的非零元素为<code>lduMatrix</code>中储存的<code>lower_, diag_, upper_</code>，$D$采用序列对角模式进行索引，没有索引，$L,D$采用COO模式，其索引分别为<code>[lduAddr().lowerAddr(), lduAddr().upperAddr()]</code>和 <code>[lduAddr().upperAddr(), lduAddr().lowerAddr()]</code>；</p>
<p>$I^N_n,b^N_n$的非零元素分别为<code>fvMatrix&lt;T&gt;</code>中储存的<code>internalCoeffs_, boundaryCoeffs_</code>，分为若干patch进行索引，其中$I^N_n$是矩阵，采用坐标对角索引模式，对于编号<code>n</code>的索引为：<code>fvm.psi().lduAddr().patchAddr(n)</code>。而$b^N_n$是向量，但并非顺序排列的，也具有索引，索引也是<code>fvm.psi().lduAddr().patchAddr(n)</code>。</p>
<p>$s’$是内部离散和物理源汇产生的源项；</p>
<h3 id="单一处理器有耦合边界情况"><a href="#单一处理器有耦合边界情况" class="headerlink" title="单一处理器有耦合边界情况"></a>单一处理器有耦合边界情况</h3><p>单一处理器的耦合边界通常为cyclic循环边界条件。</p>
<p>此时方程$A\cdot x= s$可分解为：</p>
<p>$[L+(D+\sum_n{I^N_n}+\sum_c{I^C_c})+U]\cdot x = s’ + \sum_n{b^N_n}+\sum_c{ B^C_c} T_c(x^0)$</p>
<p>其中增加的$I^C_c, B^C_c$的非零元素依然是储存为<code>fvMatrix&lt;T&gt;</code>中的<code>internalCoeffs_, boundaryCoeffs_</code>，分为若干patch进行索引，其中$I^C_c$和$I^N_n$没有本质差别，对于编号为n的patch的索引为<code>fvm.psi().lduAddr().patchAddr(n)</code>。</p>
<p>但 $B^C_c$和 $b^N_n$ 的差别较大，一个是矩阵，一个是向量，二者量纲也不相同！$B^C_c$的索引包括行列两个索引，其中行索引还是<code>fvm.psi().lduAddr().patchAddr(n)</code>，列索引则是<code>neighbPatch().faceCells()</code></p>
<p>而$T_c$ 则是element wise的坐标变换矩算子，对于$x$为标量的情形，$T_c$的作用就是单位阵。</p>
<p>但是$T_c$的作用可以非常复杂，比如fixedJump条件就还涉及到$x^0$ 的平移。（但是此时存在一些问题，比如0场的<code>Amul()</code>作用之后非0。）</p>
<p>$x^0$表示$x$ 的旧值。</p>
<h3 id="多处理器存在耦合边界的情况"><a href="#多处理器存在耦合边界的情况" class="headerlink" title="多处理器存在耦合边界的情况"></a>多处理器存在耦合边界的情况</h3><p>多处理器的耦合边界通常为processor边界条件。</p>
<p>此时方程$A\cdot x= s$可分解在每个处理器i上：</p>
<p>$[L_i+(D_i+\sum_n{I^N_{i,n}}+\sum_c{I^C_{i,c}})+U_i]\cdot x_i = s’_i + \sum_n{b^N_{i,n}}+\sum_c{ B^C_{i,c}} T_{ji,c}(x^0_j)$</p>
<p>注意，下标中含$i$的量才储存在processor i的内存中。$x^0_j,j\ne i$的访问需要通信。</p>
<h2 id="一些奇怪的情形"><a href="#一些奇怪的情形" class="headerlink" title="一些奇怪的情形"></a>一些奇怪的情形</h2><p><code>lduMatrix</code>中定义的<code>Amul</code>, <code>Tmul</code>和<code>residual</code>函数采用的约定和常规数学教科书不同。</p>
<ul>
<li>理论上<code>Amul</code>应该定义了$A\cdot x = (L+D+U)\cdot x $操作。实际上它定义的是$[L+D+U]\cdot x - \sum_c{ B^C_c} T_c(x) $操作，我猜这样是便于和$s$源项直接比较。实际上A的定义应该是$L+D+U-  \sum_c{ B^C_c} T_c$ 。</li>
<li><code>Tmul</code>同理，不过把$B^C_c​$的非零元素换成了$I^C_c​$的非零元素。</li>
<li><code>residual</code>的约定是$s-A\cdot x$，而不是反过来。 </li>
</ul>
<p>另外，<code>fvMatrix</code>和<code>lduMatrix</code>对方程组的定义是有差别的。<code>lduMatrix::solve()</code>求解时给定了$L,D,U$，并传入源项$s$和边界系数$B^C_c$，求解的是$[L+D+U]\cdot x = s+\sum_c{ B^C_c} T_c(x)$。</p>
<p>但<code>fvMatrix::solveSegregated()</code>求解时，会调用<code>lduMatrix::solve()</code>，但在调用之前，它修改了$D=D+\sum_n{I^N_n}+\sum_c{I^C_c}$和$s=s+ \sum_n{b^N_n}$ ，再传入新的源项和边界系数。</p>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>非零元素</th>
<th>含义</th>
<th>索引</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>$D_i$</td>
<td><code>fvm.diag()</code></td>
<td>非边界贡献的对角项</td>
<td>序列对角模式</td>
<td>$N_i$</td>
</tr>
<tr>
<td>$L_i$</td>
<td><code>fvm.lower()</code></td>
<td>非边界贡献的下三角阵</td>
<td>COO模式<code>fvm.lduAddr().[lowerAddr(), upperAddr()]</code></td>
<td>$K_i$</td>
</tr>
<tr>
<td>$U_i$</td>
<td><code>fvm.upper()</code></td>
<td>非边界贡献的上三角阵</td>
<td>COO模式 <code>fvm.lduAddr().[upperAddr(), lowerAddr()]</code></td>
<td>$K_i$</td>
</tr>
<tr>
<td>$s_i$</td>
<td><code>fvm.source()</code></td>
<td>非边界贡献的源项</td>
<td>序列对角模式</td>
<td>$N_i$</td>
</tr>
<tr>
<td>$I^N_{i,r}$</td>
<td><code>fvm.internalCoeffs()[r]</code></td>
<td>第r个普通边界的对角项贡献</td>
<td>坐标对角模式 <code>fvm.psi().lduAddr(). patchAddr(r)</code></td>
<td>$R_{i,r}$</td>
</tr>
<tr>
<td>$I^C_{i,r}$</td>
<td><code>fvm.internalCoeffs()[c]</code></td>
<td>耦合边界的对角项贡献</td>
<td>坐标对角模式 <code>fvm.psi().lduAddr(). patchAddr(c)</code></td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$b^N_{i,n}$</td>
<td><code>fvm.boundaryCoeffs()[r]</code></td>
<td>第r个普通边界的源项贡献</td>
<td>坐标模式向量 <code>fvm.psi().lduAddr().patchAddr(r)</code></td>
<td>$R_{i,r}$</td>
</tr>
<tr>
<td>$B^C_{i,c}T_{ji,c}(x^0_j)$</td>
<td>计算得到</td>
<td>第c个耦合边界的显式耦合源项贡献</td>
<td>同上，且<code>false==fvm.psi().boundaryField()[patchi].coupled()</code></td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$B^C_{i,c}$</td>
<td><code>fvm.boundaryCoeffs()[c]</code></td>
<td>第c个耦合边界的显式耦合源项贡献的系数</td>
<td>全局行为类似COO模式，行坐标为<code>fvm.psi().lduAddr().patchAddr(c)</code> 列坐标对cyclic BC 为 <code>neighbPatch().faceCells()</code> 对于processor BC 为另一个processor上的<code>fvm.psi().lduAddr().patchAddr(c)</code></td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$x^0_{j}$</td>
<td><code>fvm.psi(). boundaryField(). scalarInterfaces()[c]. patchNeighbourField()</code></td>
<td>第c个耦合边界另一侧的初值</td>
<td>序列对角模式</td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$T_{ji,c}$</td>
<td><code>forwardT()</code></td>
<td>第c个耦合边界的坐标变换算子，通常可表示为一个张量</td>
<td>这是Element Wise的操作。</td>
<td>3*3</td>
</tr>
</tbody>
</table>
</div>
<p>参考<code>http://sssslide.com/www.slideshare.net/fumiyanozaki96/openfoam-32087641</code>中的38页。</p>
<h3 id="fvMatrix-solveSegregated-基本结构"><a href="#fvMatrix-solveSegregated-基本结构" class="headerlink" title="fvMatrix::solveSegregated()基本结构"></a><code>fvMatrix::solveSegregated()</code>基本结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fvMatrix.H +397</span></span><br><span class="line"><span class="comment">//- Solve segregated returning the solution statistics.</span></span><br><span class="line"><span class="comment">//  Use the given solver controls</span></span><br><span class="line">SolverPerformance&lt;Type&gt; solveSegregated(<span class="keyword">const</span> dictionary&amp;); <span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fvMatrixSolve.C +102</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:SolverPerformance&lt;Type&gt; Foam::fvMatrix&lt;Type&gt;::solveSegregated</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; solverControls</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info.masterStream(<span class="keyword">this</span>-&gt;mesh().comm())</span><br><span class="line">            &lt;&lt; <span class="string">"fvMatrix&lt;Type&gt;::solveSegregated"</span></span><br><span class="line">               <span class="string">"(const dictionary&amp; solverControls) : "</span></span><br><span class="line">               <span class="string">"solving fvMatrix&lt;Type&gt;"</span></span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; psi =</span><br><span class="line">       <span class="keyword">const_cast</span>&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp;&gt;(psi_);</span><br><span class="line"></span><br><span class="line">    SolverPerformance&lt;Type&gt; solverPerfVec</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"fvMatrix&lt;Type&gt;::solveSegregated"</span>,</span><br><span class="line">        psi.name()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    scalarField saveDiag(diag());//复制原有的diag_，注意diag_是标量数组</span><br><span class="line"></span><br><span class="line">    Field&lt;Type&gt; source(source_);<span class="comment">//复制原有的source_，注意source_是Field&lt;Type&gt;数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point include the boundary source from the coupled boundaries.</span></span><br><span class="line">    <span class="comment">// This is corrected for the implict part by updateMatrixInterfaces within</span></span><br><span class="line">    <span class="comment">// the component loop.</span></span><br><span class="line">    <span class="comment">//源项中加入非耦合边界项，以及耦合边界项</span></span><br><span class="line">    <span class="comment">// s' = s + boundary source (including coupled BC's contribution)</span></span><br><span class="line">    <span class="comment">//注意这里是加！</span></span><br><span class="line">    addBoundarySource(source); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typename</span> Type::labelType validComponents</span><br><span class="line">    (</span><br><span class="line">        psi.mesh().<span class="keyword">template</span> validComponents&lt;Type&gt;()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (direction cmpt=<span class="number">0</span>; cmpt&lt;Type::nComponents; cmpt++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (validComponents[cmpt] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//有时候有的分量不用求解。比如对称张量，球张量等</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy field and source</span></span><br><span class="line"></span><br><span class="line">        scalarField psiCmpt(psi.primitiveField().component(cmpt));//复制cmpt分量</span><br><span class="line">        <span class="comment">//加入对角项不区分耦合边界和非耦合边界</span></span><br><span class="line">        <span class="comment">//D' = D + I(边界对对角项的贡献)</span></span><br><span class="line">        addBoundaryDiag(diag(), cmpt);</span><br><span class="line"></span><br><span class="line">        scalarField sourceCmpt(source.component(cmpt));//源项cmpt分量</span><br><span class="line"></span><br><span class="line">        FieldField&lt;Field, scalar&gt; bouCoeffsCmpt</span><br><span class="line">        (</span><br><span class="line">            boundaryCoeffs_.component(cmpt)</span><br><span class="line">        );<span class="comment">//边界系数的cmpt分量：非耦合边界是源项，耦合边界是邻侧系数</span></span><br><span class="line"></span><br><span class="line">        FieldField&lt;Field, scalar&gt; intCoeffsCmpt</span><br><span class="line">        (</span><br><span class="line">            internalCoeffs_.component(cmpt)</span><br><span class="line">        );<span class="comment">//边界对角系数的cmpt分量</span></span><br><span class="line"></span><br><span class="line">        lduInterfaceFieldPtrsList interfaces =</span><br><span class="line">            psi.boundaryField().scalarInterfaces(); <span class="comment">//对于非耦合求解器，采用的是scalarInterfaces()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the initMatrixInterfaces and updateMatrixInterfaces to correct</span></span><br><span class="line">        <span class="comment">// bouCoeffsCmpt for the explicit part of the coupled boundary</span></span><br><span class="line">        <span class="comment">// conditions</span></span><br><span class="line">        <span class="comment">//先接收耦合边界发来的消息，然后把耦合边界内侧的值发出去。</span></span><br><span class="line">        <span class="comment">//根据几个实现来看，其实并不更改sourceCmpt</span></span><br><span class="line">        initMatrixInterfaces </span><br><span class="line">        (</span><br><span class="line">            bouCoeffsCmpt, <span class="comment">//用边界系数去update</span></span><br><span class="line">            interfaces, <span class="comment">//用那些耦合边界</span></span><br><span class="line">            psiCmpt, <span class="comment">//耦合时的初值</span></span><br><span class="line">            sourceCmpt, <span class="comment">//结果加入sourceCmpt中</span></span><br><span class="line">            cmpt <span class="comment">//指定cmpt分量</span></span><br><span class="line">        );</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新sourceCmpt的值</span></span><br><span class="line">		<span class="comment">//sourceCmpt -= bouCoeffsCmpt*scalarReceiveBuf_</span></span><br><span class="line">		<span class="comment">// s'' = s' - 耦合边界的源项贡献</span></span><br><span class="line">		<span class="comment">//注意这里是减去</span></span><br><span class="line">		<span class="comment">//此时源项s''中只剩下非耦合边界的贡献了。</span></span><br><span class="line">        updateMatrixInterfaces</span><br><span class="line">        (</span><br><span class="line">            bouCoeffsCmpt, <span class="comment">//用边界系数去update</span></span><br><span class="line">            interfaces,</span><br><span class="line">            psiCmpt,</span><br><span class="line">            sourceCmpt, <span class="comment">//结果加入sourceCmpt中</span></span><br><span class="line">            cmpt</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        solverPerformance solverPerf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Solver call</span></span><br><span class="line">        solverPerf = lduMatrix::solver::New</span><br><span class="line">        (</span><br><span class="line">            psi.name() + pTraits&lt;Type&gt;::componentNames[cmpt],</span><br><span class="line">            *<span class="keyword">this</span>,</span><br><span class="line">            bouCoeffsCmpt,</span><br><span class="line">            intCoeffsCmpt,</span><br><span class="line">            interfaces,</span><br><span class="line">            solverControls</span><br><span class="line">        )-&gt;solve(psiCmpt, sourceCmpt, cmpt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SolverPerformance&lt;Type&gt;::debug)</span><br><span class="line">        &#123;</span><br><span class="line">            solverPerf.print(Info.masterStream(<span class="keyword">this</span>-&gt;mesh().comm()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        solverPerfVec.replace(cmpt, solverPerf);</span><br><span class="line">        solverPerfVec.solverName() = solverPerf.solverName();</span><br><span class="line"></span><br><span class="line">        psi.primitiveFieldRef().replace(cmpt, psiCmpt);</span><br><span class="line">        diag() = saveDiag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    psi.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">    psi.mesh().setSolverPerformance(psi.name(), solverPerfVec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solverPerfVec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> coupledBC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenFOAM的残差定义]]></title>
      <url>/2018/01/04/OpenFOAM%E7%9A%84%E6%AE%8B%E5%B7%AE%E5%AE%9A%E4%B9%89/</url>
      <content type="html"><![CDATA[<p>关于OpenFOAM中残差定义的具体实现</p>
<a id="more"></a>
<h1 id="关于normFactor"><a href="#关于normFactor" class="headerlink" title="关于normFactor"></a>关于<code>normFactor</code></h1><p>根据代码，OpenFOAM求解器输出的标量残差initialResidual为量化的向量$L1$ 模。</p>
<p>定义为:</p>
<script type="math/tex; mode=display">
Res = \frac{|r|_1}{normFactor}= \frac{|s-A\cdot x|_1}{|A\cdot x^0 - A\cdot W  \cdot x^0|_1+|s - A\cdot W\cdot x^0|_1+\epsilon}</script><p>其中$W$是有效权重矩阵</p>
<script type="math/tex; mode=display">
W= \frac 1 N \begin{bmatrix}  
1 & 1 & \dots &1 &1 \\
1 & \vdots & \ddots &\vdots  & 1 \\
1 & \dots & \dots & 1 & 1 \\
\end{bmatrix}_{N\times N} =  \begin{bmatrix}  
1 \\
1 \\
\vdots \\
1\\
1
\end{bmatrix}_{N\times1} \times  \begin{bmatrix}  
\frac 1 N & \frac 1 N & \dots &\frac 1 N &\frac 1 N 
\end{bmatrix} _{1\times N}\\
=S\cdot M</script><p>$S$代表对矩阵行和算子，$M$ 代表对列向量的平均算子。</p>
<p>$\epsilon$是非常小量，OpenFOAM常定义为+1e-20。</p>
<p>向量$L1$模的定义为：$|x|_1= \sum_i{|x_i|}$</p>
<p>但是要做MMS比较需要用到函数的L1模：</p>
<script type="math/tex; mode=display">
|r|_{L1}=\frac{\int_{\Omega}{|r|dx}}{\int_{\Omega}{dx}} \approx \frac{\sum_i{V_i |r|}}{\sum_i V_i}</script><p>与向量$L1$模相比，相差了一个单元体积的权重。</p>
<p>我想这部分解释了为何学术界的文章里残差收敛特别快，而OpenFOAM总是收敛到一定程度就收敛不下去了，因为OpenFOAM的残差采用的normFactor每次都在随$x^0​$变化，随着解的收敛，normFactor在减小，从而导致OpenFOAM输出的残差收敛速度降低。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PCG.C:107</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// --- Calculate normalised residual norm</span></span><br><span class="line">    solverPerf.initialResidual() =</span><br><span class="line">        gSumMag(rA, matrix().mesh().comm()) <span class="comment">//this is the vector L1 norm向量L1模</span></span><br><span class="line">       /normFactor;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//lduMatrixSolver.C:175</span></span><br><span class="line">Foam::scalar Foam::lduMatrix::solver::normFactor</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; psi,</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; source,</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; Apsi,</span><br><span class="line">    scalarField&amp; tmpField</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// --- Calculate A dot reference value of psi</span></span><br><span class="line">    matrix_.sumA(tmpField, interfaceBouCoeffs_, interfaces_); <span class="comment">//tmpField = A*S</span></span><br><span class="line"></span><br><span class="line">    tmpField *= gAverage(psi, matrix_.lduMesh_.comm()); <span class="comment">//tmpField = A*S*M*x0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// normFactor = |A*x0-A*S*M*x0|_1+|s-A*S*M*x0|_1+eps</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        gSum</span><br><span class="line">        (</span><br><span class="line">            (mag(Apsi - tmpField) + mag(source - tmpField))(),</span><br><span class="line">            matrix_.lduMesh_.comm()</span><br><span class="line">        )</span><br><span class="line">      + solverPerformance::small_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At convergence this simpler method is equivalent to the above</span></span><br><span class="line">    <span class="comment">// return 2*gSumMag(source) + solverPerformance::small_;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> coupledBC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/08/09/hello-world/</url>
      <content type="html"><![CDATA[<p>Hello World! </p>
<p>对公式、代码和插入图片进行测试。</p>
<a id="more"></a>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><ul>
<li>行内公式: $e^{\pi i}+1=0$</li>
<li>块公式:</li>
<li><script type="math/tex; mode=display">F=\frac{Gm_1m_2}{r^2}</script></li>
</ul>
<script type="math/tex; mode=display">
F=\frac{Gm_1m_2}{r^2}</script><ul>
<li>关于$\rho$的连续性方程</li>
</ul>
<script type="math/tex; mode=display">
\frac{\partial \rho}{\partial t}+\vec v\cdot\frac{\partial \rho}{\partial x}=0</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight fortran"><figcaption><span>CFL3D主程序中的Setup子程序声明</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">subroutine</span></span> setup(lw,lw2,w,mgwk,wk,nwork,iwk,iwork,itest,</span><br><span class="line">     .                 jtest,ktest,maxbl,mxbli,maxgr,maxseg,nsub1,</span><br><span class="line">     .                 maxxe,intmax,iitot,ncycmax,lwdat,lig,lbg,iovrlp,</span><br><span class="line">     .                 qb,nblock,iviscg,jdimg,kdimg,idimg,utrans,</span><br><span class="line">     .                 vtrans,wtrans,omegax,omegay,omegaz,xorig,</span><br><span class="line">     .                 yorig,zorig,dxmx,dymx,dzmx,dthxmx,dthymx,</span><br><span class="line">     .                 dthzmx,thetax,thetay,thetaz,rfreqt,rfreqr,</span><br><span class="line">     .                 xorig0,yorig0,zorig0,time2,thetaxl,thetayl,</span><br><span class="line">     .                 thetazl,itrans,irotat,idefrm,bcvali,bcvalj,</span><br><span class="line">     .                 bcvalk,nbci0,nbcidim,nbcj0,nbcjdim,</span><br><span class="line">     .                 nbck0,nbckdim,ibcinfo,jbcinfo,kbcinfo,bcfilei,</span><br><span class="line">     .                 bcfilej,bcfilek,ngrid,ncgg,nblg,iemg,inewgg,</span><br><span class="line">     .                 rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,cmxw,cmyw,</span><br><span class="line">     .                 cmzw,n_clcd,clcd,nblocks_clcd,blocks_clcd,</span><br><span class="line">     .                 chdw,swetw,fmdotw,cfttotw,cftmomw,cftpw,</span><br><span class="line">     .                 cftvw,rmstr,nneg,ntr,windex,</span><br><span class="line">     .                 ninter,iindex,nblkpt,dthetxx,dthetyy,dthetzz,</span><br><span class="line">     .                 iibg,kkbg,jjbg,ibcg,dxintg,dyintg,dzintg,iiig,</span><br><span class="line">     .                 jjig,kkig,ibpntsg,iipntsg,mblk2nd,nou,bou,nbuf,</span><br><span class="line">     .                 ibufdim,ireq_qb,igridg,bcfiles,mxbcfil,</span><br><span class="line">     .                 utrnsae,vtrnsae,wtrnsae,omgxae,omgyae,omgzae,</span><br><span class="line">     .                 xorgae,yorgae,zorgae,thtxae,thtyae,thtzae,</span><br><span class="line">     .                 rfrqtae,rfrqrae,icsi,icsf,jcsi,jcsf,</span><br><span class="line">     .                 kcsi,kcsf,freq,gmass,damp,x0,gf0,nmds,maxaes,</span><br><span class="line">     .                 aesrfdat,perturb,islavept,nslave,iskip,jskip,</span><br><span class="line">     .                 kskip,bmat,stm,stmi,gforcn,gforcnm,xxn,</span><br><span class="line">     .                 nsegdfrm,idfrmseg,iaesurf,maxsegdg,nmaster,</span><br><span class="line">     .                 aehist,timekeep,inpl3d,nplots,nplot3d,levelg,</span><br><span class="line">     .                 iadvance,xs,gforcs,xorgae0,yorgae0,zorgae0,</span><br><span class="line">     .                 icouple,lfgm,nblk,limblk,isva,nblelst,</span><br><span class="line">     .                 iskmax,jskmax,kskmax,ue,irdrea,nbli,nummem)</span><br><span class="line">#   ifdef <span class="built_in">CMPLX</span></span><br><span class="line">#   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">use</span> module_kwstm, <span class="keyword">only</span>:kws_init</span><br><span class="line">#   <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<h2 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h2><p>欢迎访问本博客：冰水混合物<br><img src="/images/qr_code_test.jpg" alt="冰水混合物"></p>
]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 公式 </tag>
            
            <tag> 图形 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>

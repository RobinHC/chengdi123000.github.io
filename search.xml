<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[rhoCentralFoam解析]]></title>
      <url>/2018/01/05/rhoCentralFoam%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>rhoCentralFoam是OpenFOAM中一个基于密度的可压缩求解器，算超声速通常用它比较合适。但是网上缺乏对其程序的分析，本文结合开发者的原始文献对其进行简单分析。</p>
<a id="more"></a>
<h1 id="rhoCentralFoam解析"><a href="#rhoCentralFoam解析" class="headerlink" title="rhoCentralFoam解析"></a>rhoCentralFoam解析</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先明确一些关键概念。</p>
<h3 id="半隐式分离求解器"><a href="#半隐式分离求解器" class="headerlink" title="半隐式分离求解器"></a>半隐式分离求解器</h3><p>首先从代码来看这是一个半隐式(semi-implicit)的分离(segregate)求解器：</p>
<ul>
<li><p>半隐式的意思是代码中只有部分项是隐式的，而另一些项是显式的，参考文献<a href="people.clarkson.edu/~sfulton/pubs/sitd.pdf">Semi-Implicit Time Differencing</a>认为半隐式格式的时间步长其实不太有较大优势，除非显式部分的能量占比很小。</p>
<ul>
<li>这种半隐式体现在不同的项上，比如粘性项：<br>$\mathbf \tau = \nabla\cdot(\mu \nabla \mathbf u )+\mathbf\tau_{MC}=  { \nabla\cdot(\mu \nabla \mathbf u ) }^{n+1} +{ (\nabla\mathbf u)^T - \frac 2 3 (\nabla\cdot\mathbf u) \mathbf I}^{n}$<ul>
<li>没有转置的第一项就可以隐式离散，但是后面的就不行，由于OpenFOAM实现方式的限制，暂时只能用显式离散。</li>
</ul>
</li>
<li>这种半隐式还体现在非线性项上，主要是为了把非线性方程线性化：<br>$\rho u u = [\rho u ]^{n} \times u^{n+1}$</li>
<li>其实非线性方程线性化有两种方法：Newton方法和Picard方法。Newton方法是对增量进行求解，通常会用到Jacobian矩阵或者其近似矩阵，而Picard方法是直接对全量求解，从实现角度来看可能更简单，但是收敛会更慢，不过从实践来讲，通常计算物理和计算数学界的人偏好用Jacobian矩阵，而CFD界的人似乎因为传统更喜欢用Picard迭代。</li>
</ul>
</li>
<li><p>分离的意思是它是先求解密度、再求解速度和能量方程的，而在求解密度的时候认为速度和能量是不变的，而求解速度的时候，密度已经更新过了，这会导致变量的一致性问题，比如文章中提到的温度T如果不做处理可能出现负值的问题。</p>
<h3 id="界面数值通量的处理和实现"><a href="#界面数值通量的处理和实现" class="headerlink" title="界面数值通量的处理和实现"></a>界面数值通量的处理和实现</h3><p>可压缩流的关键问题在于界面数值通量的处理，rhoCentralFoam采用的是KT或KNP格式，在<code>system/fvScheme</code>中有一个<code>fluxScheme</code>关键字（程序中的type是word ），如果是<code>Kurganov</code>，那么就是KNP中心上风格式，如果是<code>Tamdor</code>，则是KT中心格式。tutorial中自带算例一般是<code>Kurganov</code>，即KNP中心上风格式。</p>
</li>
</ul>
<p>在离散过程中，由于OpenFOAM本身没有提供同时取得界面两侧插值的功能，所以rhoCentralFoam是自己实现的。方法是利用辅助用途的表面张量场pos和neg来制定界面物理量的插值方向。pos和neg的源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*createFields.H*/</span></span><br><span class="line"><span class="comment">//line 64</span></span><br><span class="line">surfaceScalarField pos <span class="comment">//表面张量场</span></span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"pos"</span>,</span><br><span class="line">        runTime.timeName(),</span><br><span class="line">        mesh</span><br><span class="line">    ),</span><br><span class="line">    mesh,</span><br><span class="line">    dimensionedScalar(<span class="string">"pos"</span>, dimless, <span class="number">1.0</span>) <span class="comment">//无量纲</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">surfaceScalarField neg</span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"neg"</span>,</span><br><span class="line">        runTime.timeName(),</span><br><span class="line">        mesh</span><br><span class="line">    ),</span><br><span class="line">    mesh,</span><br><span class="line">    dimensionedScalar(<span class="string">"neg"</span>, dimless, <span class="number">-1.0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>具体的获取某个界面(face)某个方向的插值操作是通过interpolate函数完成的，函数定义如下面的代码，当传入的<code>faceFlux</code>是正的（如<code>pos</code>），那么就用这个<code>face</code>的<code>owner</code>侧的插值，否则用<code>face</code>的<code>neighbour</code>侧的插值，具体的插值算法又由<code>name</code>参数指定，系统会从<code>fvScheme</code>配置文件中找指定的插值方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*src\finiteVolume\interpolation\surfaceInterpolation\surfaceInterpolation\surfaceInterpolation.H*/</span></span><br><span class="line"><span class="comment">//line 98</span></span><br><span class="line">    <span class="comment">//- Interpolate field onto faces using scheme given by name in fvSchemes</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; //函数模板</span></span><br><span class="line"><span class="class">    //<span class="title">static</span>静态函数，<span class="title">tmp</span>对象避免对象传递时析构构造的开销</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">tmp</span>&lt;GeometricField&lt;Type, fvsPatchField, surfaceMesh&gt;&gt; <span class="title">interpolate</span></span></span><br><span class="line"><span class="class">    (</span></span><br><span class="line"><span class="class">        <span class="title">const</span> <span class="title">GeometricField</span>&lt;Type, fvPatchField, volMesh&gt;&amp; <span class="title">tvf</span>,</span></span><br><span class="line"><span class="class">        <span class="title">const</span> <span class="title">surfaceScalarField</span>&amp; <span class="title">faceFlux</span>,</span></span><br><span class="line"><span class="class">        <span class="title">const</span> <span class="title">word</span>&amp; <span class="title">name</span></span></span><br><span class="line"><span class="class">    );</span></span><br></pre></td></tr></table></figure>
<h2 id="权重以及文章中公式的错误"><a href="#权重以及文章中公式的错误" class="headerlink" title="权重以及文章中公式的错误"></a>权重以及文章中公式的错误</h2><p>文章和编程中有两个权重，一个是插值权重，也就是界面物理量和周围单元(owner和neighbour)物理量的关系：文章中公式11.5(公式11和12之间的未编号公式)如下：</p>
<script type="math/tex; mode=display">
\mathbf{\Psi}_f=(1-g_{f+})\mathbf{\Psi}_P+g_{f+}\mathbf{\Psi}_N\\

g_{f+}=\beta(r)(1-w_f)\\

\beta(r)=\frac{r+|r|}{1+r},\text{ van Leer limiter}\\

w_f = \frac{|\mathbf{S}_f\cdot\mathbf{d}_{fN}|}{|\mathbf{S}_f\cdot\mathbf{d}_{}|}     \text{  weighting coefficient}</script><p>其中$\mathbf{\Psi}_f, \mathbf{\Psi}_P, \mathbf{\Psi}_N$ 分别代表界面，owner和neighbour网格中心的物理量。</p>
<p>$g_{f+}$表示插值权重。</p>
<p>$w_f$ 是权重因子。</p>
<p>$\beta(r)$是限制器，而参数$r$ 表示两侧的梯度和平均梯度的函数。</p>
<p>另一个是重构的权重，只涉及界面两侧的量，KT和KNP的区别只在于重构权重的选取方式不一样。在文章中的表示方式是：</p>
<script type="math/tex; mode=display">
\sum_f{\phi_f\mathbf{\Psi}_f}=
\sum_f{[\alpha\phi_{f+}\mathbf{\Psi}_{f+}+(1-\alpha)\phi_{f-}\mathbf{\Psi}_{f-}+
\omega_f(\mathbf{\Psi}_{f-}-\mathbf{\Psi}_{f+})
]}</script><p>其中$\omega_f$是起耗散作用的，只有在对流项中使用，因为用得比较频繁，所以代码实现和文中公式有一些不一致，代码实现如下：</p>
<script type="math/tex; mode=display">
\sum_f{\phi_f\mathbf{\Psi}_f}=
\sum_f{[(\alpha\phi_{f+}+\omega_f)\mathbf{\Psi}_{f+}+((1-\alpha)\phi_{f-}-\omega_f)\mathbf{\Psi}_{f-}]}</script><p>此外，这个重构权重的公式有个错误就是扩散项的符号不对，扩散项中$\mathbf{\Psi}_{f\pm}$的权重和代码实现是相反的，个人认为代码实现应该是对的，文章中是错误的。</p>
<h2 id="fvc-div和fvc-ddt的量纲问题"><a href="#fvc-div和fvc-ddt的量纲问题" class="headerlink" title="fvc::div和fvc::ddt的量纲问题"></a>fvc::div和fvc::ddt的量纲问题</h2><p>还有一个问题是OF中的fvc::div($\phi,\alpha$)和数学$\nabla\cdot(\phi\alpha)$是不一样的，<code>fvc::div</code>除以了体积V：</p>
<script type="math/tex; mode=display">
\text{fvc::div}(\phi,\alpha)=\frac{\sum_f{\phi_f\alpha_f}}{V}</script><p>这点从代码可以看出：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*src/finiteVolume/finiteVolume/fvc/fvcSurfaceIntegrate.H*/</span></span><br><span class="line"><span class="comment">//line:104</span></span><br><span class="line">                ssf.dimensions()/dimVol,</span><br></pre></td></tr></table></figure></p>
<p>而fvc::ddt($\alpha$)和数学上一致，以Euler格式为例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*src\finiteVolume\finiteVolume\ddtSchemes\EulerDdtScheme\EulerDdtScheme.C*/</span></span><br><span class="line"><span class="comment">//line: 102</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">EulerDdtScheme</span>&lt;Type&gt;:</span>:fvcDdt</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; vf</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    dimensionedScalar rDeltaT = <span class="number">1.0</span>/mesh().time().deltaT();</span><br><span class="line"></span><br><span class="line">    IOobject ddtIOobject</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"ddt("</span>+vf.name()+<span class="string">')'</span>,</span><br><span class="line">        mesh().time().timeName(),</span><br><span class="line">        mesh()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mesh().moving())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tmp&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">new</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;</span><br><span class="line">            (</span><br><span class="line">                ddtIOobject,</span><br><span class="line">                rDeltaT*</span><br><span class="line">                (</span><br><span class="line">                    vf()</span><br><span class="line">                  - vf.oldTime()()*mesh().Vsc0()/mesh().Vsc()</span><br><span class="line">                ),</span><br><span class="line">                rDeltaT.value()*</span><br><span class="line">                (</span><br><span class="line">                    vf.boundaryField() - vf.oldTime().boundaryField()</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tmp&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">new</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;</span><br><span class="line">            (</span><br><span class="line">                ddtIOobject,</span><br><span class="line">                rDeltaT*(vf - vf.oldTime()) <span class="comment">//显然如果vf的量纲是D,那么ddt(vf)的量纲是D/T</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>翻译成公式是：</p>
<script type="math/tex; mode=display">
\text{fvc::ddt}(\alpha)=\frac{1}{\Delta t}(\alpha^n-\alpha^{n-1})</script><p>这样OpenFOAM的代码中的公式量纲才是正确的。</p>
<p>参考：<a href="http://www.cfd-china.com/topic/703/fvc-div%E7%9A%84%E5%89%8D%E5%90%8E%E9%87%8F%E7%BA%B2%E5%85%B3%E7%B3%BB%E5%88%B0%E5%BA%95%E6%98%AF%E5%95%A5" target="_blank" rel="noopener">http://www.cfd-china.com/topic/703/fvc-div%E7%9A%84%E5%89%8D%E5%90%8E%E9%87%8F%E7%BA%B2%E5%85%B3%E7%B3%BB%E5%88%B0%E5%BA%95%E6%98%AF%E5%95%A5</a></p>
<p>个人认为OpenFOAM很多时候的做法是为了减少计算量：</p>
<ul>
<li>比如喜欢用界面通量，避免存面矢量场，用面标量场就够了；</li>
<li>有些内部实现是不带单位的数组，而不是带单位的<code>dimensionedField</code></li>
</ul>
<h2 id="总体算法"><a href="#总体算法" class="headerlink" title="总体算法"></a>总体算法</h2><p>更多的细节参考文章中的算法，在文中第14页</p>
<ul>
<li>while t&lt;$t_{end}​$ do<ul>
<li>t := t+ dt</li>
<li>利用van Leer限制器，从单元场$\rho,\mathbf{\hat u},T​$中插值得到$\rho<em>{f\pm},\mathbf{\hat u}</em>{f\pm},T_{f\pm}​$</li>
<li>计算$\mathbf{u}<em>{f\pm}=\mathbf{\hat u}</em>{f\pm}/\rho<em>{f\pm},p</em>{f\pm}=\rho<em>{f\pm} RT</em>{f\pm},\phi<em>{f\pm}=\mathbf{S}_f\cdot\mathbf{u}</em>{f\pm},c<em>{f\pm}=\sqrt{\gamma R T</em>{f\pm}}$</li>
<li>根据公式7-13计算对流导数和$\nabla p$</li>
<li>更新$\mathbf{T}_{exp},\mu,k​$</li>
<li>根据方程1求解密度$\rho$</li>
<li>根据方程18求解质量流率$\mathbf{\hat u}​$(无粘动量预测步)</li>
<li>更新$\mathbf{u}=\mathbf{\hat u}/\rho​$</li>
<li>根据方程19求解速度$\mathbf{u}​$(扩散速度修正步)</li>
<li>根据方程20求解能量流率$\hat{E}​$(无粘能量预测步)</li>
<li>根据$\hat{E},\mathbf u,\rho$更新温度$T$</li>
<li>根据方程21求解温度$T$(扩散温度修正步)</li>
<li>更新压力$p=\rho R T​$</li>
</ul>
</li>
<li>end while</li>
</ul>
<p>但是文章是在OpenFOAM 1.5中实现的，在现在的OpenFOAM中的rhoCentralFoam实现有点儿不一样的地方，比如能量方程的求解不是求温度T了，而是直接求解内能e。</p>
<h2 id="粘性应力项"><a href="#粘性应力项" class="headerlink" title="粘性应力项"></a>粘性应力项</h2><p>根据文章内容和公式4，<code>rhoCentralFoam</code>没有考虑体积粘性，文中的公式为：</p>
<script type="math/tex; mode=display">
\mathbf T = -2\mu \times\text{dev}(\mathbf D) 

= -2\mu \times\text{dev}(\frac 1 2 [\nabla \mathbf u+\nabla (\mathbf u)^T])

= -2\mu\times \{\frac 1 2 [\nabla \mathbf u+\nabla (\mathbf u)^T]-\frac 1 3 tr(\nabla \mathbf u+\nabla (\mathbf u)^T)\mathbf I\}

= -\mu[\nabla \mathbf u+\nabla (\mathbf u)^T]-\frac 2 3\mu(\nabla\cdot \mathbf u) \mathbf I

= -\mu\nabla \mathbf u-\mu[\nabla (\mathbf u)^T+\frac 2 3 (\nabla\cdot \mathbf u) \mathbf I]</script><p>这个最终公式是有点奇怪的，一是它的符号和常规的推导是相反的，通常粘性应力是正的。二是它的形式和可压缩流的粘性应力有一定区别。</p>
<h3 id="关于可压缩流粘性应力、第二粘性系数、体积粘性"><a href="#关于可压缩流粘性应力、第二粘性系数、体积粘性" class="headerlink" title="关于可压缩流粘性应力、第二粘性系数、体积粘性"></a>关于可压缩流粘性应力、第二粘性系数、体积粘性</h3><p>参考文献<a href="https://link.springer.com/article/10.1007/s00707-015-1380-9" target="_blank" rel="noopener">A note on Stokes’ hypothesis</a>，<br>总应力$\mathbf S$可以表示为：</p>
<script type="math/tex; mode=display">
\mathbf S = -p_e \mathbf I + \mathbf T</script><p>其中$p_e$表示热力学平衡压力，负号表示压力向内为正。</p>
<p>而$\mathbf T$表示粘性应力，是变形率的函数，变形率可以用速度的梯度$\nabla\mathbf u$来表征，而根据应力应和刚体旋转部分不想关的要求，在将速度梯度进行加法分解之后，$\nabla\mathbf u=\mathbf E+\mathbf \Omega = \frac 1 2 (\nabla\mathbf u+(\nabla\mathbf u)^T)+\frac 1 2 (\nabla\mathbf u-(\nabla\mathbf u)^T)$，<br>再考虑到应力和应变率对称性的要求，应力的函数形式为：</p>
<script type="math/tex; mode=display">
\mathbf T = \lambda (\nabla \cdot \mathbf u) \mathbf I + 2\mu \mathbf E
=\lambda (\nabla \cdot \mathbf u) \mathbf I +\mu[\nabla\mathbf u+(\nabla\mathbf u)^T]</script><p>其中$\mu$被称为动力粘性系数，也就是通常所说的粘性系数。$\lambda$就是第二粘性系数。</p>
<p>再进一步地将$\mathbf E$分解为各向同性部分和偏量部分：</p>
<script type="math/tex; mode=display">
\mathbf E = \mathbf A+\mathbf D=\frac 1 3 (\nabla \cdot \mathbf u) \mathbf I +(\mathbf E-\mathbf A)</script><p>则粘性力可以表示为：</p>
<script type="math/tex; mode=display">
\mathbf T = (\lambda+\frac 2 3 \mu) (\nabla \cdot \mathbf u) \mathbf I + 2\mu \mathbf D
=\kappa(\nabla \cdot \mathbf u) \mathbf I + 2\mu \mathbf D</script><p>总应力可以表示为：</p>
<script type="math/tex; mode=display">
\mathbf S = [-p_e+(\lambda+\frac 2 3 \mu) (\nabla \cdot \mathbf u)] \mathbf I + 2\mu \mathbf D= [-p_e+\kappa (\nabla \cdot \mathbf u)] \mathbf I + 2\mu \mathbf D</script><p>其中$-p_e+(\lambda+\frac 2 3 \mu) (\nabla \cdot \mathbf u)$被称之为机械压力(mechanical pressure)。而$\kappa$被称为体积粘性系数，这就引入了Stokes假设</p>
<h3 id="Stokes-假设"><a href="#Stokes-假设" class="headerlink" title="Stokes 假设"></a>Stokes 假设</h3><p>明显可以看出，两种条件下机械压力和热力学平衡压力相同，那就是</p>
<ul>
<li>不可压缩流动：$\nabla \cdot \mathbf u =0$</li>
<li>满足Stokes 假设: $\kappa=\lambda+\frac 2 3 \mu=0$</li>
</ul>
<p>实际上</p>
<ul>
<li>对于单原子分子气体，动理学理论(kinetic theory)认为体积粘性为0，Stokes假设成立，少量试验证据也证实了这一点，而且一些研究认为动理学理论隐含假设了体积粘性为0；</li>
<li>对于多原子分子气体，由于存在内部自由度，而体积粘性和达到局部平衡的延迟有关，所以不为0，试验结果也发现体积粘性不可忽略，对于N2和O2，$\kappa = O(1)\mu$，对于CO2，$\kappa = O(1000)\mu$</li>
<li>对于许多液体而言，$\kappa &gt;&gt; \mu$</li>
<li>体积粘性的影响可以用无量纲数$\frac{\kappa\nabla\cdot\mathbf u}{p_e}​$来表征，对于绝大多数情况这个影响是可以忽略的，但是存在例外情况。<ul>
<li>CO2中的高超声速流动和激波（火星再入？）；</li>
<li>高频声波；</li>
</ul>
</li>
</ul>
<p>在rhoCentralFoam文章中，假设了体积粘性为0，那么是怎么实现的呢？</p>
<h3 id="粘性项的FVM编程实践"><a href="#粘性项的FVM编程实践" class="headerlink" title="粘性项的FVM编程实践"></a>粘性项的FVM编程实践</h3><p>在有限体积离散中，需要把尽可能多的项用采用Gauss公式用面积分的方式表达，上述式子中的$\mathbf D,\mathbf E$等量在物理上是好东西，但是在FVM实现中比较麻烦，尤其是难以表达成隐式方式，所以在FVM中还是尽量多地用$\nabla\cdot \mathbf u,\nabla \mathbf u$等表达方式。</p>
<p>因此，《The finite volume method in computational fluid dynamics: an advanced introduction to OpenFOAM and Matlab》中的公式3.37中，将粘性应力分为了两部分。</p>
<script type="math/tex; mode=display">
\frac \partial {\partial t}[\rho \mathbf u]
+\frac \partial {\partial x}[\rho \mathbf u \mathbf u] 
=
-\nabla p
+\{
\nabla\cdot[\mu\nabla\mathbf u]
\}_1
+\{
\nabla\cdot[\mu\nabla\mathbf u]^T
+\nabla(\lambda\nabla\cdot\mathbf u)
\}_2
+\mathbf f_b</script><p>引入假设$\kappa=\lambda+\frac 2 3 \mu=0$，上式可化为：</p>
<script type="math/tex; mode=display">
\frac \partial {\partial t}[\rho \mathbf u]
+\frac \partial {\partial x}[\rho \mathbf u \mathbf u] 
=
-\nabla p
+\{
\nabla\cdot[\mu\nabla\mathbf u]
\}_1
+\{
\nabla\cdot[\mu\nabla\mathbf u]^T
-\frac 2 3 \nabla(\mu\nabla\cdot\mathbf u)
\}_2
+\mathbf f_b</script><p>其中第1部分是可以用fvm::laplacian(mu,U)实现隐式处理，剩下的第2部分采用deferred correction approach的方法代入源项中处理。<br>在rhoCentralFoam的代码具体实现的时候也是分成两部分的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line:198</span></span><br><span class="line">        <span class="keyword">if</span> (!inviscid)</span><br><span class="line">        &#123;</span><br><span class="line">            solve</span><br><span class="line">            (</span><br><span class="line">                fvm::ddt(rho, U) - fvc::ddt(rho, U)</span><br><span class="line">              - fvm::laplacian(muEff, U)<span class="comment">//隐式处理</span></span><br><span class="line">              - fvc::div(tauMC)<span class="comment">//显式处理</span></span><br><span class="line">            );</span><br><span class="line">            rhoU = rho*U;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>一部分是隐式的fvm::laplacian(muEff, U)，另一部分是 显式的fvc::div(tauMC)，其计算如下。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volTensorField tauMC("tauMC", muEff*dev2(Foam::T(fvc::grad(U))));</span><br></pre></td></tr></table></figure></p>
<p>但是其中没有用到dev，而是用到了dev2，这俩是OpenFOAM中tensor类型的一种函数，其定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*src\OpenFOAM\primitives\Tensor\TensorI.H*/</span></span><br><span class="line"><span class="comment">// Line: 562</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//- Return the deviatoric part of a tensor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Cmpt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">Tensor</span>&lt;Cmpt&gt; <span class="title">dev</span>(<span class="title">const</span> <span class="title">Tensor</span>&lt;Cmpt&gt;&amp; <span class="title">t</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> t - SphericalTensor&lt;Cmpt&gt;::oneThirdI*tr(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- Return the deviatoric part of a tensor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Cmpt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">Tensor</span>&lt;Cmpt&gt; <span class="title">dev2</span>(<span class="title">const</span> <span class="title">Tensor</span>&lt;Cmpt&gt;&amp; <span class="title">t</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> t - SphericalTensor&lt;Cmpt&gt;::twoThirdsI*tr(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码翻译成公式是：</p>
<script type="math/tex; mode=display">
\tau_{MC} 
= \mu_{\text{eff}}\cdot \text{dev2}((\nabla\mathbf u)^T)
=\mu_{\text{eff}}\cdot 
\{
(\nabla\mathbf u)^T - \frac 2 3 tr((\nabla\mathbf u)^T) \mathbf I
\}\\
=\mu_{\text{eff}}\cdot 
\{
(\nabla\mathbf u)^T - \frac 2 3 (\nabla\cdot\mathbf u) \mathbf I
\}</script><p>所以可以看出，这个实现是和文章中的推导相符的，但是形式变化太大了。</p>
<h1 id="变量名对照"><a href="#变量名对照" class="headerlink" title="变量名对照"></a>变量名对照</h1><p>文章中的变量名和程序中很不一致。对照表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>code variable</th>
<th>line No.</th>
<th>dimension</th>
<th>paper symbol</th>
<th>equation No.</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>rPsi</td>
<td>80</td>
<td>$L^2/T^2$</td>
<td>$\frac{dp}{d\rho}=RT$</td>
<td>无</td>
<td>thermo模型中的变量psi的倒数</td>
</tr>
<tr>
<td>phiv_pos</td>
<td>93</td>
<td>$L^3/T$</td>
<td>$\phi<em>{f+}=\mathbf{u}</em>+\cdot \mathbf{S}_{f} $</td>
<td>7</td>
<td>正向体积流量</td>
</tr>
<tr>
<td>phiv_neg</td>
<td>94</td>
<td>$L^3/T$</td>
<td>$\phi<em>{f-}=\mathbf{u}</em>-\cdot \mathbf{S}_{f} $</td>
<td>7</td>
<td>反向体积流量</td>
</tr>
<tr>
<td>ap</td>
<td>108</td>
<td>$L^3/T$</td>
<td>$\psi_{f+}$</td>
<td>8</td>
<td>正向体积流量权重</td>
</tr>
<tr>
<td>am</td>
<td>113</td>
<td>$L^3/T$</td>
<td>$-\psi_{f-}$</td>
<td>8</td>
<td>负向体积流量权重的相反数</td>
</tr>
<tr>
<td>a_pos</td>
<td>119</td>
<td>$1$</td>
<td>$\alpha=\frac{\psi<em>{f+}}{\psi</em>{f+}+\psi_{f-}}$</td>
<td>9-KNP</td>
<td>KNP格式中的$\alpha$，在KT格式中为1/2</td>
</tr>
<tr>
<td>amaxSf</td>
<td>121</td>
<td>$L^3/T$</td>
<td>$\max(\psi<em>{f+},\psi</em>{f-})$</td>
<td>无</td>
<td>编程需要构造出来的一个变量</td>
</tr>
<tr>
<td>aSf</td>
<td>123</td>
<td>$L^3/T$</td>
<td>$\omega<em>f=-\alpha\psi</em>{f-}=-\frac{\psi<em>{f+}\psi</em>{f-}}{\psi<em>{f+}+\psi</em>{f-}}$</td>
<td>10-KNP</td>
<td>公式10-KNP展开，扩散体积通量，对于物质导数中的对流项是必须的，可与公式13对照；在KT格式中有所不同</td>
</tr>
<tr>
<td>a_neg</td>
<td>131</td>
<td>$1$</td>
<td>$1-\alpha$</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>phiv_pos</td>
<td>133</td>
<td>$L^3/T$</td>
<td>$\alpha\phi_{f+}$</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>phiv_neg</td>
<td>134</td>
<td>$L^3/T$</td>
<td>$(1-\alpha)\phi_{f-}$</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>aphiv_pos</td>
<td>136</td>
<td>$L^3/T$</td>
<td>$\alpha\phi_{f+}+\omega_f$</td>
<td>7-变形</td>
<td>原文公式7中$\mathbf{\Psi}_{f+}$的系数，但是原文$\omega_f$符号有错误</td>
</tr>
<tr>
<td>aphiv_neg</td>
<td>137</td>
<td>$L^3/T$</td>
<td>$(1-\alpha)\phi_{f-}-\omega_f$</td>
<td>7-变形</td>
<td>原文公式7中$\mathbf{\Psi}_{f-}$的系数，但是原文$\omega_f$符号有错误</td>
</tr>
<tr>
<td>amaxSf(第二次使用)</td>
<td>141</td>
<td>$L^3/T$</td>
<td>$\max(\mid\alpha\phi<em>{f+}+\omega_f\mid,\mid(1-\alpha)\phi</em>{f-}-\omega_f\mid)$</td>
<td>无</td>
<td>中心格式预测的幅值最大的数值单向通量</td>
</tr>
<tr>
<td>phi</td>
<td>159</td>
<td>$\frac M T$</td>
<td>$(\alpha\phi<em>{f+}+\omega_f)\rho</em>++ ((1-\alpha)\phi<em>{f-}-\omega_f)\rho</em>{-}$</td>
<td>无</td>
<td>界面数值重构的质量通量</td>
</tr>
<tr>
<td>phiUp</td>
<td>167</td>
<td>$\frac M {LT^2}$</td>
<td>$(\alpha\phi<em>{f+}+\omega_f)[\rho\mathbf u]</em>+ \+ ((1-\alpha)\phi<em>{f-}-\omega_f)[\rho\mathbf u]</em>- \+(\alpha p<em>++(1-\alpha)p</em>-)\mathbf S_f$</td>
<td>无</td>
<td>界面数值重构的动量通量</td>
</tr>
<tr>
<td>tauMC</td>
<td>176</td>
<td>$\frac{M}{LT^2}$</td>
<td>$\mu_{eff}[(\nabla\mathbf u)^T - \frac 2 3 (\nabla\cdot\mathbf u) \mathbf I]$</td>
<td>4</td>
<td>粘性应力的deferred correction显式部分</td>
</tr>
</tbody>
</table>
</div>
<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>程序和文献口心不一，把好好的NS方程改得面目全非。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>solver作者的原始文献<strong>Implementation of semi-discrete, non-staggered central schemes in a colocated, polyhedral, finite volume framework, for high-speed viscous flows</strong> DOI: 10.1002/fld.2069</li>
<li>《The finite volume method in computational fluid dynamics: an advanced introduction to OpenFOAM and Matlab》</li>
<li><strong>A note on Stokes’ hypothesis</strong> Acta Mech 226, 3555–3559 (2015)  DOI 10.1007/s00707-015-1380-9</li>
<li><a href="https://github.com/OpenFOAM/OpenFOAM-dev/tree/master/applications/solvers/compressible/rhoCentralFoam" target="_blank" rel="noopener">source code</a></li>
</ul>
<h3 id="注释的代码"><a href="#注释的代码" class="headerlink" title="注释的代码"></a>注释的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*rhoCentralFoam.C*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fvCFD.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"psiThermo.H"</span> <span class="comment">//热力学</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"turbulentFluidThermoModel.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fixedRhoFvPatchScalarField.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"directionInterpolate.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"localEulerDdtScheme.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fvcSmooth.H"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> NO_CONTROL</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"postProcess.H"</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"setRootCase.H"</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"createTime.H"</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"createMesh.H"</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"createFields.H"</span> <span class="comment">//pos,neg在此创建</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"createFieldRefs.H"</span> <span class="comment">//热力学场psi=drho/dp的创建</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"createTimeControls.H"</span></span></span><br><span class="line"></span><br><span class="line">    turbulence-&gt;validate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line">    <span class="comment">//读取fluxScheme,如果是Kurganov，则为KNP格式，如果是Tamdor，则是KT格式</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"readFluxScheme.H"</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function">dimensionedScalar <span class="title">v_zero</span><span class="params">(<span class="string">"v_zero"</span>, dimVolume/dimTime, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Courant numbers used to adjust the time-step</span></span><br><span class="line">    scalar CoNum = <span class="number">0.0</span>;</span><br><span class="line">    scalar meanCoNum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"\nStarting time loop\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (runTime.run())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// --- Directed interpolation of primitive fields onto faces</span></span><br><span class="line"></span><br><span class="line">        surfaceScalarField rho_pos(interpolate(rho, pos));</span><br><span class="line">        surfaceScalarField rho_neg(interpolate(rho, neg));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//U.name()表示采用U对应的插值方法</span></span><br><span class="line">        surfaceVectorField rhoU_pos(interpolate(rhoU, pos, U.name()));</span><br><span class="line">        surfaceVectorField rhoU_neg(interpolate(rhoU, neg, U.name()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//OpenFOAM喜欢采用rXxx表示xxx变量的倒数，不知道为什么。</span></span><br><span class="line">        <span class="comment">//psi=drho/dp (==1/(RT) for perfect gas)</span></span><br><span class="line">        <span class="comment">//rPsi = dp/drho (==RT for perfect gas)</span></span><br><span class="line">        <span class="function">volScalarField <span class="title">rPsi</span><span class="params">(<span class="string">"rPsi"</span>, <span class="number">1.0</span>/psi)</span></span>;</span><br><span class="line">        surfaceScalarField rPsi_pos(interpolate(rPsi, pos, T.name()));</span><br><span class="line">        surfaceScalarField rPsi_neg(interpolate(rPsi, neg, T.name()));</span><br><span class="line"></span><br><span class="line">        surfaceScalarField e_pos(interpolate(e, pos, T.name()));</span><br><span class="line">        surfaceScalarField e_neg(interpolate(e, neg, T.name()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不知为啥U_pos要这样计算而不是直接插值。</span></span><br><span class="line">        <span class="function">surfaceVectorField <span class="title">U_pos</span><span class="params">(<span class="string">"U_pos"</span>, rhoU_pos/rho_pos)</span></span>;</span><br><span class="line">        <span class="function">surfaceVectorField <span class="title">U_neg</span><span class="params">(<span class="string">"U_neg"</span>, rhoU_neg/rho_neg)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">p_pos</span><span class="params">(<span class="string">"p_pos"</span>, rho_pos*rPsi_pos)</span></span>;</span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">p_neg</span><span class="params">(<span class="string">"p_neg"</span>, rho_neg*rPsi_neg)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//phiv: volumetric flow across a face, [L^3/T]</span></span><br><span class="line">        surfaceScalarField phiv_pos("phiv_pos", U_pos &amp; mesh.Sf());// &amp;表示矢量点积</span><br><span class="line">        surfaceScalarField phiv_neg("phiv_neg", U_neg &amp; mesh.Sf());</span><br><span class="line"></span><br><span class="line">        volScalarField c("c", sqrt(thermo.Cp()/thermo.Cv()*rPsi));// 声速</span><br><span class="line">        surfaceScalarField cSf_pos</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"cSf_pos"</span>,</span><br><span class="line">            interpolate(c, pos, T.name())*mesh.magSf()</span><br><span class="line">        );</span><br><span class="line">        surfaceScalarField cSf_neg</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"cSf_neg"</span>,</span><br><span class="line">            interpolate(c, neg, T.name())*mesh.magSf()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//文献公式8</span></span><br><span class="line">        surfaceScalarField ap</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"ap"</span>,</span><br><span class="line">            max(max(phiv_pos + cSf_pos, phiv_neg + cSf_neg), v_zero)</span><br><span class="line">        );</span><br><span class="line">        surfaceScalarField am</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"am"</span>,</span><br><span class="line">            min(min(phiv_pos - cSf_pos, phiv_neg - cSf_neg), v_zero)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        surfaceScalarField a_pos("a_pos", ap/(ap - am));</span><br><span class="line"></span><br><span class="line">        surfaceScalarField amaxSf("amaxSf", max(mag(am), mag(ap)));</span><br><span class="line"></span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">aSf</span><span class="params">(<span class="string">"aSf"</span>, am*a_pos)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fluxScheme == <span class="string">"Tadmor"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            aSf = <span class="number">-0.5</span>*amaxSf;</span><br><span class="line">            a_pos = <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">a_neg</span><span class="params">(<span class="string">"a_neg"</span>, <span class="number">1.0</span> - a_pos)</span></span>;</span><br><span class="line"></span><br><span class="line">        phiv_pos *= a_pos;</span><br><span class="line">        phiv_neg *= a_neg;</span><br><span class="line"></span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">aphiv_pos</span><span class="params">(<span class="string">"aphiv_pos"</span>, phiv_pos - aSf)</span></span>;</span><br><span class="line">        <span class="function">surfaceScalarField <span class="title">aphiv_neg</span><span class="params">(<span class="string">"aphiv_neg"</span>, phiv_neg + aSf)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reuse amaxSf for the maximum positive and negative fluxes</span></span><br><span class="line">        <span class="comment">// estimated by the central scheme</span></span><br><span class="line">        amaxSf = max(mag(aphiv_pos), mag(aphiv_neg));</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"centralCourantNo.H"</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"readTimeControls.H"</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LTS) <span class="comment">//local time stepping</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"setRDeltaT.H"</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            #include <span class="string">"setDeltaT.H"</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上面是按原时刻计算的界面重构权重</span></span><br><span class="line">        runTime++;</span><br><span class="line">        <span class="comment">//下面计算出来的是新时刻的量</span></span><br><span class="line"></span><br><span class="line">        Info&lt;&lt; <span class="string">"Time = "</span> &lt;&lt; runTime.timeName() &lt;&lt; nl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 对流质量流量，含速度，用带扩散项的插值。</span></span><br><span class="line">        phi = aphiv_pos*rho_pos + aphiv_neg*rho_neg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对流动量流量部分用带扩散项的aphiv_pos插值</span></span><br><span class="line">        <span class="comment">// 压力部分用a_pos插值</span></span><br><span class="line">        surfaceVectorField phiUp</span><br><span class="line">        (</span><br><span class="line">            (aphiv_pos*rhoU_pos + aphiv_neg*rhoU_neg)</span><br><span class="line">          + (a_pos*p_pos + a_neg*p_neg)*mesh.Sf()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        surfaceScalarField phiEp</span><br><span class="line">        (</span><br><span class="line">            <span class="string">"phiEp"</span>,</span><br><span class="line">            aphiv_pos*(rho_pos*(e_pos + <span class="number">0.5</span>*magSqr(U_pos)) + p_pos)</span><br><span class="line">          + aphiv_neg*(rho_neg*(e_neg + <span class="number">0.5</span>*magSqr(U_neg)) + p_neg)</span><br><span class="line">          + aSf*p_pos - aSf*p_neg </span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        volScalarField muEff("muEff", turbulence-&gt;muEff());</span><br><span class="line">        volTensorField tauMC("tauMC", muEff*dev2(Foam::T(fvc::grad(U))));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- Solve density</span></span><br><span class="line">        <span class="comment">//fvc::div和数学divergence operator不完全一样，会除以体积，这样量纲才对。</span></span><br><span class="line">        solve(fvm::ddt(rho) + fvc::div(phi));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- Solve momentum</span></span><br><span class="line">        solve(fvm::ddt(rhoU) + fvc::div(phiUp));</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        U.ref() =</span><br><span class="line">            rhoU()</span><br><span class="line">           /rho();</span><br><span class="line">        U.correctBoundaryConditions();</span><br><span class="line">        rhoU.boundaryFieldRef() == rho.boundaryField()*U.boundaryField();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!inviscid)</span><br><span class="line">        &#123;</span><br><span class="line">            solve</span><br><span class="line">            (</span><br><span class="line">                fvm::ddt(rho, U) - fvc::ddt(rho, U)<span class="comment">//注意一个是fvm::ddt，一个是fvc::ddt</span></span><br><span class="line">              - fvm::laplacian(muEff, U) <span class="comment">//隐式的部分，如果要显式实现，参考源代码206行中sigmaDotU的计算</span></span><br><span class="line">              - fvc::div(tauMC) <span class="comment">//显式的部分</span></span><br><span class="line">            );</span><br><span class="line">            rhoU = rho*U;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- Solve energy</span></span><br><span class="line">        surfaceScalarField sigmaDotU<span class="comment">//粘性力做功项</span></span><br><span class="line">        (</span><br><span class="line">            <span class="string">"sigmaDotU"</span>,<span class="comment">//但是其实这部分不用分开成两部分计算也可以哈。</span></span><br><span class="line">            (</span><br><span class="line">                fvc::interpolate(muEff)*mesh.magSf()*fvc::snGrad(U)<span class="comment">//粘性应力中Laplacian部分的计算</span></span><br><span class="line">              + fvc::dotInterpolate(mesh.Sf(), tauMC)</span><br><span class="line">            )</span><br><span class="line">          &amp; (a_pos*U_pos + a_neg*U_neg) <span class="comment">//为啥速度又要这么插值了？</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        solve</span><br><span class="line">        (</span><br><span class="line">            fvm::ddt(rhoE)</span><br><span class="line">          + fvc::div(phiEp)</span><br><span class="line">          - fvc::div(sigmaDotU)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        e = rhoE/rho - <span class="number">0.5</span>*magSqr(U);</span><br><span class="line">        e.correctBoundaryConditions();</span><br><span class="line">        thermo.correct();</span><br><span class="line">        rhoE.boundaryFieldRef() ==</span><br><span class="line">            rho.boundaryField()*</span><br><span class="line">            (</span><br><span class="line">                e.boundaryField() + <span class="number">0.5</span>*magSqr(U.boundaryField())</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!inviscid)</span><br><span class="line">        &#123;</span><br><span class="line">            solve</span><br><span class="line">            (</span><br><span class="line">                fvm::ddt(rho, e) - fvc::ddt(rho, e)</span><br><span class="line">              - fvm::laplacian(turbulence-&gt;alphaEff(), e)</span><br><span class="line">            );</span><br><span class="line">            thermo.correct();</span><br><span class="line">            rhoE = rho*(e + <span class="number">0.5</span>*magSqr(U));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.ref() =</span><br><span class="line">            rho()</span><br><span class="line">           /psi();</span><br><span class="line">        p.correctBoundaryConditions();</span><br><span class="line">        rho.boundaryFieldRef() == psi.boundaryField()*p.boundaryField();</span><br><span class="line"></span><br><span class="line">        turbulence-&gt;correct();</span><br><span class="line"></span><br><span class="line">        runTime.write();</span><br><span class="line"></span><br><span class="line">        Info&lt;&lt; <span class="string">"ExecutionTime = "</span> &lt;&lt; runTime.elapsedCpuTime() &lt;&lt; <span class="string">" s"</span></span><br><span class="line">            &lt;&lt; <span class="string">"  ClockTime = "</span> &lt;&lt; runTime.elapsedClockTime() &lt;&lt; <span class="string">" s"</span></span><br><span class="line">            &lt;&lt; nl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; <span class="string">"End\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="从rhoCentralFoam中得到的启示"><a href="#从rhoCentralFoam中得到的启示" class="headerlink" title="从rhoCentralFoam中得到的启示"></a>从rhoCentralFoam中得到的启示</h1><p>OpenFOAM没有自带实现计算界面数值通量的方法（foam_extend中有一部分），所以往往需要通过一些interpolate操作将界面左右量计算出来，再自主实现一个计算数值通量的方法，最后再进行积分。</p>
<p>但让人觉得疑惑的是，目前OpenFOAM的时间递进方面只有单步方法，没有线性多步法，如RK之类的。</p>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
            <category> rhoCentralFoam </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> rhoCentralFoam </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenFOAM的不可压缩流算法]]></title>
      <url>/2018/01/05/OpenFOAM%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8E%8B%E7%BC%A9%E6%B5%81%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>对不可压缩流的几个经典算法及其在OpenFOAM中的实现进行了梳理。</p>
<p>主要针对OpenFOAM 5.x版本</p>
<a id="more"></a>
<h1 id="SIMPLE-PISO和PIMPLE算法"><a href="#SIMPLE-PISO和PIMPLE算法" class="headerlink" title="SIMPLE, PISO和PIMPLE算法"></a>SIMPLE, PISO和PIMPLE算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>均质-不可压缩-无体积力-常粘性</strong>的NS方程为：</p>
<script type="math/tex; mode=display">
{ {\partial \mathbf{u} } \over {\partial t} } + \mathbf{u} \cdot \nabla \mathbf{u} =
{-{1 \over \rho} \nabla p} + {\nu \nabla^2 \mathbf{u} }\\
\nabla\cdot \mathbf{u}=0</script><p>OpenFOAM和其他的CFD软件常用来解它的算法有：</p>
<ul>
<li>SIMPLE: Semi-Implicit Method of-Pressure Linked Equations，用于稳态计算</li>
<li>PISO:= Pressure Implicit Split Operator，用于瞬态计算，可以使用的Courant数往往小于1<sup><a href="#fn_1" id="reffn_1">1</a></sup></li>
<li>PIMPLE:= Merged PISO–SIMPLE，可以使用Courant数&gt;&gt;1</li>
</ul>
<p>但是找文献和教科书对的时候你会发现很多时候算法和OpenFOAM里的实现对不上。比如wiki和cfd-online上给的SIMPLE算法描述就是（<a href="https://en.wikipedia.org/wiki/SIMPLE_algorithm" target="_blank" rel="noopener">Wiki: SIMPLE Algorithm</a>）：</p>
<ol>
<li>修正边界条件；</li>
<li>计算速度和压力梯度；</li>
<li>求解离散动量方程（ discretized momentum equation），求得体心临时速度场；这一步是显式的</li>
<li>用体心临时速度场插值计算面心质量通量场；</li>
<li>计算压力修正方程（pressure correction equation），得到体心压力修正场；这一步是隐式的</li>
<li>对体心压力场进行亚松弛修正；</li>
<li>对压力场修正边界条件；</li>
<li>修正面心质量通量场；</li>
<li>修正体心速度场；</li>
<li>更新密度；</li>
</ol>
<p>但是明显OpenFOAM中的simpleFoam并没有求解过所谓的修正方程，而是自己玩了一个Picard迭代<sup><a href="#fn_9" id="reffn_9">9</a></sup>直接求的全量方程（你会发现OpenFOAM似乎从来就没求过修正量的Newton迭代，个人理解是因为OpenFOAM玩Newton迭代时边界条件不是很方便处理。）</p>
<p>于是我做了一点儿考古和分析。</p>
<h2 id="SIMPLE算法"><a href="#SIMPLE算法" class="headerlink" title="SIMPLE算法"></a>SIMPLE算法</h2><p>SIMPLE: Semi-Implicit Method of Pressure Linked Equations，这个方程的名字就满是问题，首先什么是半隐式方法（Semi-Implicit Method），什么又是压力联系方程（Pressure Linked Equations）？在原始文献<sup><a href="#fn_2" id="reffn_2">2</a></sup> 中是没有用SIMPLE这个名字的。搜索文献也很难找到压力联系方程的说法。我至今没有找到这个术语最开始的出处，查到最早的是他们自己1973年的文献<sup><a href="#fn_5" id="reffn_5">5</a></sup> 是叫SIMPLE了，但似乎大家都是以讹传讹地引用1972年的那篇文献。</p>
<p>根据一些参考文献<sup><a href="#fn_3" id="reffn_3">3</a></sup> 的分类法，SIMPLE, PISO都属于一类叫压力修正格式（Pressure Correction Schemes）的算法，其特征是构造一个压力场来满足不可压缩条件，再得到一个速度场，至于这个速度场能不能满足新得到的压力场，呵呵，要是能满足就不用再继续迭代了。由于求解的动量方程已经是线性化之后的了，所以你把这个速度对应的面心通量场再去线性化一次动量方程，如此往复才能最后得到稳态解。</p>
<h3 id="压力联系方程之到底是哪个方程"><a href="#压力联系方程之到底是哪个方程" class="headerlink" title="压力联系方程之到底是哪个方程"></a>压力联系方程之到底是哪个方程</h3><p>查来查去，发现不可压缩CFD解的主要是以下方程：</p>
<ul>
<li>压力修正方程（Pressure Correction Equation, PCE）<sup><a href="#fn_4" id="reffn_4">4</a></sup> : 两次迭代间压力需要的修正量的方程</li>
</ul>
<ol>
<li><script type="math/tex; mode=display">
\nabla^2 (p^{n+1}-p^n) =\frac 1 {\Delta t}\nabla\cdot U^*</script></li>
</ol>
<ul>
<li><p>压力泊松方程（Pressure Poisson Equation, PPE）<sup><a href="#fn_ 6" id="reffn_ 6"> 6</a></sup>: 动量方程求散度，消去速度散度项</p>
<p>稳定化的一阶欧拉时间离散时的形式。</p>
</li>
</ul>
<script type="math/tex; mode=display">
\nabla^2 p^{n+1} = \rho { {\nabla \cdot \mathbf{u}^n} \over {\Delta t} }-
\rho \nabla \cdot (\mathbf{u}^n \cdot \nabla \mathbf{u}^n)+
\mu \nabla^2 (\nabla \cdot \mathbf{u}^n)</script><p>​    速度场保持无散时的形式。</p>
<script type="math/tex; mode=display">
-\frac 1 \rho \nabla^2 p =  \nabla \cdot (\mathbf{u} \cdot \nabla \mathbf{u})</script><ul>
<li>压力联系方程（Pressure Linked Equation, PLE）：原始文献并没有说什么是PLE，参考另一篇文献<sup><a href="#fn_7" id="reffn_7">7</a></sup>的说法，压力联系方程的形式如下（符号定义参考文献）：</li>
</ul>
<script type="math/tex; mode=display">
\frac{\partial}{\partial x}\left( \gamma\frac{\partial p}{\partial x} \right) 
+\frac{\partial}{\partial y}\left( \gamma\frac{\partial p}{\partial y} \right) 
= \hat \epsilon
\\
\hat\epsilon = (\hat u_e- \hat u_w)/\Delta x +(\hat v_n - \hat v_s)/\Delta y</script><p>可见，所谓PLE非常诡异，它不是个微分方程，而是一个代数方程。对应到OpenFOAM里的simpleFoam则是<sup><a href="#fn_8" id="reffn_8">8</a></sup>：</p>
<script type="math/tex; mode=display">
\begin{equation}
\nabla \cdot (\mathbf{HbyA}^{n+1}) = \nabla \cdot(\frac{1}{A_{\mathrm{P},f} } \nabla p^{n+1})
\label{poss}
\end{equation}</script><p>同时，对比PLE和PPE，可以发现，二者都是把某种形式的动量方程带入了质量守恒方程得到的，但不同之处在于</p>
<ol>
<li>PLE是把<strong>线性化</strong>的<strong>离散</strong>动量方程中得到速度表达式带入了质量守恒方程，得到$\nabla\cdot(\frac 1 a \nabla p) = \dots $。<ol>
<li>大概是这么个过程：</li>
<li>线性化离散动量方程记为 $M\cdot u =  \nabla p $， $M$是一个矩阵。</li>
<li>先LDU加法分解： $M\cdot u = (D+L+U) \cdot u = \nabla p$</li>
<li>然后进行Jacobi迭代：$ D \cdot u = \nabla p - (L+U) \cdot u^0$</li>
<li>左边： $D$记为$A$ （实际上是对角系数除以单元体积，以保持量纲一致性）， 因为是对角阵，所以可以把$D^{-1}=A^{-1}$记为 $\frac 1 A$ ，OpenFOAM里实现为一个几何场而不是矩阵<code>fvMatrix</code>；</li>
<li>右边：$(L+U)\cdot u^0$记为 $H$ </li>
<li>这样$u = \frac 1 A \nabla p - \frac H A$ </li>
<li>然后再利用$\nabla \cdot u = 0 $</li>
<li>得到$\nabla\cdot(\frac 1 A \nabla p ) = \nabla \cdot \frac H A$ ，这就是PLE，也是实际OpenFOAM中求解的方程。</li>
<li>英语里$\frac H A$ 可以读作”H by A”</li>
<li>OpenFOAM里的$\frac 1 A$ 对应变量为<code>rUA</code> </li>
</ol>
</li>
<li>PPE是把动量方程直接求散度得到的，所以是$\nabla\cdot\nabla p=\dots$。</li>
</ol>
<h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ul>
<li>问：为啥要费劲心力去算$\mathbf{HbyA}$，再算PLE，直接离散PPE或者质量守恒方程不行么？</li>
<li><p>答：我也不知道</p>
<ul>
<li>但是玩FEM的家伙们就是这么干的（当然实际上他们也有很多流派，但是他们更多的是玩函数空间，LBB条件而不是玩方程系数，玩系数太low）</li>
<li>似乎只有玩FVM的人才玩PLE。</li>
<li><p>而且投影法<sup><a href="#fn_10" id="reffn_10">10</a></sup>那个流派的FVM也是玩的PPE，参考<a href="https://en.wikipedia.org/wiki/Projection_method_(fluid_dynamics" target="_blank" rel="noopener">Chorin’s_projection_method</a>#Chorin’s_projection_method)。</p>
</li>
<li><p>而且为了玩PLE，作为使用OpenFOAM的同位网格玩家，还必须引入Rhie-Chow插值这种大坑，虽然OpenFOAM似乎轻巧地避开了这个坑。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Semi-Implicit-Method半隐式方法"><a href="#Semi-Implicit-Method半隐式方法" class="headerlink" title="Semi-Implicit-Method半隐式方法"></a>Semi-Implicit-Method半隐式方法</h3><p>我认为之所以叫半隐式方法，是因为：</p>
<ul>
<li>求解过程中，求速度预测步的方程对于速度是隐式的，但对于压力是固定的显式离散，所以称之为半隐式。</li>
<li>求解压力方程时，压力是隐式离散的，但是此时的速度是固定不变的。</li>
<li>所以本质上这个半隐式等价于解耦算法。</li>
<li>文献<sup><a href="#fn_5" id="reffn_5">5</a></sup> 摘要中提到，SIMPLE的半隐式是和SIVA（SImultaneous Variable Adjustment）全隐算法相对的提法，其特点是每次迭代要同时更新周围的速度和压力。</li>
</ul>
<p>SIMPLE算法因此具有一些特性：</p>
<ul>
<li>解耦计算，内存占用小。</li>
</ul>
<ul>
<li>用于稳态计算，所以<code>timeStep</code>无意义，但通常设置<code>timeStep=1</code>，这样解算输出时间等于时间步数；</li>
<li>由于没有时间项来稳定化计算，需要加入松弛因子（在矩阵上加在和时间项几乎相同的位置），但是这个松弛因子在实现时搞不好会对最终稳态解产生影响。</li>
</ul>
<h3 id="关于consistent"><a href="#关于consistent" class="headerlink" title="关于consistent"></a>关于<code>consistent</code></h3><p>对于SIMPLE-C算法<sup><a href="#fn_16" id="reffn_16">16</a></sup>而言，比SIMPLE算法只多了一个步骤：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//applications/solvers/incompressible/pimpleFoam/pEqn.H +16</span></span><br><span class="line"><span class="keyword">if</span> (pimple.consistent())</span><br><span class="line">&#123;</span><br><span class="line">    rAtU = <span class="number">1.0</span>/max(<span class="number">1.0</span>/rAU - UEqn.H1(), <span class="number">0.1</span>/rAU); <span class="comment">//有max!</span></span><br><span class="line">    phiHbyA +=</span><br><span class="line">        fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf();</span><br><span class="line">    HbyA -= (rAU - rAtU())*fvc::grad(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/simpleFoam/pEqn.H +10</span></span><br><span class="line"><span class="keyword">if</span> (simple.consistent())</span><br><span class="line">&#123;</span><br><span class="line">  rAtU = <span class="number">1.0</span>/(<span class="number">1.0</span>/rAU - UEqn.H1()); <span class="comment">//没有max!</span></span><br><span class="line">  phiHbyA +=</span><br><span class="line">    fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf();</span><br><span class="line">  HbyA -= (rAU - rAtU())*fvc::grad(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，pimpleFoam和simpleFoam的<code>consistent</code>选项对<code>rAtU</code>的计算公式是有区别的！</p>
<p>其中修改了的变量有：</p>
<ul>
<li><p><code>rAtU</code></p>
<ul>
<li><code>1.0/rAU - UEqn.H1()</code>的实际含义应该是$[1/(\frac{1}{D})-(-(L+U)\cdot \mathbf{1})] = (L+D+U)\cdot \mathbf{1}$，也就是矩阵系数的行和，中间最多差一个网格体积的因子。</li>
<li><code>0.1/rAU</code>的含义应该是$\frac{1}{10} D$</li>
<li>由于系数矩阵元素的大小往往是对角项为负，非对角项为正，其行和为略小的负数（对于laplace方程，某些行和可能为0，但是对于动量方程，应该不为零）。所以为了避免除以0，<code>pimpleFoam</code>采用了<code>max</code>函数的技巧。</li>
<li>而对于<code>simpleFoam</code>，只取了第一项的倒数。</li>
</ul>
</li>
<li><p><code>phiHbyA</code></p>
<ul>
<li><p>按照<code>rAtU-rAU</code>的差值，和<code>grad(p)</code>对界面流量进行更新</p>
</li>
<li><p>把这项代入到pEqn的表达式中，可以发现和原来是一样的</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来的方程，如pisoFoam, icoFoam就采用了这个方程</span></span><br><span class="line">fvScalarMatrix pEqn</span><br><span class="line">(</span><br><span class="line">	fvm::laplacian(rAU, p) == fvc::div(phiHbyA)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//simpleFoam, pimpleFoam采用的方程，将phiHbyA改记为phiHbyA2</span></span><br><span class="line">fvScalarMatrix pEqn</span><br><span class="line">(</span><br><span class="line">	fvm::laplacian(rAtU(), p) == fvc::div(phiHbyA2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两者相减</span></span><br><span class="line">fvScalarMatrix pEqn</span><br><span class="line">(</span><br><span class="line">	fvm::laplacian(rAtU()-rAU, p) </span><br><span class="line">  == fvc::div(fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf())</span><br><span class="line">);</span><br><span class="line"><span class="comment">//可见二者是一致的。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>HbyA</code></p>
<ul>
<li>同上，按照<code>rAtU-rAU</code>的差值，对临时体心速度进行更新。</li>
<li>便于后面用<code>U = HbyA - rAtU()*fvc::grad(p);</code>去更新真正的体心速度！</li>
</ul>
</li>
<li><p>至此，正确性没有问题，但是为啥<code>rAtU</code>要这么改？！。 </p>
<ul>
<li><p>对于pimpleFoam中的<code>rAtU</code>，<code>max()</code>函数在分母，应该是取了较为稳定的一组系数，并避免了除以0。</p>
</li>
<li><p>对于simpleFoam而言，<code>rAU</code>是矩阵系数中的对角部分，而<code>rAtU</code>则是取了矩阵每一行系数的和。</p>
<ul>
<li><p>参考原始文献<sup><a href="#fn_16" id="reffn_16">16</a></sup> ，作者就是这么干的！</p>
</li>
<li><p>本质上你可以任意的分解：</p>
</li>
<li><script type="math/tex; mode=display">
M=L+D+U \\

M\cdot u = (L+D+U)\cdot u = (D_s+(M-D_s) )\cdot u = - \nabla p  \\</script></li>
<li><p>所以对于<code>consistent=false</code>的情形：</p>
</li>
<li><script type="math/tex; mode=display">
A=\frac 1 D \\
H=-(L+U)\cdot u^0</script></li>
<li><p>对于consistent=true的情形：</p>
</li>
<li><script type="math/tex; mode=display">
H_1 =- (L+U)\cdot \mathbf{1} \\
A'=D-H_1 = M\cdot \mathbf{1}</script></li>
<li><p>根据wiki上的说明，如果压力-速度耦合是解收敛的主要问题，SIMPLE-C算法可以加速收敛，SIMPLE-C比SIMPLE要快大概是120%-130%左右。</p>
</li>
<li><p>如果压力-速度耦合不是收敛的主要障碍，SIMPLE-C效率与SIMPLE差不多。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="关于H1和H的区别"><a href="#关于H1和H的区别" class="headerlink" title="关于H1和H的区别"></a>关于H1和H的区别</h4><ul>
<li>意义不一样：假设$M=(L+D+U)$，初值为$x^0$<ul>
<li>则$H_1 = H(x^0=\mathbf1)$</li>
<li>$H(x^0)=-(L+D)\cdot x^0$</li>
<li>$\mathbf 1$表示全是1的向量。</li>
</ul>
</li>
<li>都是定义在lduMatrix中的，但是<code>H1</code>是不带参数的，而<code>H</code>是带参数的。</li>
<li>实现的地方也不一样，一个在<code>lduMatrixATmul.C</code>，另一个在<code>lduMatrixTemplates.C</code>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//H1()</span></span><br><span class="line"><span class="comment">//src/OpenFOAM/matrices/lduMatrix/lduMatrix/lduMatrixATmul.C +298</span></span><br><span class="line">Foam::tmp&lt;Foam::scalarField &gt; Foam::lduMatrix::H1() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;scalarField &gt; tH1</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> scalarField(lduAddr().size(), <span class="number">0.0</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lowerPtr_ || upperPtr_)</span><br><span class="line">    &#123;</span><br><span class="line">        scalarField&amp; H1_ = tH1.ref();</span><br><span class="line"></span><br><span class="line">        scalar* __restrict__ H1Ptr = H1_.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ uPtr = lduAddr().upperAddr().begin();</span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ lPtr = lduAddr().lowerAddr().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ lowerPtr = lower().begin();</span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ upperPtr = upper().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label nFaces = upper().size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (label face=<span class="number">0</span>; face&lt;nFaces; face++)</span><br><span class="line">        &#123;</span><br><span class="line">            H1Ptr[uPtr[face]] -= lowerPtr[face];</span><br><span class="line">            H1Ptr[lPtr[face]] -= upperPtr[face];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tH1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//H(psi)</span></span><br><span class="line"><span class="comment">//src/OpenFOAM/matrices/lduMatrix/lduMatrix/lduMatrixTemplates.C +34</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:tmp&lt;Foam::Field&lt;Type&gt;&gt; Foam::lduMatrix::H(<span class="keyword">const</span> Field&lt;Type&gt;&amp; psi) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;Field&lt;Type&gt;&gt; tHpsi</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> Field&lt;Type&gt;(lduAddr().size(), Zero)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lowerPtr_ || upperPtr_)</span><br><span class="line">    &#123;</span><br><span class="line">        Field&lt;Type&gt; &amp; Hpsi = tHpsi.ref();</span><br><span class="line"></span><br><span class="line">        Type* __restrict__ HpsiPtr = Hpsi.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Type* __restrict__ psiPtr = psi.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ uPtr = lduAddr().upperAddr().begin();</span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ lPtr = lduAddr().lowerAddr().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ lowerPtr = lower().begin();</span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ upperPtr = upper().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label nFaces = upper().size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (label face=<span class="number">0</span>; face&lt;nFaces; face++)</span><br><span class="line">        &#123;</span><br><span class="line">            HpsiPtr[uPtr[face]] -= lowerPtr[face]*psiPtr[lPtr[face]];</span><br><span class="line">            HpsiPtr[lPtr[face]] -= upperPtr[face]*psiPtr[uPtr[face]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tHpsi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:tmp&lt;Foam::Field&lt;Type&gt;&gt;</span><br><span class="line">Foam::lduMatrix::H(<span class="keyword">const</span> tmp&lt;Field&lt;Type&gt;&gt;&amp; tpsi) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;Field&lt;Type&gt;&gt; tHpsi(H(tpsi()));</span><br><span class="line">    tpsi.clear();</span><br><span class="line">    <span class="keyword">return</span> tHpsi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>wiki和cfd-online上的SIMPLE算法是和simpleFoam不一致的。正确的描述可以参考openfoamwiki上的描述：<a href="http://openfoamwiki.net/index.php/OpenFOAM_guide/The_SIMPLE_algorithm_in_OpenFOAM#The_SIMPLE_algorithm" target="_blank" rel="noopener">the SIMPLE Algorithm</a></p>
<p>simple算法在OpenFOAM中的实现也是和版本相关的，比如foam-extend 4.0的simpleFoam里Jasak就采用了一种新的算法来避免时间步和松弛因子对解的影响。OpenFOAM.org和OpenFOAM.com的似乎还没变化。</p>
<p>此外，SIMPLE算法还有一些衍生算法：</p>
<ul>
<li>SIMPLEC: SIMPLE-Consistent</li>
<li>SIMPLER: SIMPLE-Revised</li>
</ul>
<h2 id="Rhie-Chow插值"><a href="#Rhie-Chow插值" class="headerlink" title="Rhie-Chow插值"></a>Rhie-Chow插值</h2><p>Rhie-Chow插值，有人又叫压力加权插值方法(pressure-weighted interpolation method, PWIM)，但是其实这个插值并不是用压力来加权的。</p>
<p>刚开始我以为这个插值的作用是来插值计算面心压力的，后来发现其实它是用来计算面心速度的插值方法。</p>
<p>本质上它等效于引入了4阶耗散项进入压力修正方程中，有利于计算的稳定化：</p>
<p>按照Rhie-Chow插值，均匀一维网格的面心速度表达式会含有P的三次导数成分。</p>
<script type="math/tex; mode=display">
U_e = \frac 1 2 (U_E+U_P)+\frac{\delta V}{4a_P\Delta x}[P_{EE}-3P_E+3P_P-P_W]</script><p>带入连续性方程之后，就会含有四次导数成分，成为稳定化压力方程的高阶耗散项，从而可以平抑压力波动：</p>
<script type="math/tex; mode=display">
\int_e^w{\frac {dU }{dx} dx} =U_e - U_w =  \frac 1 2 (U_E - U_W)+\frac{\delta V}{4a_P\Delta x}[P_EE-4P_E+6P_{P}-4P_W+P_{WW}]</script><p>详细的说明可以看参考文献<sup><a href="#fn_13" id="reffn_13">13</a></sup></p>
<p>而且玩高阶导数的人都应该知道，压力梯度都特别大的时候，高阶项会更大，所以有时候Rhie-Chow插值也会出问题。</p>
<h3 id="面心速度的作用"><a href="#面心速度的作用" class="headerlink" title="面心速度的作用"></a>面心速度的作用</h3><p>（注：面心速度（$\mathbf{u}_f$）和界面通量（程序里常用<code>phi</code>表示 ）仅相差一个面积，所以实际上差不多是同一回事儿。）</p>
<p>根据文献<sup><a href="#fn_11" id="reffn_11">11</a></sup> ，面心速度有三个作用：</p>
<ol>
<li>格式系数作用：构成关于体心速度的矩阵方程<code>UEqn</code>时，界面通量是系数的重要组成部分，系数不同，方程就不同，解就不同；</li>
<li>耦合作用：耦合速度和压力，在simple算法构造关于体心压力的矩阵方程时，需要用到界面通量；</li>
<li>质量守恒作用：界面通量应满足质量守恒。</li>
</ol>
<p>按照我的理解，在OpenFOAM中，这些作用在程序中分别由不同的变量承担了，并不是同一个面心速度了。</p>
<ol>
<li>格式系数作用：由于采用的是Picard迭代，所以OpenFOAM组成速度方程<code>UEqn</code>的矩阵系数是采用直接按<code>fvScheme</code>指定格式插值得到的界面通量<code>phi</code>在<code>fvm::div(phi,U)</code>生成的（准确地说在simpleFoam中第一次迭代用的插值phi，后面用的<code>pEqn.flux()</code>和<code>phiHbyA</code>构造的<code>phi</code>）。在<code>simpleFoam</code>中如以下代码所示。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UEqn.H</span></span><br><span class="line">tmp&lt;fvVectorMatrix&gt; tUEqn</span><br><span class="line">    (</span><br><span class="line">        fvm::div(phi, U) <span class="comment">//这里用的界面通量是phi</span></span><br><span class="line">      + MRF.DDt(U)</span><br><span class="line">      + turbulence-&gt;divDevReff(U)</span><br><span class="line">     ==</span><br><span class="line">        fvOptions(U)</span><br><span class="line">    );</span><br><span class="line">    fvVectorMatrix&amp; UEqn = tUEqn.ref();</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/cfdTools/incompressible/createPhi.H</span></span><br><span class="line">surfaceScalarField phi</span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"phi"</span>,</span><br><span class="line">        runTime.timeName(),</span><br><span class="line">        mesh,</span><br><span class="line">        IOobject::READ_IF_PRESENT,</span><br><span class="line">        IOobject::AUTO_WRITE</span><br><span class="line">    ),</span><br><span class="line">    fvc::flux(U) <span class="comment">//调用的是fvc::flux()</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/fvc/fvcFlux.C</span></span><br><span class="line"> Foam::tmp&lt;Foam::surfaceScalarField&gt; Foam::fvc::flux</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; vvf</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> scheme&lt;<span class="built_in">vector</span>&gt; <span class="comment">// scheme&lt;vector&gt;(mesh,name) 返回 tmp&lt;surfaceInterpolationScheme&gt;对象</span></span><br><span class="line">    (</span><br><span class="line">        vvf.mesh(),</span><br><span class="line">        <span class="string">"flux("</span> + vvf.name() + <span class="string">')'</span></span><br><span class="line">    )().dotInterpolate(vvf.mesh().Sf(), vvf); <span class="comment">//插值并点乘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pEqn.H</span></span><br><span class="line">    <span class="keyword">while</span> (simple.correctNonOrthogonal()) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (simple.finalNonOrthogonalIter())</span><br><span class="line">        &#123;</span><br><span class="line">            phi = phiHbyA - pEqn.flux(); <span class="comment">//更新phi</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>而耦合作用反映在<code>phiHbyA</code>这个界面通量中，它最终构成了<code>pEqn</code>中的源项部分，在OpenFOAM的simpleFoam求解器中，<code>phiHbyA</code>是用<code>fvc::flux(HbyA)</code> 构造的。<ol>
<li>但是值得注意的是，simpleFoam只构造出了不含压力梯度贡献的临时速度$u^*$ = <code>HbyA</code>，并且没有直接使用它，而是用它构造了<code>phiHbyA</code>。</li>
<li>simpleFoam没有在<code>pEqn</code>求解之前构造含有压力梯度贡献的<code>U</code>，这是在求解完压力方程后，用<code>U = HbyA - rAtU()*fvc::grad(p)</code> 构造的。</li>
<li>所以dyfluid上说<code>在OpenFOAM中，并没有直接采用Rhie-Chow插值的原始步骤。相反的，其通过对拉普拉斯项的离散巧妙的获得一种近似Rhie-Chow插值的原理。</code></li>
<li>因为原始步骤是通过$\nabla\cdot U=0$构造<code>pEqn</code>，而实际上因为<code>pEqn</code>是通过<code>phiHbyA</code> 和<code>rUA</code>构造的，所以跳过了原始的Rhie-Chow插值。</li>
<li>而因为<code>fvm::laplacian(rUA,p)</code>的实现已经是利用了周围相邻单元的压力，并没有原始构造方式中压力的奇偶失耦（odd-even decoupling）情况，所以认为是实现了Rhie-Chow插值的效果。</li>
<li>按照参考文献<sup><a href="#fn_18" id="reffn_18">18</a></sup> 的搞法（Listing 15.18），Rhie-Chow插值似乎是用于产生<code>phiHbyA</code>的，但是由于那本书严格地遵守了解PCE的思路，所以还不能完全相互比较。</li>
</ol>
</li>
<li>质量守恒作用其实是靠<code>pEqn</code>实现的PLE完成的，simpleFoam除了在<code>continuityErrs.H</code>之外不直接检查质量守恒，检查时也是用的<code>fvc::div(phi)</code>而不是速度<code>U</code>。 </li>
</ol>
<h2 id="PISO算法"><a href="#PISO算法" class="headerlink" title="PISO算法"></a>PISO算法</h2><p>PISO = Pressure Implicit Split Operator。同样的问题，什么是压力隐式(pressure implicit)，什么是算子分裂(split operator)。就icoFoam来看，我的理解是：</p>
<ul>
<li><p>压力隐式(pressure implicit)：求解的压力方程是隐式的（废话）；</p>
</li>
<li><p>算子分裂(split operator)：把$\frac {dx}{dt}|_t^{t+\Delta t}=O(x) = (O_1+O_2)(x)  $ 近似成$ \frac{dx}{dt}|_t^{t+\Delta t} = O_1(x’), \frac{dx’}{dt}|_t^{t+\Delta t}=O_2(x)$来求解</p>
<ul>
<li><p>原始文献<sup><a href="#fn_15" id="reffn_15">15</a></sup>中其实也就是解耦速度和压力的意思：</p>
</li>
<li><blockquote>
<p>The principle is here extended to apply to the coupling between variables, namely, the pressure and velocity, whereby operations involving different variables are split into a series of predictor-corrector steps.</p>
</blockquote>
</li>
<li><p>算子分裂的一个问题在于，它有时候<strong>不能保证到达稳态解的正确性</strong>！详见参考文献<sup><a href="#fn_14" id="reffn_14">14</a></sup> 。</p>
</li>
</ul>
</li>
</ul>
<p>算法的具体描述请参考<a href="http://openfoamwiki.net/index.php/OpenFOAM_guide/The_PISO_algorithm_in_OpenFOAM" target="_blank" rel="noopener">OpenFOAMwiki的PISO Algorithm</a> （这里的描述所用的版本有点老，和最新版OpenFOAM中使用的变量名有所不同）：</p>
<ol>
<li>Set the boundary conditions 施加边界条件.</li>
<li>Solve the discretized momentum equation to compute an intermediate velocity field. 解离散动量方程得到中间阶段的速度场$U^*$<ol>
<li>但是其实这一步可以设置<code>momentumPredictor=false</code>来跳过去。</li>
<li>因为最重要的其实是压力方程，这个速度场方程UEqn主要用来提取$A$和$H$，以构造后面压力方程要用的<code>phi</code></li>
<li>因为有非定常项，所以这里是没有松弛的！有松弛就不对了。</li>
</ol>
</li>
<li>Compute the mass fluxes at the cells faces，构造<code>phiHbyA</code>.<ol>
<li>与simple不同，这里的<code>phiHbyA</code>加入了<code>fvc::ddtCorr</code>项</li>
<li><code>fvc::ddtCorr</code>项的定义参考<a href="https://zh.scribd.com/doc/48195039/ddtPhiCorr" target="_blank" rel="noopener">这里</a>。</li>
</ol>
</li>
<li>Solve the pressure equation.解压力方程，其实应该是解的PLE</li>
<li>Correct the mass fluxes at the cell faces.更新<code>phi</code></li>
<li>Correct the velocities on the basis of the new pressure field. 更新<code>U</code></li>
<li>Update the boundary conditions.更新<code>U</code>的边界条件</li>
<li>Repeat from 3 for the prescribed number of times. 重复piso循环，<ol>
<li>这个是由<code>piso.correct()</code>控制的，而<code>piso.correct()</code>是由变量<code>label corrPISO_</code>控制的。</li>
<li>重复的时候，UEqn所引用的<code>U</code>是有更新的。所以用UEqn构造的<code>UEqn.A(), UEqn.H()</code>也可能会有所更新。</li>
</ol>
</li>
<li>Increase the time step and repeat from 1. 下一个时间步，这里是由<code>runTime.loop()</code>控制的。</li>
</ol>
<p>OpenFOAM中的PISO求解器其实有两个，最简单的是icoFoam，用的是PISO算法解层流。复杂一点的是pisoFoam，带有湍流模型。</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h4 id="solutionControl及其子类的继承关系"><a href="#solutionControl及其子类的继承关系" class="headerlink" title="solutionControl及其子类的继承关系"></a>solutionControl及其子类的继承关系</h4><ul>
<li>pisoControl是pimpleControl的子类！</li>
<li>pimpleContrl是solutionControl的子类</li>
<li>simpleControl是solutionControl的子类。</li>
</ul>
<h4 id="松弛"><a href="#松弛" class="headerlink" title="松弛"></a>松弛</h4><p>从代码中可以发现，pisoFoam和icoFoam对于压力和动量方程是没有进行松弛的。这是因为它要进行的是<strong>时间精确</strong>的模拟。</p>
<p>但是如果你用的ddt格式本来就不是时间精确的话，额，还是不要用PISO了，改用PIMPLE吧。加点松弛因子可能还稳定些。</p>
<h2 id="PIMPLE算法"><a href="#PIMPLE算法" class="headerlink" title="PIMPLE算法"></a>PIMPLE算法</h2><p>PIMPLE算法是SIMPLE和PISO的结合。因为PISO只有一个预测步，所以PISO的稳定性限制了它只能用于瞬态计算并且时间步不能取得太大，而SIMPLE没有时间项只能用于稳态计算（或者采用伪时间步方法用于瞬态计算）。PIMPLE算法的核心是把UEqn<strong>重新生成</strong>并解了很多次！</p>
<ul>
<li>pimpleFoam中的<code>#include &quot;UEqn.H&quot;</code> 语句是被包在<code>pimple.loop()</code>循环内的。</li>
<li>pisoFoam中的<code>#include &quot;UEqn.H&quot;</code>语句没有被包裹，每次<code>runTime.loop()</code>只运行一次。</li>
<li>pisoFoam中没有使用<code>consistent</code>关键字，所以没有SIMPLE-C修正。</li>
<li>pimpleFoam中使用了<code>consistent</code>关键字，所以和simpleFoam一样，对phiHbyA进行了SIMPLE-C处理。</li>
<li>simpleFoam中使用的<code>simple.loop()</code>而不是<code>runTime.loop()</code>，但是它调用了<code>runTime.loop()</code></li>
</ul>
<h3 id="PIMPLE里的三层循环"><a href="#PIMPLE里的三层循环" class="headerlink" title="PIMPLE里的三层循环"></a>PIMPLE里的三层循环</h3><p>总结起来，PIMPLE算法每个时间步（由<code>runTime.loop()</code>控制）有三层循环：</p>
<ul>
<li>外层<code>pimple.loop()</code>类似SIMPLE循环<ul>
<li>利用当前的<code>U</code>，生成并求解<code>UEqn</code></li>
<li>中层<code>pimple.correct()</code>，几乎就是PISO循环，负责压力求解<ul>
<li>利用<code>UEqn</code> 构造<code>rAU</code>, <code>HbyA</code></li>
<li><code>HbyA</code> 生成<code>phiHbyA</code>，加入<code>fvc::ddtCorr(U,phi)</code>修正。</li>
<li><code>adjustPhi()</code></li>
<li>利用<code>consistent</code>关键字对<code>phiHbyA</code>进行SIMPLE-C一致性修正</li>
<li><code>constrainPressure()</code></li>
<li>内层<code>pimple.correctNonOrthogonal()</code>非正交修正循环<ul>
<li>构造压力联系方程<code>pEqn</code></li>
<li><code>pEqn.setReference()</code></li>
<li>用新的<code>p</code>作为初始值求解<code>pEqn</code>，进行非正交修正。</li>
</ul>
</li>
<li>更新<code>U</code>和<code>phi</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>而SIMPLE算法没有中层循环，PISO算法没有外层循环。所以PIMPLE算法可以简化为PISO算法，但是由于SIMPLE算法中没有包含非定常项，所以PIMPLE算法要等同于SIMPLE算法需要使<code>ddt</code>项的格式需要指定为<code>steadyState</code>。</p>
<h2 id="一些编程细节"><a href="#一些编程细节" class="headerlink" title="一些编程细节"></a>一些编程细节</h2><p>此外在程序代码中还有好多稀奇古怪的乱七八糟玩意儿。</p>
<h3 id="solutionControl及其子类的变量命名规范"><a href="#solutionControl及其子类的变量命名规范" class="headerlink" title="solutionControl及其子类的变量命名规范"></a><code>solutionControl</code>及其子类的变量命名规范</h3><p>OpenFOAM里的求解控制类是<code>solutionControl</code> 及其子类<code>simpleControl</code>, <code>pisoControl</code>和<code>pimpleControl</code>。其中定义了很多变量，其命名规范是：</p>
<ul>
<li><code>label xxx_</code>表示迭代变量，比如<code>corr_,</code> <code>corrNonOrtho_</code>,pimpleControl中的 <code>corrPISO_</code>等。</li>
<li><code>label nXxx_</code>表示<strong>迭代上限次数</strong>，比如<code>nCorrNonOrtho_</code>（实际迭代次数是<code>nCorrNonOrtho_+1</code>，因为第一次求解不算所谓修正），pimpleControl中的<code>nCorrPIMPLE_</code>, <code>nCorrPISO_</code></li>
<li><code>bool yyy_</code>表示标志量，比如<code>transonic_</code>, <code>consistent_</code>, <code>momentumPredictor_</code></li>
<li><code>residualControl_</code> 残差控制。</li>
</ul>
<ul>
<li>以pimpleControl为例，其迭代循环变量和控制变量标志如下表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>含义</th>
<th>迭代量的变量名</th>
<th>迭代上限的变量名</th>
<th>配置文件中的关键字</th>
<th>默认值</th>
<th>判断是否执行的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>外部迭代，又叫PIMPLE迭代</td>
<td><code>label corr_</code></td>
<td><code>nCorrPIMPLE_</code></td>
<td><code>nOuterCorrectors</code></td>
<td>1</td>
<td><code>loop()</code></td>
</tr>
<tr>
<td>PISO压力修正循环</td>
<td><code>label corrPISO_</code></td>
<td><code>nCorrPISO_</code></td>
<td><code>nCorrectors</code></td>
<td>1</td>
<td><code>correct()</code></td>
</tr>
<tr>
<td>非正交修正</td>
<td><code>label corrNonOrtho_</code></td>
<td><code>nCorrNonOrtho_</code> <strong>这是实际迭代次数上限减1</strong></td>
<td><code>nNonOrthogonalCorrectors</code></td>
<td>0</td>
<td><code>correctNonOrthogonal()</code></td>
</tr>
<tr>
<td>是否执行动量预测步</td>
<td><code>bool momentumPredictor_</code></td>
<td></td>
<td><code>momentumPredictor</code></td>
<td>true</td>
<td><code>momentumPredictor()</code></td>
</tr>
<tr>
<td>一致性</td>
<td><code>bool consistent_</code></td>
<td></td>
<td><code>consistent</code></td>
<td>false</td>
<td><code>consistent()</code></td>
</tr>
<tr>
<td>跨声速</td>
<td><code>bool transonic</code></td>
<td></td>
<td><code>transonic</code></td>
<td>false</td>
<td><code>transonic()</code></td>
</tr>
<tr>
<td>是否在PISO循环外更新密度</td>
<td><code>bool SIMPLErho_</code></td>
<td></td>
<td><code>SIMPLErho</code></td>
<td>false</td>
<td><code>SIMPLErho()</code></td>
</tr>
<tr>
<td>仅在最后迭代启用湍流</td>
<td><code>bool turbOnFinalIterOnly_</code></td>
<td></td>
<td><code>turbOnFinalIterOnly</code></td>
<td>true</td>
<td><code>momentumPredictor()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="simpleFoam中phi变量的更新。"><a href="#simpleFoam中phi变量的更新。" class="headerlink" title="simpleFoam中phi变量的更新。"></a>simpleFoam中<code>phi</code>变量的更新。</h3><p>如果仔细的人应该会发现，<code>phi</code>这个变量在simpleFoam中是由<code>createFields.H</code>调用<code>createPhi.H</code>创建的，然后在<code>UEqn.H</code>中被<code>fvm::div(phi,U)</code>使用，那么在下一次迭代之前它是如何更新的呢？</p>
<p>我们发现它是在<code>pEqn.H</code>中更新的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pEqn.H</span></span><br><span class="line">	<span class="keyword">if</span> (simple.finalNonOrthogonalIter())</span><br><span class="line">        &#123;</span><br><span class="line">            phi = phiHbyA - pEqn.flux();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于adjustPhi-和-setReference"><a href="#关于adjustPhi-和-setReference" class="headerlink" title="关于adjustPhi, 和 setReference"></a>关于adjustPhi, 和 setReference</h3><p>adjustPhi和pRef针对的是压力方程为全Neuman边界的情况<sup><a href="#fn_12" id="reffn_12">12</a></sup>，这时解的存在唯一性会有两个问题:</p>
<ul>
<li>唯一性：方程系数矩阵M 列秩不满时，解有无穷多，相互之间相差一个常数，所以需要setReference</li>
<li>存在性：方程的增广矩阵行秩不满时，存在相容性问题，需要<code>adjustPhi</code></li>
</ul>
<h4 id="方程多解问题：setReference"><a href="#方程多解问题：setReference" class="headerlink" title="方程多解问题：setReference"></a>方程多解问题：setReference</h4><p>当方程为：</p>
<script type="math/tex; mode=display">
\Delta p = f \text{ on }\Omega \\


\nabla p \cdot \mathbf n = g \text{ on }\partial \Omega</script><p>首先，如果$p_1$是一个解，那么$p_2=p_1+const$也是方程的解，方程解不唯一，所以离散方程会有奇异性，无法求解。<br>解决方法是固定一个点的压力为给定值，就是设置<code>setReference</code>。</p>
<h4 id="方程相容性问题：adjustPhi"><a href="#方程相容性问题：adjustPhi" class="headerlink" title="方程相容性问题：adjustPhi"></a>方程相容性问题：adjustPhi</h4><p>p变量前面是直接加了微分的，所以需要对于全Neumann条件的情形还需要满足<strong>相容性条件</strong>：</p>
<script type="math/tex; mode=display">
\int_{\Omega}{f dV} =\int_{\Omega}{\Delta p dV} = \int_{ \partial\Omega}{\nabla p \cdot\mathbf n dS}

= \int_{ \partial\Omega}{g dS}</script><p>这就是adjustPhi去强制满足这个条件。<br>带入f和g的表达式</p>
<script type="math/tex; mode=display">
f= \nabla\cdot\mathbf u^*\\

g=0</script><p>可得：</p>
<script type="math/tex; mode=display">
\int_{\Omega}{\nabla \cdot \mathbf u^* dV} =\int_{\partial \Omega}{\mathbf u^*dS}= 0</script><p>你再看看adjustPhi出现的位置，是在pEqn.H中，对phiHbyA进行的调整。其实也就是这里的$\mathbf u^*$项。必须使其满足以上相容性条件。</p>
<h3 id="关于constrainPressure和constrainHbyA"><a href="#关于constrainPressure和constrainHbyA" class="headerlink" title="关于constrainPressure和constrainHbyA"></a>关于<code>constrainPressure</code>和<code>constrainHbyA</code></h3><p>从OpenFOAM的4.0版本开始，引入了<code>fixedFluxPressure,fixedFluxExtraoplatedPressure</code>边界条件，从而使入口的压力可以浮动，且边界压力梯度还可以根据计算情况进行调整，于是引入了<code>constrainPressure()</code>和<code>constrainHbyA()</code>函数。 </p>
<p>其说明可以参考<a href="http://caefn.com/" target="_blank" rel="noopener">Fumiya Nozaki’s CFD Blog</a>的这篇blog：<a href="http://caefn.com/openfoam/solvers-recent-changes" target="_blank" rel="noopener">Recent changes in the basics of the OpenFOAM solvers</a>和 <a href="http://caefn.com/openfoam/ja-bc-fixedfluxpressure" target="_blank" rel="noopener">fixedFluxPressure 境界条件</a>。 </p>
<h4 id="constrainPressure用于调整压力p的边界"><a href="#constrainPressure用于调整压力p的边界" class="headerlink" title="constrainPressure用于调整压力p的边界"></a><code>constrainPressure</code>用于调整压力p的边界</h4><p>可压缩流中边界速度$U_f$在离散生成<code>UEqn</code>之后可以表示为：</p>
<script type="math/tex; mode=display">
\begin{equation} 
\rho \boldsymbol{U}_f \cdot \boldsymbol{S}_f = \left(\frac{\rho \boldsymbol{H} }{A_p}\right)_f \cdot \boldsymbol{S}_f\;-\;\left(\frac{\rho}{A_p}\right)_f (\nabla p)_f \cdot \boldsymbol{S}_f. \tag{1} \label{eq:1} 
\end{equation}</script><p>所以界面法向压力梯度可以表示为：</p>
<script type="math/tex; mode=display">
\begin{equation} 
(\nabla p)_f \cdot \boldsymbol{n}_f = \frac{1}{|\boldsymbol{S}_f|\left(\frac{\rho}{A_p}\right)_f} \left(\left(\frac{\rho \boldsymbol{H} }{A_p}\right)_f \cdot \boldsymbol{S}_f\;-\;\rho \boldsymbol{U}_f \cdot \boldsymbol{S}_f \right). \tag{2} \label{eq:2} 
\end{equation}</script><p>将上述关系运用于压力边界条件，就是<code>constrainPressure</code>要干的事儿。</p>
<ul>
<li><code>void constrainPressure(p,rho=1,U,phiHbyA,rhorAU,MRF=NULLMRF)</code><ul>
<li>输出调整的其实是p</li>
<li>必要的输入有<code>U,phiHbyA,rhorAU</code></li>
</ul>
</li>
</ul>
<ul>
<li>p边界条件继承于<code>fixedFluxPressureFvPatchScalarField</code>的才会调整。</li>
</ul>
<h4 id="constrainHbyA-tHbyA-U-p-用于返回调整后的tHbyANew变量"><a href="#constrainHbyA-tHbyA-U-p-用于返回调整后的tHbyANew变量" class="headerlink" title="constrainHbyA(tHbyA,U,p)用于返回调整后的tHbyANew变量"></a><code>constrainHbyA(tHbyA,U,p)</code>用于返回调整后的<code>tHbyANew</code>变量</h4><ul>
<li>循环每个边界</li>
<li>当<code>U</code>的在这个边界的边界条件是<code>assignable()==false</code></li>
<li>且<code>p</code>的在这个边界是继承自<code>fixedFluxExtrapolatedPressureFvPatchScalarField</code></li>
<li><code>tHbyANew</code>的这个 这边界设置为和<code>U</code>的这个边界相同的值。</li>
<li>返回<code>tHbyANew</code></li>
<li>为什么要这么做：我也不知道。可能这样做了之后<code>constrainPressure()</code>得到的压力和<code>HbyA</code>在固定速度的边界与前述PLE方程就是一致的了，毕竟前面的<code>constrainPressure()</code>是利用了<code>HbyA</code>生成的<code>phiHbyA</code>的。</li>
<li>如果没有用到<code>fixedFluxExtrapolatedPressure</code>和 <code>fixedFluxPressure</code>边界条件，这两个函数其实相当于没有作用。</li>
</ul>
<h3 id="关于fvc-ddtCorr-和fvc-ddtPhiCorr"><a href="#关于fvc-ddtCorr-和fvc-ddtPhiCorr" class="headerlink" title="关于fvc::ddtCorr()和fvc::ddtPhiCorr()"></a>关于fvc::ddtCorr()和fvc::ddtPhiCorr()</h3><p>对于非稳态的求解器，如pimpleFoam, pisoFoam和icoFoam中，<code>phiHbyA</code>在构造时除了用到<code>HbyA</code> 向的插值，还会用到<code>fvc::ddtCorr()</code>，这一项主要是为了修正非定常和松弛因子对解的影响。而且这一项还是和OpenFOAM版本历史相关的！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OpenFOAM 5.x, 4.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +77</span></span><br><span class="line">            surfaceScalarField phiHbyA</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"phiHbyA"</span>,</span><br><span class="line">                fvc::flux(HbyA) <span class="comment">//这里用了fvc::flux函数，而不是原来的interpolate 和 &amp; 算符</span></span><br><span class="line">              + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi) <span class="comment">//用的是ddtCorr!</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"><span class="comment">//OpenFOAM 2.3.x, 2.4.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C  +73</span></span><br><span class="line">            surfaceScalarField phiHbyA</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"phiHbyA"</span>,</span><br><span class="line">                (fvc::interpolate(HbyA) &amp; mesh.Sf())</span><br><span class="line">              + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi) <span class="comment">//用的是ddtCorr</span></span><br><span class="line">            );</span><br><span class="line"><span class="comment">//OpenFOAM 2.2.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +73</span></span><br><span class="line">            surfaceScalarField phiHbyA<span class="comment">//用了新的变量名!</span></span><br><span class="line">            (</span><br><span class="line">                <span class="string">"phiHbyA"</span>,</span><br><span class="line">                (fvc::interpolate(HbyA) &amp; mesh.Sf()) </span><br><span class="line">              + fvc::ddtPhiCorr(rAU, U, phi) <span class="comment">//用的是ddtPhiCorr!</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//OpenFOAM 2.1.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +72</span></span><br><span class="line">            phi = (fvc::interpolate(U) &amp; mesh.Sf())</span><br><span class="line">                + fvc::ddtPhiCorr(rAU, U, phi);</span><br><span class="line"></span><br><span class="line"><span class="comment">//foam-extend 4.0</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +86</span></span><br><span class="line">            U = HUEqn.H()/aU; <span class="comment">//注意这里的HUEqn不包含非定常项</span></span><br><span class="line">            phi = (fvc::interpolate(U) &amp; mesh.Sf()); <span class="comment">//所以这里也不包含。</span></span><br></pre></td></tr></table></figure>
<p>太老的就不管了，因为根据OpenFOAM.org官网的<a href="https://openfoam.org/release/2-3-0/numerics/" target="_blank" rel="noopener">更新说明</a>，2.3.0版本时已经把<code>ddtPhiCorr</code>换成了<code>ddtCorr</code>。</p>
<p>首先找OpenFOAM 5.x的代码，看看<code>ddtCorr()</code>到底是干啥的 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/fvc/fvcDdt.C +183</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;GeometricField&lt;typename flux&lt;Type&gt;::type, fvsPatchField, surfaceMesh&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">ddtCorr</span></span></span><br><span class="line"><span class="class">(</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">GeometricField</span>&lt;Type, fvPatchField, volMesh&gt;&amp; <span class="title">U</span>,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">GeometricField</span></span></span><br><span class="line"><span class="class">    &lt;</span></span><br><span class="line"><span class="class">        typename flux&lt;Type&gt;::type,</span></span><br><span class="line"><span class="class">        fvsPatchField,</span></span><br><span class="line"><span class="class">        surfaceMesh</span></span><br><span class="line"><span class="class">    &gt;&amp; <span class="title">phi</span></span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> fv::ddtScheme&lt;Type&gt;::New <span class="comment">//根据变量名返回tmp&lt;ddtScheme&lt;Type&gt;&gt;的临时对象</span></span><br><span class="line">    (</span><br><span class="line">        U.mesh(),</span><br><span class="line">        U.mesh().ddtScheme(<span class="string">"ddt("</span> + U.name() + <span class="string">')'</span>)</span><br><span class="line">    ).ref().fvcDdtPhiCorr(U, phi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里涉及到RTS机制，</span></span><br><span class="line"><span class="comment">//为了简化，参考steadyState和经典的Euler格式是怎么做的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/ddtSchemes/steadyStateDdtScheme/steadyStateDdtScheme.C +305</span></span><br><span class="line"><span class="comment">//steadyState返回的是0，无修正，这很正常。</span></span><br><span class="line"><span class="comment">//返回值的量纲是：phi.dimensions()/dimTime</span></span><br><span class="line"><span class="comment">//对于不可压缩流应该是L^3/T^2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;typename steadyStateDdtScheme&lt;Type&gt;::fluxFieldType&gt;</span></span><br><span class="line"><span class="class"><span class="title">steadyStateDdtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCorr</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;fluxFieldType&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> fluxFieldType</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"ddtCorr("</span> + U.name() + <span class="string">','</span> + phi.name() + <span class="string">')'</span>,</span><br><span class="line">                mesh().time().timeName(),</span><br><span class="line">                mesh()</span><br><span class="line">            ),</span><br><span class="line">            mesh(),</span><br><span class="line">            dimensioned&lt;<span class="keyword">typename</span> flux&lt;Type&gt;::type&gt;</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"0"</span>,</span><br><span class="line">                phi.dimensions()/dimTime,</span><br><span class="line">                Zero</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Euler格式的修正</span></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/ddtSchemes/EulerDdtScheme/EulerDdtScheme.C +534</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;typename EulerDdtScheme&lt;Type&gt;::fluxFieldType&gt;</span></span><br><span class="line"><span class="class"><span class="title">EulerDdtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCorr</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    dimensionedScalar rDeltaT = <span class="number">1.0</span>/mesh().time().deltaT(); <span class="comment">//时间增量的倒数</span></span><br><span class="line"></span><br><span class="line">    fluxFieldType phiCorr</span><br><span class="line">    (</span><br><span class="line">        phi.oldTime() - fvc::dotInterpolate(mesh().Sf(), U.oldTime())</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp&lt;fluxFieldType&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> fluxFieldType</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"ddtCorr("</span> + U.name() + <span class="string">','</span> + phi.name() + <span class="string">')'</span>,</span><br><span class="line">                mesh().time().timeName(),</span><br><span class="line">                mesh()</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">this</span>-&gt;fvcDdtPhiCoeff(U.oldTime(), phi.oldTime(), phiCorr)</span><br><span class="line">           *rDeltaT*phiCorr</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//涉及到fvcDdtPhiCoeff系数，继续查找，发现这个函数位于ddtScheme中。</span></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.C +151</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;surfaceScalarField&gt; <span class="title">ddtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCoeff</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phiCorr</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;surfaceScalarField&gt; tddtCouplingCoeff = scalar(<span class="number">1</span>)</span><br><span class="line">      - min</span><br><span class="line">        (</span><br><span class="line">            mag(phiCorr)</span><br><span class="line">           /(mag(phi) + dimensionedScalar(<span class="string">"small"</span>, phi.dimensions(), SMALL)),</span><br><span class="line">            scalar(<span class="number">1</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    surfaceScalarField&amp; ddtCouplingCoeff = tddtCouplingCoeff.ref();</span><br><span class="line"></span><br><span class="line">    surfaceScalarField::Boundary&amp; ccbf =</span><br><span class="line">        ddtCouplingCoeff.boundaryFieldRef();</span><br><span class="line"></span><br><span class="line">    forAll(U.boundaryField(), patchi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">        (</span><br><span class="line">            U.boundaryField()[patchi].fixesValue()</span><br><span class="line">         || isA&lt;cyclicAMIFvPatch&gt;(mesh().boundary()[patchi])</span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            ccbf[patchi] = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InfoInFunction</span><br><span class="line">            &lt;&lt; <span class="string">"ddtCouplingCoeff mean max min = "</span></span><br><span class="line">            &lt;&lt; gAverage(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMax(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMin(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tddtCouplingCoeff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以OpenFOAM的<code>ddtCorr</code>的算法如下：</p>
<ol>
<li>首先用过去时间的通量$\phi^{n-1}$和速度$U^{n-1}$估算通量的修正$\phi^{c}$。</li>
</ol>
<ol>
<li><script type="math/tex; mode=display">
\phi^{c} = \phi^{n-1} - U_f(U^{n-1})\cdot \mathbf S_f</script></li>
<li><p>计算ddt耦合系数$K_c$：</p>
<script type="math/tex; mode=display">
K_c = 1 - \min\left( \frac {|\phi^c|}{|\phi^{n-1}|+\epsilon}, 1\right)</script><p>同时，应该注意到，ddt耦合系数$K_c$是一个大于0的无量纲界面张量场！它的边界条件也被特殊地处理了，对于固定速度边界或cyclicAMI边界，它的值是0.</p>
</li>
<li><p>输出修正量$\phi^k = K_c\phi^c/\Delta t$</p>
</li>
</ol>
<p>但是为什么这么计算耦合系数$K_c$和通量$\phi^c$，我也不知道！ </p>
<ul>
<li><a href="https://www.cfd-online.com/Forums/openfoam-solving/60096-ddtphicorr.html#post516511" target="_blank" rel="noopener">cfd-online上一个叫eugene的id提到</a><code>ddtCorr</code>实质上是文献<sup><a href="#fn_19" id="reffn_19">19</a></sup>中的所谓Choi Correction，对应的原始文献是<sup><a href="#fn_20" id="reffn_20">20</a></sup> ，但发帖者认为<code>fvcDdtPhiCoeff = 1</code>时是完整的Choi Correction，但此时OpenFOAM会不稳定，所以用了一个经验性的<code>fvcDdtPhiCoeff()</code>函数来限制这个Choi Correction。</li>
</ul>
<h4 id="Jasak的搞法"><a href="#Jasak的搞法" class="headerlink" title="Jasak的搞法"></a>Jasak的搞法</h4><p>Jasak似乎玩了另外的花样。在foam-extend 4.0中，Jasak的icoFoam和OpenFOAM.org以及OpenFOAMplus的icoFoam就不一样了。</p>
<ul>
<li><p>Jasak的icoFoam把<code>UEqn</code>分成了<code>HUEqn</code>和<code>ddtUEqn</code>两部分：</p>
</li>
<li><ul>
<li><code>HUEqn</code>： 对流和扩散项</li>
<li><code>ddtUEqn</code>：非定常项；</li>
</ul>
</li>
<li><p>动量预测步：<code>HUEqn + ddtUEqn == -grad(p)</code></p>
</li>
<li><p>PISO循环中：<code>H</code>从<code>HUEqn.H()</code>中产生！与时间步完全无关。</p>
</li>
<li><p>速度更新：</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://github.com/Unofficial-Extend-Project-Mirror/foam-extend-foam-extend-4.0/blob/master/applications/solvers/incompressible/icoFoam/icoFoam.C +113</span></span><br><span class="line"><span class="comment">// Note: cannot call H(U) here because the velocity is not complete</span></span><br><span class="line"><span class="comment">// HJ, 22/Jan/2016</span></span><br><span class="line">U = <span class="number">1.0</span>/(aU + ddtUEqn.A())*</span><br><span class="line">(</span><br><span class="line">    U*aU - fvc::grad(p) + ddtUEqn.H()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Jasak 认为这使得代码更加清晰了（时间导数算子中完全去掉了<code>ddtPhiCorr</code>和<code>ddtCorr</code>）。而且<strong>完全消除了时间步和松弛因子对结果的影响</strong>。结果对比参考文献<sup><a href="#fn_17" id="reffn_17">17</a></sup></p>
<h4 id="投影法"><a href="#投影法" class="headerlink" title="投影法"></a>投影法</h4><p>另外一种选择是用投影法，参考文献<sup><a href="#fn_21" id="reffn_21">21</a></sup>。 投影法在同位网格上可以避免Rhie-Chow插值，从而避免这个<code>ddtCorr()</code>的问题。 他们也做了数值试验来观察这个质量通量修正项（mass flux correction term）对PISO算法的效果。发现扔掉这一项，PISO算法的耗散大大降低。</p>
<h4 id="OpenFOAMplus的搞法"><a href="#OpenFOAMplus的搞法" class="headerlink" title="OpenFOAMplus的搞法"></a>OpenFOAMplus的搞法</h4><p>OpenFOAMplus在v1706中的<code>ddtScheme</code>加入了一个<code>scalar ddtPhiCoeff_</code>的定义。从而使<code>ddtCorr()</code>的实现更加复杂化。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://develop.openfoam.com/Development/OpenFOAM-plus/blob/master/src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.H</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ddtScheme</span></span></span><br><span class="line"><span class="class">:</span></span><br><span class="line">    <span class="keyword">public</span> tmp&lt;ddtScheme&lt;Type&gt;&gt;::refCount</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> fvMesh&amp; mesh_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Input for fvcDdtPhiCoeff (-1 default)</span></span><br><span class="line">        scalar ddtPhiCoeff_; <span class="comment">//ebf654f2这个集成rhoPimpleAdiabaticFoam的提交中才出现的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>而此时更改为了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://develop.openfoam.com/Development/OpenFOAM-plus/blob/master/src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.C +151</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;surfaceScalarField&gt; <span class="title">ddtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCoeff</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phiCorr</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;surfaceScalarField&gt; tddtCouplingCoeff</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> surfaceScalarField</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"ddtCouplingCoeff"</span>,</span><br><span class="line">                U.mesh().time().timeName(),</span><br><span class="line">                U.mesh()</span><br><span class="line">            ),</span><br><span class="line">            U.mesh(),</span><br><span class="line">            dimensionedScalar(<span class="string">"one"</span>, dimless, <span class="number">1.0</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    surfaceScalarField&amp; ddtCouplingCoeff = tddtCouplingCoeff.ref();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ddtPhiCoeff_ &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ddtCouplingCoeff -= min</span><br><span class="line">        (</span><br><span class="line">            mag(phiCorr)</span><br><span class="line">           /(mag(phi) + dimensionedScalar(<span class="string">"small"</span>, phi.dimensions(), SMALL)),</span><br><span class="line">            scalar(<span class="number">1</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ddtCouplingCoeff =</span><br><span class="line">            dimensionedScalar(<span class="string">"ddtPhiCoeff"</span>, dimless, ddtPhiCoeff_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    surfaceScalarField::Boundary&amp; ccbf = ddtCouplingCoeff.boundaryFieldRef();</span><br><span class="line"></span><br><span class="line">    forAll(U.boundaryField(), patchi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">        (</span><br><span class="line">            U.boundaryField()[patchi].fixesValue()</span><br><span class="line">         || isA&lt;cyclicAMIFvPatch&gt;(mesh().boundary()[patchi])</span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            ccbf[patchi] = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InfoInFunction</span><br><span class="line">            &lt;&lt; <span class="string">"ddtCouplingCoeff mean max min = "</span></span><br><span class="line">            &lt;&lt; gAverage(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMax(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMin(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tddtCouplingCoeff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样使得可以这个系数可以手工调整。</p>
<p>他们所引用的参考文献<sup><a href="#fn_22" id="reffn_22">22</a></sup> 暂时没找到全文</p>
<h3 id="关于p-pFinal的选择"><a href="#关于p-pFinal的选择" class="headerlink" title="关于p,pFinal的选择"></a>关于<code>p,pFinal</code>的选择</h3><p>仔细的哥们儿会发现simpleFoam里用的是<code>pEqn.solve()</code>，到了icoFoam, pisoFoam和pimpleFoam里用的就是<code>pEqn.solve(mesh.solver(p.select(piso/pimple.finalInnerIter())))</code>。</p>
<p>这里的区别，还是看代码吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/finiteVolume/cfdTools/general/solutionControl/pimpleControl/pimpleControlI.H +92</span></span><br><span class="line"><span class="comment">//最后一步内迭代，也就是最后一次用PISO求解压力且是非正交修正的最后一步时返回true，否则返回false</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Foam::pimpleControl::finalInnerIter() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">       corrPISO_ == nCorrPISO_</span><br><span class="line">    &amp;&amp; corrNonOrtho_ == nNonOrthCorr_ + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/OpenFOAM/fields/GeometricFields/GeometricField/GeometricField.C +985</span></span><br><span class="line"><span class="comment">//true，也就是最后一次迭代时返回名字`pFinal`，否则返回名字`p`</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>, <span class="title">template</span>&lt;class&gt; <span class="title">class</span> <span class="title">PatchField</span>, <span class="title">class</span> <span class="title">GeoMesh</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:word Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;::select</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">bool</span> final</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (final)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name() + <span class="string">"Final"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/OpenFOAM/matrices/solution/solution.C +353</span></span><br><span class="line"><span class="comment">// 返回name对应的solver controls dictionary</span></span><br><span class="line"><span class="keyword">const</span> Foam::dictionary&amp; Foam::solution::solver(<span class="keyword">const</span> word&amp; name) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; <span class="string">"Lookup solver for "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solvers_.subDict(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/fvMatrices/fvMatrix/fvMatrixSolve.C +55</span></span><br><span class="line"><span class="comment">//按这个solverControls来解</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:SolverPerformance&lt;Type&gt; Foam::fvMatrix&lt;Type&gt;::solve</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; solverControls</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>结论：simpleFoam是稳态求解器，所以没有pFinal一说，所以用不着这套复杂的机制。</p>
<h3 id="关于收敛判据和求解控制"><a href="#关于收敛判据和求解控制" class="headerlink" title="关于收敛判据和求解控制"></a>关于收敛判据和求解控制</h3><p>对于不可压缩流动而言， 收敛判据只取决于两个问题，</p>
<ol>
<li>连续性方程是否得到满足，在多大程度上得到满足？<ol>
<li>OpenFOAM里是用<code>#include &quot;continuityErrs.H&quot;</code>来计算、记录和输出这一项的。<ol>
<li>程序开始时还需要用 <code>include &quot;initContinuityErrs.H&quot;</code> 初始化一下。</li>
<li>它用的是<code>phi</code>而不是<code>U</code></li>
<li>它会记录累计误差<code>cumulativeContErr</code>，全场流量平衡误差<code>globalContErr</code>，以及局部误差的和<code>sumLocalContErr</code>（最后一项几乎等价于速度场散度的L1模：$|\nabla\cdot U|_{L1}$）</li>
</ol>
</li>
<li>事实上这点比较简单，因为每次计算压力的时候都是力图使连续性方程得到满足的。</li>
<li>而且这一项与非定常项无关。</li>
</ol>
</li>
<li>动量方程在多大程度上得到满足：<ol>
<li>这点在OpenFOAM里是通过对动量方程的求解来满足的。</li>
<li>其实OpenFOAM并没有对其进行严格地度量（指L1, L2模这样的数学度量）。</li>
<li>对于稳态算法SIMPLE，看<strong>最终一步</strong>的动量方程的的<strong>初始残差</strong>；</li>
<li>对于非稳态算法（PISO, PIMPLE等）<strong>输出</strong>中的<strong>每个时间步最后一次外迭代</strong>时，动量方程的<strong>初始残差</strong>可以认为是一个度量，但是它并不完全一致和严格。<ol>
<li><strong>每个时间步</strong> 是因为非稳态算法一般是需要进行时间精确模拟的。如果这个时间步没有收敛，这个时间步就不对，并且会影响到下一个时间步。</li>
<li><strong>最后一次</strong> 是因为前面的算是中间过程，最后并不保存下来；</li>
<li><strong>外迭代</strong>是因为内迭代是解耦计算，有时候看上去残差很小，可能并没有卵用，一耦合残差又超级大。<ol>
<li>对SIMPLE对应着<code>simple.loop()</code></li>
<li>对PIMPLE对应着<code>pimple.loop()</code></li>
</ol>
</li>
<li><strong>初始残差</strong>是因为OpenFOAM输出的残差都是线性求解器输出的，而其中线性求解器输出的只有初始残差是和非线性残差是一致的。<ol>
<li>经过线性求解器的迭代，线性残差可能会很小，甚至到机器零；</li>
<li>但是这个解只有对初始解产生的矩阵系数是对的，如果把矩阵系数按照得到的解重新计算，得到的残差才算是非线性残差（严格说来也不完全一样，但是差不多啦）；</li>
<li>这个非线性残差小才算是收敛 ；</li>
<li>另外，即使非线性残差小不代表误差小；</li>
<li>时间步很大时，网格很粗时，即使残差为0，<strong>误差</strong>也可能很大；</li>
</ol>
</li>
<li>实际得到的解因为是最后一次外迭代完成之后的解，一般来说其非线性残差可能会比输出中的初始残差更小一些。但是这个数据并没有被计算和输出。</li>
</ol>
</li>
<li>参考<a href="https://chengdi123000.github.io/2018/01/04/OpenFOAM%E7%9A%84%E6%AE%8B%E5%B7%AE%E5%AE%9A%E4%B9%89/">OpenFOAM的残差定义</a></li>
</ol>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_1">
<sup>1</sup>. <a href="https://holzmann-cfd.de/publications/mathematics-numerics-derivations-and-openfoam" target="_blank" rel="noopener">MATHEMATICS, NUMERICS, DERIVATIONS AND OPENFOAM®</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. <strong>Patankar, S. V. and Spalding, D.B. (1972)</strong>, “A calculation procedure for heat, mass and momentum transfer in three-dimensional parabolic flows”, Int. J. of Heat and Mass Transfer, Volume 15, Issue 10, October 1972, Pages 1787-1806<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. <a href="https://mycourses.aalto.fi/pluginfile.php/458332/mod_folder/content/0/CHEM-E7160%20Pressure%20Correction%20Scheme.pdf?forcedownload=1" target="_blank" rel="noopener">Pressure Correction Scheme for Incompressible Fluid Flow </a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. S.V. Patankar. Numerical Heat Transfer and Fluid Flow. Hemisphere, 1980<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_5">
<sup>5</sup>. Caretto L.S., Gosman A.D., Patankar S.V., Spalding D.B. (1973) Two calculation procedures for steady, three-dimensional flows with recirculation. In: Cabannes H., Temam R. (eds) Proceedings of the Third International Conference on Numerical Methods in Fluid Mechanics. Lecture Notes in Physics, vol 19. Springer, Berlin, Heidelberg<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_6">
<sup>6</sup>. <a href="http://thevisualroom.com/poisson_for_pressure.html" target="_blank" rel="noopener">http://thevisualroom.com/poisson_for_pressure.html</a><a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_7">
<sup>7</sup>. Lee S L, Tzong R Y. Artificial pressure for pressure-linked equation[J]. International journal of heat and mass transfer, 1992, 35(10): 2705-2716.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_8">
<sup>8</sup>. <a href="http://dyfluid.com/RhieChow.html" target="_blank" rel="noopener">http://dyfluid.com/RhieChow.html</a><a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_9">
<sup>9</sup>. <a href="http://www4.ncsu.edu/eos/users/w/white/www/white/ma587/lec24.pdf" target="_blank" rel="noopener">Nonlinear Systems: Picard and Newton methods</a> <a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_10">
<sup>10</sup>. <a href="https://books.google.com/books?id=fvX_umNtz_cC&amp;lpg=PA514&amp;ots=qdoBREZy6u&amp;dq=%E6%8A%95%E5%BD%B1%E7%AE%97%E6%B3%95%20sIMPLE&amp;pg=PA514#v=onepage&amp;q=%E6%8A%95%E5%BD%B1%E7%AE%97%E6%B3%95%20sIMPLE&amp;f=false" target="_blank" rel="noopener">林建忠，《流体力学》</a><a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_11">
<sup>11</sup>. DISCUSSION ON MOMENTUM INTERPOLATION METHOD FOR COLLOCATED GRIDS OF INCOMPRESSIBLE FLOW. Bo Yu, Wen-Quan Tao, Jin-Jia Wei, Yasuo Kawaguchi, Toshio Tagawa &amp; Hiroyuki Ozoe. Numerical Heat Transfer, Part B: Fundamentals Vol. 42 , Iss. 2,2002<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_12">
<sup>12</sup>. <a href="http://web.stanford.edu/class/cs205b/lectures/lecture16.pdf" target="_blank" rel="noopener">CS205b/CME306 Lecture 16</a><a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_13">
<sup>13</sup>. <a href="http://www.fem.unicamp.br/~im450/palestras&amp;artigos/CFD of Turbulence_Chalmers_Un/chapter_6-1.pdf" target="_blank" rel="noopener">Collocated grids </a><a href="#reffn_13" title="Jump back to footnote [13] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_14">
<sup>14</sup>. <a href="http://www.math.ucla.edu/~wotaoyin/splittingbook/ch3-macnamara-strang.pdf" target="_blank" rel="noopener">Operator Splitting</a><a href="#reffn_14" title="Jump back to footnote [14] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_15">
<sup>15</sup>. Issa, R. I. (1986). Solution of the implicitly discretised fluid flow equations by operator-splitting. <em>Journal of computational physics</em>, <em>62</em>(1), 40-65.<a href="#reffn_15" title="Jump back to footnote [15] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_16">
<sup>16</sup>. Van Doormaal, J. P., &amp; Raithby, G. D. (1984). Enhancements of the SIMPLE method for predicting incompressible fluid flows. <em>Numerical heat transfer</em>, <em>7</em>(2), 147-163.<a href="#reffn_16" title="Jump back to footnote [16] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_17">
<sup>17</sup>. <a href="http://foam-u.fr/wp-content/uploads/2017/02/Invited_1stOFDayFrance_Jasak.pdf" target="_blank" rel="noopener">Numerics Improvements and Validation Results: FOAM-Extend Update on Work-in-Progress</a><a href="#reffn_17" title="Jump back to footnote [17] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_18">
<sup>18</sup>. Moukalled, F., Mangani, L., &amp; Darwish, M. (2016). The finite volume method in computational fluid dynamics.<a href="#reffn_18" title="Jump back to footnote [18] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_19">
<sup>19</sup>. <a href="http://nht.xjtu.edu.cn/paper/en/2002206.pdf" target="_blank" rel="noopener">Yu, B., Tao, W. Q., Wei, J. J., Kawaguchi, Y., Tagawa, T., &amp; Ozoe, H. (2002). Discussion on momentum interpolation method for collocated grids of incompressible flow. <em>Numerical Heat Transfer: Part B: Fundamentals</em>, <em>42</em>(2), 141-166.</a><a href="#reffn_19" title="Jump back to footnote [19] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_20">
<sup>20</sup>. S. K. Choi, Note on the Use of Momentum Interpolation Method for Unsteady Flows, Numer. Heat Transfer A, vol. 36, pp. 545-550, 1999.<a href="#reffn_20" title="Jump back to footnote [20] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_21">
<sup>21</sup>. Vuorinen, V., Keskinen, J. P., Duwig, C., &amp; Boersma, B. J. (2014). On the implementation of low-dissipative Runge–Kutta projection methods for time dependent flows using OpenFOAM®. <em>Computers &amp; Fluids</em>, <em>93</em>, 153-163.<a href="#reffn_21" title="Jump back to footnote [21] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_22">
<sup>22</sup>. Knacke, T. (2013). Potential effects of Rhie &amp; Chow type interpolations in airframe noise simulations. In: Schram, C., Dénos, R., Lecomte E. (ed):   Accurate and efficient aeroacoustic prediction approaches for  airframe noise, VKI LS 2013-03.<a href="#reffn_22" title="Jump back to footnote [22] in the text."> &#8617;</a>
</blockquote>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> SIMPLE </tag>
            
            <tag> PISO </tag>
            
            <tag> PIMPLE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MASA的安装]]></title>
      <url>/2018/01/05/MASA%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>MASA (Manufactured Analytical Solution Abstraction) 的安装<br><a id="more"></a></p>
<h1 id="MASA的安装"><a href="#MASA的安装" class="headerlink" title="MASA的安装"></a>MASA的安装</h1><p>MASA (Manufactured Analytical Solution Abstraction) 是一个经过验证的虚构解验证程序库，用C++写的，并提供C, python, Fortran90等其他语言的接口。可以用于对常见偏微分方程的模拟程序进行代码验证（Code Verification）。</p>
<p>它所包含的方程有：</p>
<ol>
<li>Heat Equation</li>
<li>Laplace’s Equation</li>
<li>Euler Equations (with and without thermal equilibrium chemistry)</li>
<li>Navier-Stokes Equations</li>
<li>Reynolds Averaged Navier Stokes with Various Turbulence Models</li>
</ol>
<p>MASA 网址: <a href="https://github.com/manufactured-solutions/MASA.git" target="_blank" rel="noopener">https://github.com/manufactured-solutions/MASA.git</a></p>
<p>MASA 文档: <a href="http://manufactured-solutions.github.io/MASA/" target="_blank" rel="noopener">http://manufactured-solutions.github.io/MASA/</a></p>
<h2 id="下载和编译"><a href="#下载和编译" class="headerlink" title="下载和编译"></a>下载和编译</h2><pre><code>cd
git clone https://github.com/manufactured-solutions/MASA.git MASA_src
cd MASA_src

# check tools
which gcc gfortran g++
</code></pre><p>但是这个文件夹中没有常见的configure, CMakeLists.txt和Makefile，所以不知道怎么编译。</p>
<p>经过搜索，发现这个库应该用 <a href="https://en.wikipedia.org/wiki/GNU_Build_System" target="_blank" rel="noopener">GNU Build System</a> 来编译。</p>
<p>GNU Build System的整个流程如下图所示：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/84/Autoconf-automake-process.svg" alt="flowchart of build tools"></p>
<p>所以需要的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 切换到root</span><br><span class="line">yum install libtool autoconf automake gcc-gfortran swig  python-devel -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 切换回来</span><br><span class="line">su ofuser</span><br><span class="line">cd</span><br><span class="line">cd MASA_src</span><br><span class="line">autoreconf -i</span><br><span class="line">./configure --prefix=$HOME/lib/MASA \</span><br><span class="line">--enable-python-interfaces \</span><br><span class="line">--enable-fortran-interfaces \</span><br><span class="line">--enable-static \</span><br><span class="line">--enable-warn-all \</span><br><span class="line">--enable-coverage \</span><br><span class="line">--enable-strict-tests \</span><br><span class="line">make</span><br><span class="line">make check #FAIL: f_insh</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>一些关于库使用的输出:</p>
<pre><code>----------------------------------------------------------------------
Libraries have been installed in:
   /home/ofuser/lib/MASA/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the `-LLIBDIR&#39;
flag during linking and do at least one of the following:
   - add LIBDIR to the `LD_LIBRARY_PATH&#39; environment variable
     during execution
   - add LIBDIR to the `LD_RUN_PATH&#39; environment variable
     during linking
   - use the `-Wl,-rpath -Wl,LIBDIR&#39; linker flag
   - have your system administrator add LIBDIR to `/etc/ld.so.conf&#39;

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
Libraries have been installed in:
   /home/ofuser/lib/MASA/lib64/python2.7/site-packages/masa

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the `-LLIBDIR&#39;
flag during linking and do at least one of the following:
   - add LIBDIR to the `LD_LIBRARY_PATH&#39; environment variable
     during execution
   - add LIBDIR to the `LD_RUN_PATH&#39; environment variable
     during linking
   - use the `-Wl,-rpath -Wl,LIBDIR&#39; linker flag
   - have your system administrator add LIBDIR to `/etc/ld.so.conf&#39;

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
</code></pre>]]></content>
      
        <categories>
            
            <category> MMS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MMS </tag>
            
            <tag> MASA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenFOAM在docker中的使用]]></title>
      <url>/2018/01/05/OpenFOAM%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>利用docker在windows中使用OpenFOAM。利用共享文件夹功能在windows中进行前后处理。<br><a id="more"></a></p>
<h1 id="OpenFOAM在docker中的使用"><a href="#OpenFOAM在docker中的使用" class="headerlink" title="OpenFOAM在docker中的使用"></a>OpenFOAM在docker中的使用</h1><p>操作系统：windows 10 Pro/Home</p>
<p>docker版本：docker有两种，一种是社区版Community Edition，一种是商业版。我们采用免费的社区版，但是由于docker本质上是一个Linux程序，所以即使是社区版，在windows下使用时需要首先用虚拟机运行一个Linux平台（通常是Moby Linux），根据虚拟机平台的不同，也是有两种选择：</p>
<ul>
<li>docker for windows，这个版本是主推的版本，可以利用windows10的HyperV虚拟化平台。但是windows10需要Pro版或者旗舰版才能开启HyperV虚拟化。</li>
<li>docker toolbox，这个版本是比较老的，利用的是Oracle的VirtualBox进行虚拟化，但是可以在Windows10 Home版本下运行，或者在windows 7等老版本操作系统下运行。</li>
</ul>
<p>两个版本我都会介绍到。</p>
<h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>下面分别介绍docker for windows和docker toolbox的安装</p>
<h3 id="docker-for-windows"><a href="#docker-for-windows" class="headerlink" title="docker for windows"></a>docker for windows</h3><p>对于可以开启HyperV虚拟化的windows 10 Pro或者旗舰版而言，docker for windows是最好的选择。</p>
<p>网址: <a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p>
<p>下载: <a href="https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe" target="_blank" rel="noopener">Docker for Windows Installer.exe</a></p>
<p>版本: Docker version 17.09.0, 社区版中的最新稳定版。</p>
<p>安装指南: <a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/</a></p>
<p>一路点击OK,next 安装完成后，运行<code>Docker for Windows</code>. 它会花费一些时间启动 <code>docker engine</code>. 等提示启动完成后，右键单击<code>开始</code>按钮，选择”Windows Powershell”。打开Powershell命令行。（用cmd也是可以的）</p>
<p>运行如下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"><span class="comment">## Docker version 17.09.0-ce, build afdb6d4</span></span><br><span class="line">docker-compose --version</span><br><span class="line"><span class="comment">## docker-compose version 1.16.1, build 6d1ac219</span></span><br><span class="line">docker-machine --version</span><br><span class="line"><span class="comment">## docker-machine.exe version 0.12.2, build 9371605</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## Hello from Docker!</span></span><br><span class="line"><span class="comment">## This message shows that your installation appears to be working correctly.</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## To generate this message, Docker took the following steps:</span></span><br><span class="line"><span class="comment">##  1. The Docker client contacted the Docker daemon.</span></span><br><span class="line"><span class="comment">##  2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span></span><br><span class="line"><span class="comment">##     (amd64)</span></span><br><span class="line"><span class="comment">##  3. The Docker daemon created a new container from that image which runs the</span></span><br><span class="line"><span class="comment">##     executable that produces the output you are currently reading.</span></span><br><span class="line"><span class="comment">##  4. The Docker daemon streamed that output to the Docker client, which sent it</span></span><br><span class="line"><span class="comment">##     to your terminal.</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## To try something more ambitious, you can run an Ubuntu container with:</span></span><br><span class="line"><span class="comment">##  $ docker run -it ubuntu bash</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## Share images, automate workflows, and more with a free Docker ID:</span></span><br><span class="line"><span class="comment">##  https://cloud.docker.com/</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## For more examples and ideas, visit:</span></span><br><span class="line"><span class="comment">##  https://docs.docker.com/engine/userguide/</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment">## CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span></span><br><span class="line"><span class="comment">## 32a621d46d34        hello-world         "/hello"            24 seconds ago      Exited (0) 23 seconds ago                       clever_agnesi</span></span><br><span class="line">docker rm <span class="number">32</span>a621d46d34 <span class="comment">#change it to your container ID</span></span><br><span class="line"><span class="comment">## 32a621d46d34 </span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment">## CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span></span><br></pre></td></tr></table></figure>
<h3 id="docker-toolbox安装"><a href="#docker-toolbox安装" class="headerlink" title="docker toolbox安装"></a>docker toolbox安装</h3><p>网址和安装指南：<a href="https://docs.docker.com/toolbox/toolbox_install_windows/" target="_blank" rel="noopener">https://docs.docker.com/toolbox/toolbox_install_windows/</a></p>
<p>下载：<a href="https://download.docker.com/win/stable/DockerToolbox.exe" target="_blank" rel="noopener">https://download.docker.com/win/stable/DockerToolbox.exe</a></p>
<p>这个docker toolbox也要求至少是64位的windows 操作系统，win 7 以上。并且在BIOS中开启了虚拟化（Virtualization，和HyperV不同）</p>
<p>docker toolbox安装时会安装VirtualBox。</p>
<p>安装完成后会出现以下几个图标：</p>
<p><img src="https://docs.docker.com/toolbox/images/icon-set.png" alt=""></p>
<p>双击“Docker Quickestart”可以启动MSYS2 ，用如下命令进行测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"><span class="meta">#</span>Docker version 17.10.0-ce, build f4ffd25</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker-compose --version</span><br><span class="line"><span class="meta">#</span>docker-compose version 1.16.1, build 6d1ac219</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker-machine --version</span><br><span class="line"><span class="meta">#</span>docker-machine.exe version 0.13.0, build 9ba6da9</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Hello from Docker!</span><br><span class="line"><span class="meta">#</span>This message shows that your installation appears to be working correctly.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>To generate this message, Docker took the following steps:</span><br><span class="line"><span class="meta">#</span> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"><span class="meta">#</span> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span><br><span class="line"><span class="meta">#</span>    (amd64)</span><br><span class="line"><span class="meta">#</span> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line"><span class="meta">#</span>    executable that produces the output you are currently reading.</span><br><span class="line"><span class="meta">#</span> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line"><span class="meta">#</span>    to your terminal.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta">#</span> $ docker run -it ubuntu bash</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"><span class="meta">#</span> https://cloud.docker.com/</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>For more examples and ideas, visit:</span><br><span class="line"><span class="meta">#</span> https://docs.docker.com/engine/userguide/</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta">#</span>CONTAINER ID        IMAGE                                   COMMAND             CREATED             STATUS                         PORTS               NAMES</span><br><span class="line"><span class="meta">#</span>a8e15cba83b6        hello-world                             "/hello"            10 seconds ago      Exited (0) 10 seconds ago                          musing_hamilton</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker rm a8e15cba83b6</span><br><span class="line"><span class="meta">#</span>a8e15cba83b6</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta">#</span>CONTAINER ID        IMAGE                                   COMMAND             CREATED             STATUS                         PORTS               NAMES</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>至此，docker就安装好了。</p>
<h2 id="下载OpenFOAM的-docker-image"><a href="#下载OpenFOAM的-docker-image" class="headerlink" title="下载OpenFOAM的 docker image"></a>下载OpenFOAM的 docker image</h2><p>很简单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker pull openfoamplus/of_v1706_centos73 # OF+</span><br><span class="line"><span class="meta">#</span> or</span><br><span class="line"><span class="meta">#</span> docker pull openfoam/openfoam5-paraview54 # OF5</span><br><span class="line"><span class="meta">#</span> list images</span><br><span class="line">docker image ls</span><br><span class="line"><span class="meta">#</span> REPOSITORY                       TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line"><span class="meta">#</span> hello-world                      latest              f2a91732366c        6 weeks ago         1.85kB</span><br><span class="line"><span class="meta">#</span> openfoamplus/of_v1706_centos73   latest              9b81f0cd518b        6 months ago        1.76GB</span><br></pre></td></tr></table></figure>
<h2 id="映射共享文件夹并测试OpenFOAM"><a href="#映射共享文件夹并测试OpenFOAM" class="headerlink" title="映射共享文件夹并测试OpenFOAM"></a>映射共享文件夹并测试OpenFOAM</h2><p>共享文件夹是与docker交换数据最方便的工具。windows下的docker可以通过虚拟机的功能配合docker工具自带的映射功能，实现映射共享文件夹的功能。为了避免问题过于复杂化，本文的共享文件夹位于<code>C:\Users\cheng</code>目录之下，这样可以避免对虚拟机的大幅变动。如果需要共享位于其他位置的文件夹，使用docker toolbox的请参考<a href="http://support.divio.com/local-development/docker/how-to-use-a-directory-outside-cusers-with-docker-toolbox-on-windows" target="_blank" rel="noopener">How to use a directory outside C:\Users with Docker Toolbox on Windows</a>，使用docker for windows的可以参考：<a href="https://rominirani.com/docker-on-windows-mounting-host-directories-d96f3f056a2c" target="_blank" rel="noopener">Docker on Windows — Mounting Host Directories</a></p>
<ul>
<li>docker for windows: 采用powershell</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cd c:\Users\cheng</span><br><span class="line"></span><br><span class="line">mkdir OpenFOAM</span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-i -t \</span><br><span class="line">--name myOFplus_1706 \</span><br><span class="line">-v <span class="string">"/c/Users/cheng/OpenFOAM:/home/ofuser/OpenFOAM"</span> \</span><br><span class="line">openfoamplus/of_v1706_centos73 \</span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的代码在进入bash后输入</span></span><br><span class="line">su ofuser</span><br><span class="line">cd </span><br><span class="line">mkdir -p <span class="variable">$FOAM_RUN</span></span><br><span class="line">run</span><br><span class="line">cp -r <span class="variable">$FOAM_TUTORIALS</span>/incompressible/icoFoam/cavity .</span><br><span class="line">./Allrun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要临时退出，但不中断执行</span></span><br><span class="line"><span class="comment"># 按Ctrl+p, Ctrl+q</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 再次进入docker image的bash</span></span><br><span class="line">docker attach myOFplus_1706</span><br></pre></td></tr></table></figure>
<ul>
<li>docker toolbox: 采用“Docker Quickestart”启动的仿bash界面。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cd c:\Users\cheng</span><br><span class="line"></span><br><span class="line">mkdir OpenFOAM</span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-i -t \</span><br><span class="line">--name myOFplus_1706 \</span><br><span class="line">-v "/c/Users/cheng/OpenFOAM:/home/ofuser/OpenFOAM" \</span><br><span class="line">openfoamplus/of_v1706_centos73 \</span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 下面的代码在进入bash后输入</span><br><span class="line">su ofuser</span><br><span class="line">cd </span><br><span class="line">mkdir -p $FOAM_RUN</span><br><span class="line">run</span><br><span class="line">cp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity .</span><br><span class="line">./Allrun</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 想要临时退出，但不中断执行</span><br><span class="line"><span class="meta">#</span> 按Ctrl+p, Ctrl+q</span><br></pre></td></tr></table></figure>
<h2 id="docker-中的OpenFOAM环境"><a href="#docker-中的OpenFOAM环境" class="headerlink" title="docker 中的OpenFOAM环境"></a>docker 中的OpenFOAM环境</h2><p>以下命令在docker中可以查看出安装环境</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cd </span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">echo $WM_PROJECT_DIR #OpenFOAM安装位置</span><br><span class="line"><span class="meta">#</span>/opt/OpenFOAM/OpenFOAM-v1706</span><br><span class="line">echo $WM_THIRD_PARTY_DIR #第三方软件文件夹位置</span><br><span class="line"><span class="meta">#</span>/opt/OpenFOAM/ThirdParty-v1706</span><br><span class="line">echo $WM_PROJECT_VERSION</span><br><span class="line"><span class="meta">#</span>v1706</span><br><span class="line">echo $WM_PROJECT_USER_DIR #OpenFOAM用户文件夹位置</span><br><span class="line"><span class="meta">#</span>/home/ofuser/OpenFOAM/ofuser-v1706</span><br><span class="line"></span><br><span class="line">echo $WM_OPTIONS #编译配置</span><br><span class="line"><span class="meta">#</span>linux64GccDPInt32Opt </span><br><span class="line"><span class="meta">#</span>编译配置为</span><br><span class="line"><span class="meta">#</span> linux64:64位Linux版本</span><br><span class="line"><span class="meta">#</span> DP:双精度</span><br><span class="line"><span class="meta">#</span> Gcc: GCC编译器</span><br><span class="line"><span class="meta">#</span> Int32: 32位整型</span><br><span class="line"><span class="meta">#</span> Opt: 性能优化版本，没有调试信息。</span><br><span class="line"></span><br><span class="line">g++ --version #采用的编译器版本</span><br><span class="line"><span class="meta">#</span>g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-11)</span><br><span class="line"><span class="meta">#</span>Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line"><span class="meta">#</span>This is free software; see the source for copying conditions.  There is NO</span><br><span class="line"><span class="meta">#</span>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line">mpirun --version # 采用的mpi版本</span><br><span class="line"><span class="meta">#</span>mpirun (Open MPI) 1.10.4</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Report bugs to http://www.open-mpi.org/community/help/</span><br></pre></td></tr></table></figure>
<h1 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h1><p>可以用paraview 进行后处理</p>
<h2 id="paraview-安装"><a href="#paraview-安装" class="headerlink" title="paraview 安装"></a>paraview 安装</h2><ul>
<li>网址：<a href="https://www.paraview.org/" target="_blank" rel="noopener">https://www.paraview.org/</a></li>
<li>下载地址：<a href="https://www.paraview.org/paraview-downloads/download.php?submit=Download&amp;version=v5.4&amp;type=binary&amp;os=Windows&amp;downloadFile=ParaView-5.4.1-Qt5-OpenGL2-Windows-64bit.exe" target="_blank" rel="noopener">https://www.paraview.org/paraview-downloads/download.php?submit=Download&amp;version=v5.4&amp;type=binary&amp;os=Windows&amp;downloadFile=ParaView-5.4.1-Qt5-OpenGL2-Windows-64bit.exe</a></li>
<li>版本：最新稳定版：5.4.1</li>
</ul>
<p>安装很容易。</p>
<p>由于windows版本的paraview没有编译安装OpenFOAM专用reader，所以需要在shell中，位于算例文件目录下用<code>touch a.foam</code>建立一个文件（一些教程中的<code>touch a.OpenFOAM</code>无效）。</p>
<p>后处理结果如下：</p>
<p><img src="/images/U_mag_comparison.png" alt="U_mag_comparison"></p>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenFOAM输出完整矩阵]]></title>
      <url>/2018/01/04/OpenFOAM%E8%BE%93%E5%87%BA%E5%AE%8C%E6%95%B4%E7%9F%A9%E9%98%B5/</url>
      <content type="html"><![CDATA[<p>输出单CPU算例带耦合边界条件的fvScalarMatrix中的完整矩阵信息。<br><a id="more"></a></p>
<h1 id="OpenFOAM输出完整矩阵"><a href="#OpenFOAM输出完整矩阵" class="headerlink" title="OpenFOAM输出完整矩阵"></a>OpenFOAM输出完整矩阵</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>OpenFOAM采用的特殊矩阵模式导致输出完整矩阵很困难。本文尝试解决的是输出单CPU算例带耦合边界条件的问题中的fvScalarMatrix的问题。</p>
<p>首先，需要限定是单CPU，否则可能存在CPU间的processorFvPatch耦合界面边界条件，fvScalarMatrix将无法包含所有的边界条件相关的源项。</p>
<p>其次耦合边界条件中仅支持cyclic类边界条件，jumpCyclic边界条件可能存在线性代数上的一致性问题，暂时不考虑。</p>
<p>再次，输出限于fvScalarMatrix，fvVectorMatrix的情况类似，但是涉及到更加复杂一些的操作。</p>
<p>最后，采用<code>cnpy</code>库输出为numpy支持的npy或npz格式，便于进一步分析，具体模式为COO模式，同时<code>cnpy</code>还提供了npy2mat, npz2mat, mat2npz等工具用于与matlab交换数据。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>需要首先安装一个<code>cnpy</code>的小程序库，用于生成numpy和matlab可以直接读取的文件。</p>
<ul>
<li>网址: <a href="https://github.com/rogersce/cnpy" target="_blank" rel="noopener">https://github.com/rogersce/cnpy</a></li>
<li>命令行:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在root账户下</span></span><br><span class="line">yum install cmake git -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># `su ofuser`到ofuser账户， check tools</span></span><br><span class="line">cmake --version</span><br><span class="line">g++ --version</span><br><span class="line">git --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># clone, configure, build and install</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/rogersce/cnpy.git cnpy_src</span><br><span class="line"><span class="built_in">cd</span> cnpy_src</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DENABLE_STATIC=ON -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/lib/cnpy</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>实际程序中<code>#include</code>如下代码：<code>dumpFvScalarMatrix.H</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fvCFD.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cyclicFvPatch.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cnpy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">path: 想要储存的文件名</span></span><br><span class="line"><span class="comment">Eqn: fvScalarMatrix 的常量引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpFvScalarMatrix</span><span class="params">( <span class="keyword">const</span> fvScalarMatrix&amp; Eqn,fileName filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (filepath.hasExt() == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      filepath = filepath.ext(<span class="string">"npz"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">const</span> label nCells = Eqn.diag().size();</span><br><span class="line">	<span class="keyword">const</span> label nFaces = Eqn.lower().size();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> scalar* <span class="keyword">const</span> __restrict__ diagPtr = Eqn.diag().begin();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> label* <span class="keyword">const</span> __restrict__ uPtr = Eqn.lduAddr().upperAddr().begin();</span><br><span class="line">	<span class="keyword">const</span> label* <span class="keyword">const</span> __restrict__ lPtr = Eqn.lduAddr().lowerAddr().begin();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> scalar* <span class="keyword">const</span> __restrict__ upperPtr = Eqn.upper().begin();</span><br><span class="line">	<span class="keyword">const</span> scalar* <span class="keyword">const</span> __restrict__ lowerPtr = Eqn.lower().begin();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;scalar&gt; AA(nCells+<span class="number">2</span>*nFaces);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;scalar&gt; S(nCells);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;scalar&gt; x0(nCells);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;label&gt; JR(nCells+<span class="number">2</span>*nFaces);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;label&gt; JC(nCells+<span class="number">2</span>*nFaces);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">auto</span> psi=Eqn.psi();</span><br><span class="line">    <span class="keyword">auto</span> s=Eqn.source();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// diag</span></span><br><span class="line">	<span class="keyword">for</span>(label cell=<span class="number">0</span>;cell&lt;nCells;cell++)</span><br><span class="line">	&#123;</span><br><span class="line">		AA[cell]=diagPtr[cell];</span><br><span class="line">		JR[cell]=cell;</span><br><span class="line">		JC[cell]=cell;</span><br><span class="line">         S[cell]=s[cell];</span><br><span class="line">         x0[cell]=psi[cell];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Upper</span></span><br><span class="line">	<span class="keyword">for</span>(label face=<span class="number">0</span>;face&lt;nFaces;face++)</span><br><span class="line">	&#123;</span><br><span class="line">		AA[face+nCells]=upperPtr[face];</span><br><span class="line">		JR[face+nCells]=uPtr[face];</span><br><span class="line">		JC[face+nCells]=lPtr[face];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Lower</span></span><br><span class="line">	<span class="keyword">for</span>(label face=<span class="number">0</span>;face&lt;nFaces;face++)</span><br><span class="line">	&#123;</span><br><span class="line">		AA[face+nCells+nFaces]=lowerPtr[face];</span><br><span class="line">		JR[face+nCells+nFaces]=lPtr[face];</span><br><span class="line">		JC[face+nCells+nFaces]=uPtr[face];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//边界贡献</span></span><br><span class="line">    <span class="keyword">auto</span> I = Eqn.internalCoeffs();</span><br><span class="line">    <span class="keyword">auto</span> B = Eqn.boundaryCoeffs();</span><br><span class="line">    <span class="keyword">auto</span> psib = psi.boundaryField();</span><br><span class="line">    forAll(psib,patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> fvPatch&amp; pp = psib[patchI].patch();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pp.coupled()) <span class="comment">//耦合边界</span></span><br><span class="line">        &#123;</span><br><span class="line">          	<span class="keyword">if</span>(isA&lt;cyclicFvPatch&gt;(pp)) <span class="comment">//只处理循环边界</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">const</span> cyclicFvPatch&amp; pnp= (refCast&lt;<span class="keyword">const</span> cyclicFvPatch&gt;(pp)).neighbPatch();</span><br><span class="line">              forAll(pp,faceI)</span><br><span class="line">            &#123;</span><br><span class="line">                label cellI = pp.faceCells()[faceI];</span><br><span class="line">                label cellJ = pnp.faceCells()[faceI];</span><br><span class="line">                AA[cellI] += I[patchI][faceI];</span><br><span class="line">                AA.push_back(B[patchI][faceI]);</span><br><span class="line">                JR.push_back(cellI);</span><br><span class="line">                JC.push_back(cellJ);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//其他非循环边界的耦合边界，统统报错退出</span></span><br><span class="line">            &#123;</span><br><span class="line">              SeriousError&lt;&lt;<span class="string">"Only support cyclic coupled BC!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//非耦合边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            forAll(pp,faceI)</span><br><span class="line">            &#123;</span><br><span class="line">                label cellI = pp.faceCells()[faceI];</span><br><span class="line">                AA[cellI] += I[patchI][faceI];</span><br><span class="line">                S[cellI] += B[patchI][faceI];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	cnpy::npz_save(filepath,<span class="string">"AA"</span>,&amp;AA[<span class="number">0</span>],&#123;AA.size()&#125;,<span class="string">"w"</span>);</span><br><span class="line">	cnpy::npz_save(filepath,<span class="string">"JR"</span>,&amp;JR[<span class="number">0</span>],&#123;JR.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line">	cnpy::npz_save(filepath,<span class="string">"JC"</span>,&amp;JC[<span class="number">0</span>],&#123;JC.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line">	cnpy::npz_save(filepath,<span class="string">"S"</span>,&amp;S[<span class="number">0</span>],&#123;S.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line">	cnpy::npz_save(filepath,<span class="string">"x0"</span>,&amp;x0[<span class="number">0</span>],&#123;x0.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="基于-icoFoam的源代码建立myIcoFoam"><a href="#基于-icoFoam的源代码建立myIcoFoam" class="headerlink" title="基于 icoFoam的源代码建立myIcoFoam"></a>基于 icoFoam的源代码建立myIcoFoam</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line">cd ..</span><br><span class="line">mkdir -p applications/solvers</span><br><span class="line">cd applications/solvers</span><br><span class="line"><span class="meta">#</span><span class="bash"> I put my solver here.</span></span><br><span class="line">pwd # /OF/OpenFOAM/-v1706/applications/solvers</span><br><span class="line">cp $FOAM_SOLVERS/incompressible/icoFoam -r .</span><br><span class="line">mv icoFoam myIcoFoam</span><br><span class="line">cd myIcoFoam</span><br><span class="line">mv icoFoam.C myIcoFoam.C</span><br><span class="line">sed -i s/icoFoam/myIcoFoam/g myIcoFoam.C</span><br><span class="line">sed -i s/icoFoam/myIcoFoam/g Make/files</span><br><span class="line">sed -i s/FOAM_APPBIN/FOAM_USER_APPBIN Make/files</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line">wmake</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> run</span></span><br><span class="line">run</span><br><span class="line">cd cavity</span><br><span class="line">foamJob -screen myIcoFoam</span><br></pre></td></tr></table></figure>
<h3 id="修改myIcoFoam的代码，输出pEqn的矩阵"><a href="#修改myIcoFoam的代码，输出pEqn的矩阵" class="headerlink" title="修改myIcoFoam的代码，输出pEqn的矩阵"></a>修改myIcoFoam的代码，输出pEqn的矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myIcoFoam.C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fvCFD.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pisoControl.H"</span></span></span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dumpFvScalarMatrix.H"</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">                  <span class="keyword">if</span> (piso.finalNonOrthogonalIter())</span><br><span class="line">                &#123;</span><br><span class="line">                    phi = phiHbyA - pEqn.flux();</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">//添加</span></span><br><span class="line">				<span class="keyword">if</span> (runTime.timeIndex()==<span class="number">2</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					Info&lt;&lt; <span class="string">"TimeIndex = 2, output matrix pEqn"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">					dumpFvScalarMatrix(pEqn,<span class="string">"Eqn.npz"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Make/options 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -I$(LIB_SRC)/finiteVolume/lnInclude \</span><br><span class="line">    -I$(LIB_SRC)/meshTools/lnInclude \</span><br><span class="line">    -I$(HOME)/lib/cnpy/include </span><br><span class="line"></span><br><span class="line">EXE_LIBS = \</span><br><span class="line">    -lfiniteVolume \</span><br><span class="line">    -lmeshTools \</span><br><span class="line">    -Wl,-rpath -Wl,$(HOME)/lib/cnpy/lib -L$(HOME)/lib/cnpy/lib -lcnpy</span><br></pre></td></tr></table></figure>
<h3 id="python后处理"><a href="#python后处理" class="headerlink" title="python后处理"></a>python后处理</h3><p>python需要安装scipy，在docker下比较简单的方法是到root账户下进行安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进root账户</span></span><br><span class="line">cd</span><br><span class="line">curl "https://bootstrap.pypa.io/get-pip.py" -o "get-pip.py"</span><br><span class="line">python get-pip.py</span><br><span class="line">pip install scipy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回到ofuser账户</span></span><br><span class="line">su ofuser</span><br><span class="line">cd</span><br><span class="line">python -c "import scipy as sp;print(sp.version.version)"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.0.0</span></span><br></pre></td></tr></table></figure>
<p>python后处理代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br><span class="line">data = np.load(<span class="string">"Eqn.npz"</span>)</span><br><span class="line"></span><br><span class="line">AA,JR,JC,S,x0 = data[<span class="string">'AA'</span>],data[<span class="string">'JR'</span>],data[<span class="string">'JC'</span>],data[<span class="string">'S'</span>],data[<span class="string">'x0'</span>]</span><br><span class="line">N = S.shape[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> coo_matrix</span><br><span class="line">sm = coo_matrix((AA,(JR,JC)),shape=(N,N))</span><br><span class="line">m = sm.toarray()</span><br><span class="line"><span class="keyword">print</span> m.shape</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://sssslide.com/www.slideshare.net/fumiyanozaki96/openfoam-32087641" target="_blank" rel="noopener">OpenFOAM －空間の離散化と係数行列の取り扱い（Spatial Discretization and Coefficient Matrix）－byFumiya Nozaki</a>中的第38页。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenFOAM的耦合边界处理]]></title>
      <url>/2018/01/04/OpenFOAM%E7%9A%84%E8%80%A6%E5%90%88%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>关于OpenFOAM中耦合边界的具体实现</p>
<a id="more"></a>
<h1 id="OpenFOAM的耦合边界处理"><a href="#OpenFOAM的耦合边界处理" class="headerlink" title="OpenFOAM的耦合边界处理"></a>OpenFOAM的耦合边界处理</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>首先，在计算机里，大量的矩阵其实是稀疏矩阵，而矩阵的表示方式都是非零元素（non-zero elements）和索引（index，即元素所在行列号，本文按照c语言的约定，从0开始）分开的。这是稀疏矩阵算法的特殊性，所以指明OpenFOAM中的矩阵时，需要同时制定非零元素的存放之处和索引的存放之处。</p>
<p>而常见的稀疏矩阵的表示方式有：</p>
<ol>
<li><p>序列对角模式：对于对角阵而言，如果是按照对角顺序储存非零元素，可以无需储存索引；</p>
</li>
<li><p>坐标对角模式：对于对角阵而言，如果没有按照对角顺序储存非零元素，需要一列坐标指定对角元素顺序；</p>
</li>
<li><p>COO坐标模式：有三列数组，一列储存非零元素，一列储存行号，一列储存列号，是最广义可用的稀疏矩阵储存模式，但是往往有信息的冗余；</p>
</li>
<li><p>CSR/CSC压缩行/列模式：一列储存非零元素（先从上到下行号递增，再从左到右列号递增），一列储存行号，一列储存压缩后的列号，这也是OpenFOAM的<code>lduAddress</code>类实际采用的储存格式；</p>
</li>
<li><p>Banded，带状储存模式：对于带状结构，可以采用此种模式，对于一维问题，矩阵一般来说都是带状的，但是对于三维问题，很难是窄带结构的；</p>
</li>
</ol>
<p>实际上，OpenFOAM采用的是一种极为特殊的分割储存的COO模式，常见教材称之为LDU分裂模式，常记为$A=L+D+U$，其中$L,D,U$分别代表矩阵$A$的下三角部分（行号大于列号），对角部分和上三角部分（行号小于列号）。但是其实它远比上述LDU分裂（或者称之为LDU加法分解，注意与矩阵的LU乘法分解的区别）要复杂得多。</p>
<h2 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h2><p>首先引入以下记号和符号：</p>
<ul>
<li><p>$N_i$，第i个处理器中的单元数，$\sum_i {N_i} = N$为单元总数。由于OpenFOAM是cell-center based FVM，所以$N$就是求解的自由度数，也就是待求解变量集合$x$的维度；</p>
<ul>
<li><p>同理，$x$也可以视为各个处理器上待求解变量$x<em>i$的垂直连接（vertical concatenation）$x=x_0||x_1||x_2||x_3||\dots||x</em>{N-1}$</p>
</li>
<li><script type="math/tex; mode=display">
x= \begin{bmatrix} 
    x_0\\
    x_1\\
    \vdots\\
    x_i\\
    \vdots\\
    x_{N-1}
     \end{bmatrix}</script></li>
</ul>
</li>
<li><p>$F_i$为第i个处理器中的总面数（一般等于网格中的owner数），$K_i$为内部面数（一般等于网格中的neighbour数），$P_i$为边界面数（$F_i=K_i+P_i$）</p>
<ul>
<li>但是边界面分为两种，耦合边界（coupled BC, 在OpenFOAM中等价于interface，<code>fvPatch::coupled()</code>返回<code>true</code>）和非耦合边界（普通边界），第i个处理器中的第c号耦合边界的面数记为$ C<em>{i,c}$，第r号普通边界的面数记为$R</em>{i,r}$。</li>
<li>耦合边界和普通边界的相同点和区别在于，他们都有一些面，实现为<code>patchField()</code>，每个面的owner对应的内部单元<code>internalField()</code>，但是普通边界的面外侧没有单元，而耦合边界外侧是它所对应的另一个耦合边界，在实现的时候记为<code>neighbPatch()</code>， <code>neighbPatch</code> 是有内部单元的，这些<code>neighbPatch</code>的内部单元在原耦合边界中实现为<code>patchNeighbourField()</code></li>
<li>有了<code>internalField()</code>和<code>patchNeighbourField()</code>，耦合边界的处理起来很多时候其实就和内部边界面差不多了。</li>
<li>网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。</li>
<li>简单的情况下（没有AMI, ACMI等复杂的边界条件时），整个问题总的面数为$F=\sum<em>i{F_i}-\sum</em>{i}\sum<em>c{C</em>{i,c}}$</li>
</ul>
</li>
<li><p>记总的矩阵为$A$，大小为$N\times N$，按处理器可以分裂为$A<em>i$和耦合系数矩阵$I^C</em>{i,c}$和$B^C_{i,c}$。排列如下：</p>
</li>
<li><script type="math/tex; mode=display">
A= \begin{bmatrix} 
    A_0 & 0\\
   0 &A_1 & 0 \\
 0 &0 & A_2 & 0\\
   0 &\vdots &\vdots &\vdots  \\
   0 &\dots & \dots &\dots &A_i &0 \\
   0 &\dots &\dots &\dots &\dots &A_{N-1}
     \end{bmatrix} + 
O</script><ul>
<li>$A_i=L_i+D_i+U_i+I_i$，采用LDU分裂模式表示。</li>
<li>$O$表示Off diagonal部分，也就是不在LDU分裂模式表示范围内的，和处理器之间的耦合边界的系数</li>
</ul>
</li>
<li><p>源项为$s$，同理也可以按处理器分裂为$s_i$。</p>
</li>
<li><p>总体的方程为$A\cdot x=s$，展开之后应该是$L+D+U$</p>
</li>
<li><p>但是在每个处理器上为$A<em>i\cdot x_i  = A’_i\cdot x-\sum</em>{j}\sum<em>c{B^C</em>{j,c}x^0_j}= s_i $</p>
<ul>
<li>$A<em>i = A’_i+\sum I^N = L_i+D_i+U_i+I^N</em>{i,c}$</li>
<li>网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。</li>
</ul>
</li>
</ul>
<h2 id="各种情况下的矩阵组成"><a href="#各种情况下的矩阵组成" class="headerlink" title="各种情况下的矩阵组成"></a>各种情况下的矩阵组成</h2><h3 id="单一处理器无耦合边界情况"><a href="#单一处理器无耦合边界情况" class="headerlink" title="单一处理器无耦合边界情况"></a>单一处理器无耦合边界情况</h3><p>单一处理器，无耦合边界，仅有普通边界。</p>
<p>此时方程$A\cdot x= s$可分解为：</p>
<p>$[L+(D+\sum_n{I^N_n})+U]\cdot x = s’ + \sum_n{ b^N_n}$</p>
<p>其中$L,D,U$的非零元素为<code>lduMatrix</code>中储存的<code>lower_, diag_, upper_</code>，$D$采用序列对角模式进行索引，没有索引，$L,D$采用COO模式，其索引分别为<code>[lduAddr().lowerAddr(), lduAddr().upperAddr()]</code>和 <code>[lduAddr().upperAddr(), lduAddr().lowerAddr()]</code>；</p>
<p>$I^N<em>n,b^N_n$的非零元素分别为<code>fvMatrix&lt;T&gt;</code>中储存的`internalCoeffs</em>, boundaryCoeffs_<code>，分为若干patch进行索引，其中$I^N_n$是矩阵，采用坐标对角索引模式，对于编号</code>n<code>的索引为：</code>fvm.psi().lduAddr().patchAddr(n)<code>。而$b^N_n$是向量，但并非顺序排列的，也具有索引，索引也是</code>fvm.psi().lduAddr().patchAddr(n)`。</p>
<p>$s’$是内部离散和物理源汇产生的源项；</p>
<h3 id="单一处理器有耦合边界情况"><a href="#单一处理器有耦合边界情况" class="headerlink" title="单一处理器有耦合边界情况"></a>单一处理器有耦合边界情况</h3><p>单一处理器的耦合边界通常为cyclic循环边界条件。</p>
<p>此时方程$A\cdot x= s$可分解为：</p>
<p>$[L+(D+\sum_n{I^N_n}+\sum_c{I^C_c})+U]\cdot x = s’ + \sum_n{b^N_n}+\sum_c{ B^C_c} T_c(x^0)$</p>
<p>其中增加的$I^C<em>c, B^C_c$的非零元素依然是储存为<code>fvMatrix&lt;T&gt;</code>中的`internalCoeffs</em>, boundaryCoeffs_<code>，分为若干patch进行索引，其中$I^C_c$和$I^N_n$没有本质差别，对于编号为n的patch的索引为</code>fvm.psi().lduAddr().patchAddr(n)`。</p>
<p>但 $B^C_c$和 $b^N_n$ 的差别较大，一个是矩阵，一个是向量，二者量纲也不相同！$B^C_c$的索引包括行列两个索引，其中行索引还是<code>fvm.psi().lduAddr().patchAddr(n)</code>，列索引则是<code>neighbPatch().faceCells()</code></p>
<p>而$T_c$ 则是element wise的坐标变换矩算子，对于$x$为标量的情形，$T_c$的作用就是单位阵。</p>
<p>但是$T_c$的作用可以非常复杂，比如fixedJump条件就还涉及到$x^0$ 的平移。（但是此时存在一些问题，比如0场的Amul()作用之后非0。）</p>
<p>$x^0$表示$x$ 的旧值。</p>
<h3 id="多处理器存在耦合边界的情况"><a href="#多处理器存在耦合边界的情况" class="headerlink" title="多处理器存在耦合边界的情况"></a>多处理器存在耦合边界的情况</h3><p>多处理器的耦合边界通常为processor边界条件。</p>
<p>此时方程$A\cdot x= s$可分解在每个处理器i上：</p>
<p>$[L<em>i+(D_i+\sum_n{I^N</em>{i,n}}+\sum<em>c{I^C</em>{i,c}})+U<em>i]\cdot x_i = s’_i + \sum_n{b^N</em>{i,n}}+\sum<em>c{ B^C</em>{i,c}} T_{ji,c}(x^0_j)$</p>
<p>注意，下标中含$i​$的量才储存在processor i的内存中。$x^0_j,j\ne i​$的访问需要通信。</p>
<h2 id="一些奇怪的情形"><a href="#一些奇怪的情形" class="headerlink" title="一些奇怪的情形"></a>一些奇怪的情形</h2><p><code>lduMatrix</code>中定义的<code>Amul</code>, <code>Tmul</code>和<code>residual</code>函数采用的约定和常规数学教科书不同。</p>
<ul>
<li>理论上<code>Amul</code>应该定义了$A\cdot x = (L+D+U)\cdot x ​$操作。实际上它定义的是$[L+D+U]\cdot x - \sum_c{ B^C_c} T_c(x) ​$操作，我猜这样是便于和$s​$源项直接比较。实际上A的定义应该是$L+D+U-  \sum_c{ B^C_c} T_c​$ 。</li>
<li><code>Tmul</code>同理，不过把$B^C_c​$的非零元素换成了$I^C_c​$的非零元素。</li>
<li><code>residual</code>的约定是$s-A\cdot x$，而不是反过来。 </li>
</ul>
<p>另外，<code>fvMatrix</code>和<code>lduMatrix</code>对方程组的定义是有差别的。<code>lduMatrix::solve()</code>求解时给定了$L,D,U$，并传入源项$s$和边界系数$B^C_c$，求解的是$[L+D+U]\cdot x = s+\sum_c{ B^C_c} T_c(x)$。</p>
<p>但<code>fvMatrix::solveSegregated()</code>求解时，会调用<code>lduMatrix::solve()</code>，但在调用之前，它修改了$D=D+\sum_n{I^N_n}+\sum_c{I^C_c}$和$s=s+ \sum_n{b^N_n}$ ，再传入新的源项和边界系数。</p>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>非零元素</th>
<th>含义</th>
<th>索引</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>$D_i$</td>
<td><code>fvm.diag()</code></td>
<td>非边界贡献的对角项</td>
<td>序列对角模式</td>
<td>$N_i$</td>
</tr>
<tr>
<td>$L_i$</td>
<td><code>fvm.lower()</code></td>
<td>非边界贡献的下三角阵</td>
<td>COO模式<code>fvm.lduAddr().[lowerAddr(), upperAddr()]</code></td>
<td>$K_i$</td>
</tr>
<tr>
<td>$U_i$</td>
<td><code>fvm.upper()</code></td>
<td>非边界贡献的上三角阵</td>
<td>COO模式 <code>fvm.lduAddr().[upperAddr(), lowerAddr()]</code></td>
<td>$K_i$</td>
</tr>
<tr>
<td>$s_i$</td>
<td><code>fvm.source()</code></td>
<td>非边界贡献的源项</td>
<td>序列对角模式</td>
<td>$N_i$</td>
</tr>
<tr>
<td>$I^N_{i,r}$</td>
<td><code>fvm.internalCoeffs()[r]</code></td>
<td>第r个普通边界的对角项贡献</td>
<td>坐标对角模式 <code>fvm.psi().lduAddr(). patchAddr(r)</code></td>
<td>$R_{i,r}$</td>
</tr>
<tr>
<td>$I^C_{i,r}$</td>
<td><code>fvm.internalCoeffs()[c]</code></td>
<td>耦合边界的对角项贡献</td>
<td>坐标对角模式 <code>fvm.psi().lduAddr(). patchAddr(c)</code></td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$b^N_{i,n}$</td>
<td><code>fvm.boundaryCoeffs()[r]</code></td>
<td>第r个普通边界的源项贡献</td>
<td>坐标模式向量 <code>fvm.psi().lduAddr().patchAddr(r)</code></td>
<td>$R_{i,r}$</td>
</tr>
<tr>
<td>$B^C<em>{i,c}T</em>{ji,c}(x^0_j)$</td>
<td>计算得到</td>
<td>第c个耦合边界的显式耦合源项贡献</td>
<td>同上，且<code>false==fvm.psi().boundaryField()[patchi].coupled()</code></td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$B^C_{i,c}$</td>
<td><code>fvm.boundaryCoeffs()[c]</code></td>
<td>第c个耦合边界的显式耦合源项贡献的系数</td>
<td>全局行为类似COO模式，行坐标为<code>fvm.psi().lduAddr().patchAddr(c)</code> 列坐标对cyclic BC 为 <code>neighbPatch().faceCells()</code> 对于processor BC 为另一个processor上的<code>fvm.psi().lduAddr().patchAddr(c)</code></td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$x^0_{j}$</td>
<td><code>fvm.psi(). boundaryField(). scalarInterfaces()[c]. patchNeighbourField()</code></td>
<td>第c个耦合边界另一侧的初值</td>
<td>序列对角模式</td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$T_{ji,c}$</td>
<td><code>forwardT()</code></td>
<td>第c个耦合边界的坐标变换算子，通常可表示为一个张量</td>
<td>这是Element Wise的操作。</td>
<td>3*3</td>
</tr>
</tbody>
</table>
</div>
<p>参考<code>http://sssslide.com/www.slideshare.net/fumiyanozaki96/openfoam-32087641</code>中的38页。</p>
<h3 id="fvMatrix-solveSegregated-基本结构"><a href="#fvMatrix-solveSegregated-基本结构" class="headerlink" title="fvMatrix::solveSegregated()基本结构"></a><code>fvMatrix::solveSegregated()</code>基本结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fvMatrix.H +397</span></span><br><span class="line"><span class="comment">//- Solve segregated returning the solution statistics.</span></span><br><span class="line"><span class="comment">//  Use the given solver controls</span></span><br><span class="line">SolverPerformance&lt;Type&gt; solveSegregated(<span class="keyword">const</span> dictionary&amp;); <span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fvMatrixSolve.C +102</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:SolverPerformance&lt;Type&gt; Foam::fvMatrix&lt;Type&gt;::solveSegregated</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; solverControls</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info.masterStream(<span class="keyword">this</span>-&gt;mesh().comm())</span><br><span class="line">            &lt;&lt; <span class="string">"fvMatrix&lt;Type&gt;::solveSegregated"</span></span><br><span class="line">               <span class="string">"(const dictionary&amp; solverControls) : "</span></span><br><span class="line">               <span class="string">"solving fvMatrix&lt;Type&gt;"</span></span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; psi =</span><br><span class="line">       <span class="keyword">const_cast</span>&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp;&gt;(psi_);</span><br><span class="line"></span><br><span class="line">    SolverPerformance&lt;Type&gt; solverPerfVec</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"fvMatrix&lt;Type&gt;::solveSegregated"</span>,</span><br><span class="line">        psi.name()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    scalarField saveDiag(diag());//复制原有的diag_，注意diag_是标量数组</span><br><span class="line"></span><br><span class="line">    Field&lt;Type&gt; source(source_);<span class="comment">//复制原有的source_，注意source_是Field&lt;Type&gt;数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point include the boundary source from the coupled boundaries.</span></span><br><span class="line">    <span class="comment">// This is corrected for the implict part by updateMatrixInterfaces within</span></span><br><span class="line">    <span class="comment">// the component loop.</span></span><br><span class="line">    <span class="comment">//源项中加入非耦合边界项，以及耦合边界项</span></span><br><span class="line">    <span class="comment">// s' = s + boundary source (including coupled BC's contribution)</span></span><br><span class="line">    <span class="comment">//注意这里是加！</span></span><br><span class="line">    addBoundarySource(source); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typename</span> Type::labelType validComponents</span><br><span class="line">    (</span><br><span class="line">        psi.mesh().<span class="keyword">template</span> validComponents&lt;Type&gt;()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (direction cmpt=<span class="number">0</span>; cmpt&lt;Type::nComponents; cmpt++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (validComponents[cmpt] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//有时候有的分量不用求解。比如对称张量，球张量等</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy field and source</span></span><br><span class="line"></span><br><span class="line">        scalarField psiCmpt(psi.primitiveField().component(cmpt));//复制cmpt分量</span><br><span class="line">        <span class="comment">//加入对角项不区分耦合边界和非耦合边界</span></span><br><span class="line">        <span class="comment">//D' = D + I(边界对对角项的贡献)</span></span><br><span class="line">        addBoundaryDiag(diag(), cmpt);</span><br><span class="line"></span><br><span class="line">        scalarField sourceCmpt(source.component(cmpt));//源项cmpt分量</span><br><span class="line"></span><br><span class="line">        FieldField&lt;Field, scalar&gt; bouCoeffsCmpt</span><br><span class="line">        (</span><br><span class="line">            boundaryCoeffs_.component(cmpt)</span><br><span class="line">        );<span class="comment">//边界系数的cmpt分量：非耦合边界是源项，耦合边界是邻侧系数</span></span><br><span class="line"></span><br><span class="line">        FieldField&lt;Field, scalar&gt; intCoeffsCmpt</span><br><span class="line">        (</span><br><span class="line">            internalCoeffs_.component(cmpt)</span><br><span class="line">        );<span class="comment">//边界对角系数的cmpt分量</span></span><br><span class="line"></span><br><span class="line">        lduInterfaceFieldPtrsList interfaces =</span><br><span class="line">            psi.boundaryField().scalarInterfaces(); <span class="comment">//对于非耦合求解器，采用的是scalarInterfaces()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the initMatrixInterfaces and updateMatrixInterfaces to correct</span></span><br><span class="line">        <span class="comment">// bouCoeffsCmpt for the explicit part of the coupled boundary</span></span><br><span class="line">        <span class="comment">// conditions</span></span><br><span class="line">        <span class="comment">//先接收耦合边界发来的消息，然后把耦合边界内侧的值发出去。</span></span><br><span class="line">        <span class="comment">//根据几个实现来看，其实并不更改sourceCmpt</span></span><br><span class="line">        initMatrixInterfaces </span><br><span class="line">        (</span><br><span class="line">            bouCoeffsCmpt, <span class="comment">//用边界系数去update</span></span><br><span class="line">            interfaces, <span class="comment">//用那些耦合边界</span></span><br><span class="line">            psiCmpt, <span class="comment">//耦合时的初值</span></span><br><span class="line">            sourceCmpt, <span class="comment">//结果加入sourceCmpt中</span></span><br><span class="line">            cmpt <span class="comment">//指定cmpt分量</span></span><br><span class="line">        );</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新sourceCmpt的值</span></span><br><span class="line">		<span class="comment">//sourceCmpt -= bouCoeffsCmpt*scalarReceiveBuf_</span></span><br><span class="line">		<span class="comment">// s'' = s' - 耦合边界的源项贡献</span></span><br><span class="line">		<span class="comment">//注意这里是减去</span></span><br><span class="line">		<span class="comment">//此时源项s''中只剩下非耦合边界的贡献了。</span></span><br><span class="line">        updateMatrixInterfaces</span><br><span class="line">        (</span><br><span class="line">            bouCoeffsCmpt, <span class="comment">//用边界系数去update</span></span><br><span class="line">            interfaces,</span><br><span class="line">            psiCmpt,</span><br><span class="line">            sourceCmpt, <span class="comment">//结果加入sourceCmpt中</span></span><br><span class="line">            cmpt</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        solverPerformance solverPerf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Solver call</span></span><br><span class="line">        solverPerf = lduMatrix::solver::New</span><br><span class="line">        (</span><br><span class="line">            psi.name() + pTraits&lt;Type&gt;::componentNames[cmpt],</span><br><span class="line">            *<span class="keyword">this</span>,</span><br><span class="line">            bouCoeffsCmpt,</span><br><span class="line">            intCoeffsCmpt,</span><br><span class="line">            interfaces,</span><br><span class="line">            solverControls</span><br><span class="line">        )-&gt;solve(psiCmpt, sourceCmpt, cmpt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SolverPerformance&lt;Type&gt;::debug)</span><br><span class="line">        &#123;</span><br><span class="line">            solverPerf.print(Info.masterStream(<span class="keyword">this</span>-&gt;mesh().comm()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        solverPerfVec.replace(cmpt, solverPerf);</span><br><span class="line">        solverPerfVec.solverName() = solverPerf.solverName();</span><br><span class="line"></span><br><span class="line">        psi.primitiveFieldRef().replace(cmpt, psiCmpt);</span><br><span class="line">        diag() = saveDiag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    psi.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">    psi.mesh().setSolverPerformance(psi.name(), solverPerfVec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solverPerfVec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> coupledBC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenFOAM的残差定义]]></title>
      <url>/2018/01/04/OpenFOAM%E7%9A%84%E6%AE%8B%E5%B7%AE%E5%AE%9A%E4%B9%89/</url>
      <content type="html"><![CDATA[<p>关于OpenFOAM中残差定义的具体实现</p>
<a id="more"></a>
<h1 id="关于normFactor"><a href="#关于normFactor" class="headerlink" title="关于normFactor"></a>关于<code>normFactor</code></h1><p>根据代码，OpenFOAM求解器输出的标量残差initialResidual为量化的向量$L1$ 模。</p>
<p>定义为:</p>
<script type="math/tex; mode=display">
Res = \frac{|r|_1}{normFactor}= \frac{|s-A\cdot x|_1}{|A\cdot x^0 - A\cdot W  \cdot x^0|_1+|s - A\cdot W\cdot x^0|_1+\epsilon}</script><p>其中$W$是有效权重矩阵</p>
<script type="math/tex; mode=display">
W= \frac 1 N \begin{bmatrix}  
1 & 1 & \dots &1 &1 \\
1 & \vdots & \ddots &\vdots  & 1 \\
1 & \dots & \dots & 1 & 1 \\
\end{bmatrix}_{N\times N} =  \begin{bmatrix}  
1 \\
1 \\
\vdots \\
1\\
1
\end{bmatrix}_{N\times1} \times  \begin{bmatrix}  
\frac 1 N & \frac 1 N & \dots &\frac 1 N &\frac 1 N 
\end{bmatrix} _{1\times N}\\
=S\cdot M</script><p>$S$代表对矩阵行和算子，$M$ 代表对列向量的平均算子。</p>
<p>$\epsilon$是非常小量，OpenFOAM常定义为+1e-20。</p>
<p>向量$L1$模的定义为：$|x|_1= \sum_i{|x_i|}$</p>
<p>但是要做MMS比较需要用到函数的L1模：</p>
<script type="math/tex; mode=display">
|r|_{L1}=\frac{\int_{\Omega}{|r|dx}}{\int_{\Omega}{dx}} \approx \frac{\sum_i{V_i |r|}}{\sum_i V_i}</script><p>与向量$L1$模相比，相差了一个单元体积的权重。</p>
<p>我想这部分解释了为何学术界的文章里残差收敛特别快，而OpenFOAM总是收敛到一定程度就收敛不下去了，因为OpenFOAM的残差采用的normFactor每次都在随$x^0​$变化，随着解的收敛，normFactor在减小，从而导致OpenFOAM输出的残差收敛速度降低。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PCG.C:107</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// --- Calculate normalised residual norm</span></span><br><span class="line">    solverPerf.initialResidual() =</span><br><span class="line">        gSumMag(rA, matrix().mesh().comm()) <span class="comment">//this is the vector L1 norm向量L1模</span></span><br><span class="line">       /normFactor;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//lduMatrixSolver.C:175</span></span><br><span class="line">Foam::scalar Foam::lduMatrix::solver::normFactor</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; psi,</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; source,</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; Apsi,</span><br><span class="line">    scalarField&amp; tmpField</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// --- Calculate A dot reference value of psi</span></span><br><span class="line">    matrix_.sumA(tmpField, interfaceBouCoeffs_, interfaces_); <span class="comment">//tmpField = A*S</span></span><br><span class="line"></span><br><span class="line">    tmpField *= gAverage(psi, matrix_.lduMesh_.comm()); <span class="comment">//tmpField = A*S*M*x0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// normFactor = |A*x0-A*S*M*x0|_1+|s-A*S*M*x0|_1+eps</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        gSum</span><br><span class="line">        (</span><br><span class="line">            (mag(Apsi - tmpField) + mag(source - tmpField))(),</span><br><span class="line">            matrix_.lduMesh_.comm()</span><br><span class="line">        )</span><br><span class="line">      + solverPerformance::small_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At convergence this simpler method is equivalent to the above</span></span><br><span class="line">    <span class="comment">// return 2*gSumMag(source) + solverPerformance::small_;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> coupledBC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/08/09/hello-world/</url>
      <content type="html"><![CDATA[<p>Hello World! </p>
<p>对公式、代码和插入图片进行测试。</p>
<a id="more"></a>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><ul>
<li>行内公式: $e^{\pi i}+1=0$</li>
<li>块公式:</li>
<li><script type="math/tex; mode=display">F=\frac{Gm_1m_2}{r^2}</script></li>
</ul>
<script type="math/tex; mode=display">
F=\frac{Gm_1m_2}{r^2}</script><ul>
<li>关于$\rho$的连续性方程</li>
</ul>
<script type="math/tex; mode=display">
\frac{\partial \rho}{\partial t}+\vec v\cdot\frac{\partial \rho}{\partial x}=0</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight fortran"><figcaption><span>CFL3D主程序中的Setup子程序声明</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">subroutine</span></span> setup(lw,lw2,w,mgwk,wk,nwork,iwk,iwork,itest,</span><br><span class="line">     .                 jtest,ktest,maxbl,mxbli,maxgr,maxseg,nsub1,</span><br><span class="line">     .                 maxxe,intmax,iitot,ncycmax,lwdat,lig,lbg,iovrlp,</span><br><span class="line">     .                 qb,nblock,iviscg,jdimg,kdimg,idimg,utrans,</span><br><span class="line">     .                 vtrans,wtrans,omegax,omegay,omegaz,xorig,</span><br><span class="line">     .                 yorig,zorig,dxmx,dymx,dzmx,dthxmx,dthymx,</span><br><span class="line">     .                 dthzmx,thetax,thetay,thetaz,rfreqt,rfreqr,</span><br><span class="line">     .                 xorig0,yorig0,zorig0,time2,thetaxl,thetayl,</span><br><span class="line">     .                 thetazl,itrans,irotat,idefrm,bcvali,bcvalj,</span><br><span class="line">     .                 bcvalk,nbci0,nbcidim,nbcj0,nbcjdim,</span><br><span class="line">     .                 nbck0,nbckdim,ibcinfo,jbcinfo,kbcinfo,bcfilei,</span><br><span class="line">     .                 bcfilej,bcfilek,ngrid,ncgg,nblg,iemg,inewgg,</span><br><span class="line">     .                 rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,cmxw,cmyw,</span><br><span class="line">     .                 cmzw,n_clcd,clcd,nblocks_clcd,blocks_clcd,</span><br><span class="line">     .                 chdw,swetw,fmdotw,cfttotw,cftmomw,cftpw,</span><br><span class="line">     .                 cftvw,rmstr,nneg,ntr,windex,</span><br><span class="line">     .                 ninter,iindex,nblkpt,dthetxx,dthetyy,dthetzz,</span><br><span class="line">     .                 iibg,kkbg,jjbg,ibcg,dxintg,dyintg,dzintg,iiig,</span><br><span class="line">     .                 jjig,kkig,ibpntsg,iipntsg,mblk2nd,nou,bou,nbuf,</span><br><span class="line">     .                 ibufdim,ireq_qb,igridg,bcfiles,mxbcfil,</span><br><span class="line">     .                 utrnsae,vtrnsae,wtrnsae,omgxae,omgyae,omgzae,</span><br><span class="line">     .                 xorgae,yorgae,zorgae,thtxae,thtyae,thtzae,</span><br><span class="line">     .                 rfrqtae,rfrqrae,icsi,icsf,jcsi,jcsf,</span><br><span class="line">     .                 kcsi,kcsf,freq,gmass,damp,x0,gf0,nmds,maxaes,</span><br><span class="line">     .                 aesrfdat,perturb,islavept,nslave,iskip,jskip,</span><br><span class="line">     .                 kskip,bmat,stm,stmi,gforcn,gforcnm,xxn,</span><br><span class="line">     .                 nsegdfrm,idfrmseg,iaesurf,maxsegdg,nmaster,</span><br><span class="line">     .                 aehist,timekeep,inpl3d,nplots,nplot3d,levelg,</span><br><span class="line">     .                 iadvance,xs,gforcs,xorgae0,yorgae0,zorgae0,</span><br><span class="line">     .                 icouple,lfgm,nblk,limblk,isva,nblelst,</span><br><span class="line">     .                 iskmax,jskmax,kskmax,ue,irdrea,nbli,nummem)</span><br><span class="line">#   ifdef <span class="built_in">CMPLX</span></span><br><span class="line">#   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">use</span> module_kwstm, <span class="keyword">only</span>:kws_init</span><br><span class="line">#   <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<h2 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h2><p>欢迎访问本博客：冰水混合物<br><img src="/images/qr_code_test.jpg" alt="冰水混合物"></p>
]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 公式 </tag>
            
            <tag> 图形 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[OpenFOAM的耦合边界处理]]></title>
      <url>/2018/01/04/OpenFOAM%E7%9A%84%E8%80%A6%E5%90%88%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>关于OpenFOAM中耦合边界的具体实现</p>
<a id="more"></a>
<h1 id="OpenFOAM的耦合边界处理"><a href="#OpenFOAM的耦合边界处理" class="headerlink" title="OpenFOAM的耦合边界处理"></a>OpenFOAM的耦合边界处理</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>首先，在计算机里，大量的矩阵其实是稀疏矩阵，而矩阵的表示方式都是非零元素（non-zero elements）和索引（index，即元素所在行列号，本文按照c语言的约定，从0开始）分开的。这是稀疏矩阵算法的特殊性，所以指明OpenFOAM中的矩阵时，需要同时制定非零元素的存放之处和索引的存放之处。</p>
<p>而常见的稀疏矩阵的表示方式有：</p>
<ol>
<li><p>序列对角模式：对于对角阵而言，如果是按照对角顺序储存非零元素，可以无需储存索引；</p>
</li>
<li><p>坐标对角模式：对于对角阵而言，如果没有按照对角顺序储存非零元素，需要一列坐标指定对角元素顺序；</p>
</li>
<li><p>COO坐标模式：有三列数组，一列储存非零元素，一列储存行号，一列储存列号，是最广义可用的稀疏矩阵储存模式，但是往往有信息的冗余；</p>
</li>
<li><p>CSR/CSC压缩行/列模式：一列储存非零元素（先从上到下行号递增，再从左到右列号递增），一列储存行号，一列储存压缩后的列号，这也是OpenFOAM的<code>lduAddress</code>类实际采用的储存格式；</p>
</li>
<li><p>Banded，带状储存模式：对于带状结构，可以采用此种模式，对于一维问题，矩阵一般来说都是带状的，但是对于三维问题，很难是窄带结构的；</p>
</li>
</ol>
<p>实际上，OpenFOAM采用的是一种极为特殊的分割储存的COO模式，常见教材称之为LDU分裂模式，常记为$A=L+D+U$，其中$L,D,U$分别代表矩阵$A$的下三角部分（行号大于列号），对角部分和上三角部分（行号小于列号）。但是其实它远比上述LDU分裂（或者称之为LDU加法分解，注意与矩阵的LU乘法分解的区别）要复杂得多。</p>
<h2 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h2><p>首先引入以下记号和符号：</p>
<ul>
<li><p>$N_i$，第i个处理器中的单元数，$\sum_i {N_i} = N$为单元总数。由于OpenFOAM是cell-center based FVM，所以$N$就是求解的自由度数，也就是待求解变量集合$x$的维度；</p>
<ul>
<li><p>同理，$x$也可以视为各个处理器上待求解变量$x_i$的垂直连接（vertical concatenation）$x=x_0||x_1||x_2||x<em>3||\dots||x</em>{N-1}$</p>
</li>
<li><p>$$<br>x= \begin{bmatrix} </p>
<pre><code>x_0\\
x_1\\
\vdots\\
x_i\\
\vdots\\
x_{N-1}
 \end{bmatrix}
</code></pre><p>$$</p>
</li>
</ul>
</li>
<li><p>$F_i$为第i个处理器中的总面数（一般等于网格中的owner数），$K_i$为内部面数（一般等于网格中的neighbour数），$P_i$为边界面数（$F_i=K_i+P_i$）</p>
<ul>
<li>但是边界面分为两种，耦合边界（coupled BC, 在OpenFOAM中等价于interface，<code>fvPatch::coupled()</code>返回<code>true</code>）和非耦合边界（普通边界），第i个处理器中的第c号耦合边界的面数记为$ C<em>{i,c}$，第r号普通边界的面数记为$R</em>{i,r}$。</li>
<li>耦合边界和普通边界的相同点和区别在于，他们都有一些面，实现为<code>patchField()</code>，每个面的owner对应的内部单元<code>internalField()</code>，但是普通边界的面外侧没有单元，而耦合边界外侧是它所对应的另一个耦合边界，在实现的时候记为<code>neighbPatch()</code>， <code>neighbPatch</code> 是有内部单元的，这些<code>neighbPatch</code>的内部单元在原耦合边界中实现为<code>patchNeighbourField()</code></li>
<li>有了<code>internalField()</code>和<code>patchNeighbourField()</code>，耦合边界的处理起来很多时候其实就和内部边界面差不多了。</li>
<li>网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。</li>
<li>简单的情况下（没有AMI, ACMI等复杂的边界条件时），整个问题总的面数为$F=\sum_i{F<em>i}-\sum</em>{i}\sum<em>c{C</em>{i,c}}$</li>
</ul>
</li>
<li><p>记总的矩阵为$A$，大小为$N\times N$，按处理器可以分裂为$A<em>i$和耦合系数矩阵$I^C</em>{i,c}$和$B^C_{i,c}$。排列如下：</p>
</li>
<li><p>$$<br>A= \begin{bmatrix} </p>
<pre><code>A_0 &amp; 0\\
</code></pre><p>   0 &amp;A_1 &amp; 0 \<br> 0 &amp;0 &amp; A_2 &amp; 0\<br>   0 &amp;\vdots &amp;\vdots &amp;\vdots  \<br>   0 &amp;\dots &amp; \dots &amp;\dots &amp;A<em>i &amp;0 \<br>   0 &amp;\dots &amp;\dots &amp;\dots &amp;\dots &amp;A</em>{N-1}</p>
<pre><code>\end{bmatrix} + 
</code></pre><p>O<br>$$</p>
<ul>
<li>$A_i=L_i+D_i+U_i+I_i$，采用LDU分裂模式表示。</li>
<li>$O$表示Off diagonal部分，也就是不在LDU分裂模式表示范围内的，和处理器之间的耦合边界的系数</li>
</ul>
</li>
<li><p>源项为$s$，同理也可以按处理器分裂为$s_i$。</p>
</li>
<li><p>总体的方程为$A\cdot x=s$，展开之后应该是$L+D+U$</p>
</li>
<li><p>但是在每个处理器上为$A_i\cdot x_i  = A’<em>i\cdot x-\sum</em>{j}\sum<em>c{B^C</em>{j,c}x^0_j}= s_i $</p>
<ul>
<li>$A_i = A’_i+\sum I^N = L_i+D_i+U<em>i+I^N</em>{i,c}$</li>
<li>网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。</li>
</ul>
</li>
</ul>
<h2 id="各种情况下的矩阵组成"><a href="#各种情况下的矩阵组成" class="headerlink" title="各种情况下的矩阵组成"></a>各种情况下的矩阵组成</h2><h3 id="单一处理器无耦合边界情况"><a href="#单一处理器无耦合边界情况" class="headerlink" title="单一处理器无耦合边界情况"></a>单一处理器无耦合边界情况</h3><p>单一处理器，无耦合边界，仅有普通边界。</p>
<p>此时方程$A\cdot x= s$可分解为：</p>
<p>$[L+(D+\sum_n{I^N_n})+U]\cdot x = s’ + \sum_n{ b^N_n}$</p>
<p>其中$L,D,U$的非零元素为<code>lduMatrix</code>中储存的<code>lower_, diag_, upper_</code>，$D$采用序列对角模式进行索引，没有索引，$L,D$采用COO模式，其索引分别为<code>[lduAddr().lowerAddr(), lduAddr().upperAddr()]</code>和 <code>[lduAddr().upperAddr(), lduAddr().lowerAddr()]</code>；</p>
<p>$I^N_n,b^N<em>n$的非零元素分别为<code>fvMatrix&lt;T&gt;</code>中储存的`internalCoeffs</em>, boundaryCoeffs_<code>，分为若干patch进行索引，其中$I^N_n$是矩阵，采用坐标对角索引模式，对于编号</code>n<code>的索引为：</code>fvm.psi().lduAddr().patchAddr(n)<code>。而$b^N_n$是向量，但并非顺序排列的，也具有索引，索引也是</code>fvm.psi().lduAddr().patchAddr(n)`。</p>
<p>$s’$是内部离散和物理源汇产生的源项；</p>
<h3 id="单一处理器有耦合边界情况"><a href="#单一处理器有耦合边界情况" class="headerlink" title="单一处理器有耦合边界情况"></a>单一处理器有耦合边界情况</h3><p>单一处理器的耦合边界通常为cyclic循环边界条件。</p>
<p>此时方程$A\cdot x= s$可分解为：</p>
<p>$[L+(D+\sum_n{I^N_n}+\sum_c{I^C_c})+U]\cdot x = s’ + \sum_n{b^N_n}+\sum_c{ B^C_c} T_c(x^0)$</p>
<p>其中增加的$I^C_c, B^C<em>c$的非零元素依然是储存为<code>fvMatrix&lt;T&gt;</code>中的`internalCoeffs</em>, boundaryCoeffs_<code>，分为若干patch进行索引，其中$I^C_c$和$I^N_n$没有本质差别，对于编号为n的patch的索引为</code>fvm.psi().lduAddr().patchAddr(n)`。</p>
<p>但 $B^C_c$和 $b^N_n$ 的差别较大，一个是矩阵，一个是向量，二者量纲也不相同！$B^C_c$的索引包括行列两个索引，其中行索引还是<code>fvm.psi().lduAddr().patchAddr(n)</code>，列索引则是<code>neighbPatch().faceCells()</code></p>
<p>而$T_c$ 则是element wise的坐标变换矩算子，对于$x$为标量的情形，$T_c$的作用就是单位阵。</p>
<p>但是$T_c$的作用可以非常复杂，比如fixedJump条件就还涉及到$x^0$ 的平移。（但是此时存在一些问题，比如0场的Amul()作用之后非0。）</p>
<p>$x^0$表示$x$ 的旧值。</p>
<h3 id="多处理器存在耦合边界的情况"><a href="#多处理器存在耦合边界的情况" class="headerlink" title="多处理器存在耦合边界的情况"></a>多处理器存在耦合边界的情况</h3><p>多处理器的耦合边界通常为processor边界条件。</p>
<p>此时方程$A\cdot x= s$可分解在每个处理器i上：</p>
<p>$[L_i+(D_i+\sum<em>n{I^N</em>{i,n}}+\sum<em>c{I^C</em>{i,c}})+U_i]\cdot x_i = s’_i + \sum<em>n{b^N</em>{i,n}}+\sum<em>c{ B^C</em>{i,c}} T_{ji,c}(x^0_j)$</p>
<p>注意，下标中含$i​$的量才储存在processor i的内存中。$x^0_j,j\ne i​$的访问需要通信。</p>
<h2 id="一些奇怪的情形"><a href="#一些奇怪的情形" class="headerlink" title="一些奇怪的情形"></a>一些奇怪的情形</h2><p><code>lduMatrix</code>中定义的<code>Amul</code>, <code>Tmul</code>和<code>residual</code>函数采用的约定和常规数学教科书不同。</p>
<ul>
<li>理论上<code>Amul</code>应该定义了$A\cdot x = (L+D+U)\cdot x ​$操作。实际上它定义的是$[L+D+U]\cdot x - \sum_c{ B^C_c} T_c(x) ​$操作，我猜这样是便于和$s​$源项直接比较。实际上A的定义应该是$L+D+U-  \sum_c{ B^C_c} T_c​$ 。</li>
<li><code>Tmul</code>同理，不过把$B^C_c​$的非零元素换成了$I^C_c​$的非零元素。</li>
<li><code>residual</code>的约定是$s-A\cdot x$，而不是反过来。 </li>
</ul>
<p>另外，<code>fvMatrix</code>和<code>lduMatrix</code>对方程组的定义是有差别的。<code>lduMatrix::solve()</code>求解时给定了$L,D,U$，并传入源项$s$和边界系数$B^C_c$，求解的是$[L+D+U]\cdot x = s+\sum_c{ B^C_c} T_c(x)$。</p>
<p>但<code>fvMatrix::solveSegregated()</code>求解时，会调用<code>lduMatrix::solve()</code>，但在调用之前，它修改了$D=D+\sum_n{I^N_n}+\sum_c{I^C_c}$和$s=s+ \sum_n{b^N_n}$ ，再传入新的源项和边界系数。</p>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><table>
<thead>
<tr>
<th>符号</th>
<th>非零元素</th>
<th>含义</th>
<th>索引</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>$D_i$</td>
<td><code>fvm.diag()</code></td>
<td>非边界贡献的对角项</td>
<td>序列对角模式</td>
<td>$N_i$</td>
</tr>
<tr>
<td>$L_i$</td>
<td><code>fvm.lower()</code></td>
<td>非边界贡献的下三角阵</td>
<td>COO模式<code>fvm.lduAddr().[lowerAddr(), upperAddr()]</code></td>
<td>$K_i$</td>
</tr>
<tr>
<td>$U_i$</td>
<td><code>fvm.upper()</code></td>
<td>非边界贡献的上三角阵</td>
<td>COO模式 <code>fvm.lduAddr().[upperAddr(), lowerAddr()]</code></td>
<td>$K_i$</td>
</tr>
<tr>
<td>$s_i$</td>
<td><code>fvm.source()</code></td>
<td>非边界贡献的源项</td>
<td>序列对角模式</td>
<td>$N_i$</td>
</tr>
<tr>
<td>$I^N_{i,r}$</td>
<td><code>fvm.internalCoeffs()[r]</code></td>
<td>第r个普通边界的对角项贡献</td>
<td>坐标对角模式 <code>fvm.psi().lduAddr(). patchAddr(r)</code></td>
<td>$R_{i,r}$</td>
</tr>
<tr>
<td>$I^C_{i,r}$</td>
<td><code>fvm.internalCoeffs()[c]</code></td>
<td>耦合边界的对角项贡献</td>
<td>坐标对角模式 <code>fvm.psi().lduAddr(). patchAddr(c)</code></td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$b^N_{i,n}$</td>
<td><code>fvm.boundaryCoeffs()[r]</code></td>
<td>第r个普通边界的源项贡献</td>
<td>坐标模式向量 <code>fvm.psi().lduAddr().patchAddr(r)</code></td>
<td>$R_{i,r}$</td>
</tr>
<tr>
<td>$B^C<em>{i,c}T</em>{ji,c}(x^0_j)$</td>
<td>计算得到</td>
<td>第c个耦合边界的显式耦合源项贡献</td>
<td>同上，且<code>false==fvm.psi().boundaryField()[patchi].coupled()</code></td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$B^C_{i,c}$</td>
<td><code>fvm.boundaryCoeffs()[c]</code></td>
<td>第c个耦合边界的显式耦合源项贡献的系数</td>
<td>全局行为类似COO模式，行坐标为<code>fvm.psi().lduAddr().patchAddr(c)</code> 列坐标对cyclic BC 为 <code>neighbPatch().faceCells()</code> 对于processor BC 为另一个processor上的<code>fvm.psi().lduAddr().patchAddr(c)</code></td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$x^0_{j}$</td>
<td><code>fvm.psi(). boundaryField(). scalarInterfaces()[c]. patchNeighbourField()</code></td>
<td>第c个耦合边界另一侧的初值</td>
<td>序列对角模式</td>
<td>$C_{i,c}$</td>
</tr>
<tr>
<td>$T_{ji,c}$</td>
<td><code>forwardT()</code></td>
<td>第c个耦合边界的坐标变换算子，通常可表示为一个张量</td>
<td>这是Element Wise的操作。</td>
<td>3*3</td>
</tr>
</tbody>
</table>
<p>参考<code>http://sssslide.com/www.slideshare.net/fumiyanozaki96/openfoam-32087641</code>中的38页。</p>
<h3 id="fvMatrix-solveSegregated-基本结构"><a href="#fvMatrix-solveSegregated-基本结构" class="headerlink" title="fvMatrix::solveSegregated()基本结构"></a><code>fvMatrix::solveSegregated()</code>基本结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fvMatrix.H +397</span></span><br><span class="line"><span class="comment">//- Solve segregated returning the solution statistics.</span></span><br><span class="line"><span class="comment">//  Use the given solver controls</span></span><br><span class="line">SolverPerformance&lt;Type&gt; solveSegregated(<span class="keyword">const</span> dictionary&amp;); <span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fvMatrixSolve.C +102</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:SolverPerformance&lt;Type&gt; Foam::fvMatrix&lt;Type&gt;::solveSegregated</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; solverControls</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info.masterStream(<span class="keyword">this</span>-&gt;mesh().comm())</span><br><span class="line">            &lt;&lt; <span class="string">"fvMatrix&lt;Type&gt;::solveSegregated"</span></span><br><span class="line">               <span class="string">"(const dictionary&amp; solverControls) : "</span></span><br><span class="line">               <span class="string">"solving fvMatrix&lt;Type&gt;"</span></span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; psi =</span><br><span class="line">       <span class="keyword">const_cast</span>&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp;&gt;(psi_);</span><br><span class="line"></span><br><span class="line">    SolverPerformance&lt;Type&gt; solverPerfVec</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"fvMatrix&lt;Type&gt;::solveSegregated"</span>,</span><br><span class="line">        psi.name()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    scalarField saveDiag(diag());//复制原有的diag_，注意diag_是标量数组</span><br><span class="line"></span><br><span class="line">    Field&lt;Type&gt; source(source_);<span class="comment">//复制原有的source_，注意source_是Field&lt;Type&gt;数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point include the boundary source from the coupled boundaries.</span></span><br><span class="line">    <span class="comment">// This is corrected for the implict part by updateMatrixInterfaces within</span></span><br><span class="line">    <span class="comment">// the component loop.</span></span><br><span class="line">    <span class="comment">//源项中加入非耦合边界项，以及耦合边界项</span></span><br><span class="line">    <span class="comment">// s' = s + boundary source (including coupled BC's contribution)</span></span><br><span class="line">    <span class="comment">//注意这里是加！</span></span><br><span class="line">    addBoundarySource(source); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typename</span> Type::labelType validComponents</span><br><span class="line">    (</span><br><span class="line">        psi.mesh().<span class="keyword">template</span> validComponents&lt;Type&gt;()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (direction cmpt=<span class="number">0</span>; cmpt&lt;Type::nComponents; cmpt++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (validComponents[cmpt] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//有时候有的分量不用求解。比如对称张量，球张量等</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy field and source</span></span><br><span class="line"></span><br><span class="line">        scalarField psiCmpt(psi.primitiveField().component(cmpt));//复制cmpt分量</span><br><span class="line">        <span class="comment">//加入对角项不区分耦合边界和非耦合边界</span></span><br><span class="line">        <span class="comment">//D' = D + I(边界对对角项的贡献)</span></span><br><span class="line">        addBoundaryDiag(diag(), cmpt);</span><br><span class="line"></span><br><span class="line">        scalarField sourceCmpt(source.component(cmpt));//源项cmpt分量</span><br><span class="line"></span><br><span class="line">        FieldField&lt;Field, scalar&gt; bouCoeffsCmpt</span><br><span class="line">        (</span><br><span class="line">            boundaryCoeffs_.component(cmpt)</span><br><span class="line">        );<span class="comment">//边界系数的cmpt分量：非耦合边界是源项，耦合边界是邻侧系数</span></span><br><span class="line"></span><br><span class="line">        FieldField&lt;Field, scalar&gt; intCoeffsCmpt</span><br><span class="line">        (</span><br><span class="line">            internalCoeffs_.component(cmpt)</span><br><span class="line">        );<span class="comment">//边界对角系数的cmpt分量</span></span><br><span class="line"></span><br><span class="line">        lduInterfaceFieldPtrsList interfaces =</span><br><span class="line">            psi.boundaryField().scalarInterfaces(); <span class="comment">//对于非耦合求解器，采用的是scalarInterfaces()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the initMatrixInterfaces and updateMatrixInterfaces to correct</span></span><br><span class="line">        <span class="comment">// bouCoeffsCmpt for the explicit part of the coupled boundary</span></span><br><span class="line">        <span class="comment">// conditions</span></span><br><span class="line">        <span class="comment">//先接收耦合边界发来的消息，然后把耦合边界内侧的值发出去。</span></span><br><span class="line">        <span class="comment">//根据几个实现来看，其实并不更改sourceCmpt</span></span><br><span class="line">        initMatrixInterfaces </span><br><span class="line">        (</span><br><span class="line">            bouCoeffsCmpt, <span class="comment">//用边界系数去update</span></span><br><span class="line">            interfaces, <span class="comment">//用那些耦合边界</span></span><br><span class="line">            psiCmpt, <span class="comment">//耦合时的初值</span></span><br><span class="line">            sourceCmpt, <span class="comment">//结果加入sourceCmpt中</span></span><br><span class="line">            cmpt <span class="comment">//指定cmpt分量</span></span><br><span class="line">        );</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新sourceCmpt的值</span></span><br><span class="line">		<span class="comment">//sourceCmpt -= bouCoeffsCmpt*scalarReceiveBuf_</span></span><br><span class="line">		<span class="comment">// s'' = s' - 耦合边界的源项贡献</span></span><br><span class="line">		<span class="comment">//注意这里是减去</span></span><br><span class="line">		<span class="comment">//此时源项s''中只剩下非耦合边界的贡献了。</span></span><br><span class="line">        updateMatrixInterfaces</span><br><span class="line">        (</span><br><span class="line">            bouCoeffsCmpt, <span class="comment">//用边界系数去update</span></span><br><span class="line">            interfaces,</span><br><span class="line">            psiCmpt,</span><br><span class="line">            sourceCmpt, <span class="comment">//结果加入sourceCmpt中</span></span><br><span class="line">            cmpt</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        solverPerformance solverPerf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Solver call</span></span><br><span class="line">        solverPerf = lduMatrix::solver::New</span><br><span class="line">        (</span><br><span class="line">            psi.name() + pTraits&lt;Type&gt;::componentNames[cmpt],</span><br><span class="line">            *<span class="keyword">this</span>,</span><br><span class="line">            bouCoeffsCmpt,</span><br><span class="line">            intCoeffsCmpt,</span><br><span class="line">            interfaces,</span><br><span class="line">            solverControls</span><br><span class="line">        )-&gt;solve(psiCmpt, sourceCmpt, cmpt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SolverPerformance&lt;Type&gt;::debug)</span><br><span class="line">        &#123;</span><br><span class="line">            solverPerf.print(Info.masterStream(<span class="keyword">this</span>-&gt;mesh().comm()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        solverPerfVec.replace(cmpt, solverPerf);</span><br><span class="line">        solverPerfVec.solverName() = solverPerf.solverName();</span><br><span class="line"></span><br><span class="line">        psi.primitiveFieldRef().replace(cmpt, psiCmpt);</span><br><span class="line">        diag() = saveDiag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    psi.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">    psi.mesh().setSolverPerformance(psi.name(), solverPerfVec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solverPerfVec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> coupledBC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenFOAM的残差定义]]></title>
      <url>/2018/01/04/OpenFOAM%E7%9A%84%E6%AE%8B%E5%B7%AE%E5%AE%9A%E4%B9%89/</url>
      <content type="html"><![CDATA[<p>关于OpenFOAM中残差定义的具体实现</p>
<a id="more"></a>
<h1 id="关于normFactor"><a href="#关于normFactor" class="headerlink" title="关于normFactor"></a>关于<code>normFactor</code></h1><p>根据代码，OpenFOAM求解器输出的标量残差initialResidual为量化的向量$L1$ 模。</p>
<p>定义为:</p>
<p>$$<br>Res = \frac{|r|_1}{normFactor}= \frac{|s-A\cdot x|_1}{|A\cdot x^0 - A\cdot W  \cdot x^0|_1+|s - A\cdot W\cdot x^0|_1+\epsilon}<br>$$</p>
<p>其中 $W$ 是有效权重矩阵</p>
<p>$$<br>W= \frac 1 N \begin{bmatrix}<br>1 &amp; 1 &amp; \dots &amp;1 &amp;1 \<br>1 &amp; \vdots &amp; \ddots &amp;\vdots  &amp; 1 \<br>1 &amp; \dots &amp; \dots &amp; 1 &amp; 1 \<br>\end{bmatrix}<em>{N\times N} =  \begin{bmatrix}<br>1 \<br>1 \<br>\vdots \<br>1\<br>1<br>\end{bmatrix}</em>{N\times 1} \times  \begin{bmatrix}<br>\frac 1 N &amp; \frac 1 N &amp; \dots &amp;\frac 1 N &amp;\frac 1 N<br>\end{bmatrix} _{1\times N}\<br>=[行和算子]\times[向量平均算子]<br>$$</p>
<p>$\epsilon$ 是非常小量，OpenFOAM常定义为+1e-20。</p>
<p>向量$L1$模的定义为：$|x|_1= \sum_i{|x_i|}$</p>
<p>但是要做MMS比较需要用到函数的L1模：<br>$$<br>|r|<em>{L1}=\frac{\int</em>{\Omega}{|r|dx}}{\int_{\Omega}{dx}} \approx \frac{\sum_i{V_i |r|}}{\sum_i V_i}<br>$$<br>与向量$L1$模相比，相差了一个单元体积的权重。</p>
<p>我想这部分解释了为何学术界的文章里残差收敛特别快，而OpenFOAM总是收敛到一定程度就收敛不下去了，因为OpenFOAM的残差采用的normFactor每次都在随$x^0$变化，随着解的收敛，normFactor在减小，从而导致OpenFOAM输出的残差收敛速度降低。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PCG.C:107</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// --- Calculate normalised residual norm</span></span><br><span class="line">    solverPerf.initialResidual() =</span><br><span class="line">        gSumMag(rA, matrix().mesh().comm())</span><br><span class="line">       /normFactor;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//lduMatrixSolver.C:175</span></span><br><span class="line">Foam::scalar Foam::lduMatrix::solver::normFactor</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; psi,</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; source,</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; Apsi,</span><br><span class="line">    scalarField&amp; tmpField</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// --- Calculate A dot reference value of psi</span></span><br><span class="line">    matrix_.sumA(tmpField, interfaceBouCoeffs_, interfaces_);</span><br><span class="line"></span><br><span class="line">    tmpField *= gAverage(psi, matrix_.lduMesh_.comm());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        gSum</span><br><span class="line">        (</span><br><span class="line">            (mag(Apsi - tmpField) + mag(source - tmpField))(),</span><br><span class="line">            matrix_.lduMesh_.comm()</span><br><span class="line">        )</span><br><span class="line">      + solverPerformance::small_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At convergence this simpler method is equivalent to the above</span></span><br><span class="line">    <span class="comment">// return 2*gSumMag(source) + solverPerformance::small_;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> OpenFOAM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenFOAM </tag>
            
            <tag> coupledBC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/08/09/hello-world/</url>
      <content type="html"><![CDATA[<p>Hello World! </p>
<p>对公式、代码和插入图片进行测试。</p>
<a id="more"></a>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><ul>
<li>行内公式: $e^{\pi i}+1=0$</li>
<li>块公式:</li>
<li>$$F=\frac{Gm_1m_2}{r^2}$$</li>
</ul>
<p>$$<br>F=\frac{Gm_1m_2}{r^2}<br>$$</p>
<ul>
<li>关于$\rho$的连续性方程</li>
</ul>
<p>$$<br>\frac{\partial \rho}{\partial t}+\vec v\cdot\frac{\partial \rho}{\partial x}=0<br>$$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight fortran"><figcaption><span>CFL3D主程序中的Setup子程序声明</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">subroutine</span></span> setup(lw,lw2,w,mgwk,wk,nwork,iwk,iwork,itest,</span><br><span class="line">     .                 jtest,ktest,maxbl,mxbli,maxgr,maxseg,nsub1,</span><br><span class="line">     .                 maxxe,intmax,iitot,ncycmax,lwdat,lig,lbg,iovrlp,</span><br><span class="line">     .                 qb,nblock,iviscg,jdimg,kdimg,idimg,utrans,</span><br><span class="line">     .                 vtrans,wtrans,omegax,omegay,omegaz,xorig,</span><br><span class="line">     .                 yorig,zorig,dxmx,dymx,dzmx,dthxmx,dthymx,</span><br><span class="line">     .                 dthzmx,thetax,thetay,thetaz,rfreqt,rfreqr,</span><br><span class="line">     .                 xorig0,yorig0,zorig0,time2,thetaxl,thetayl,</span><br><span class="line">     .                 thetazl,itrans,irotat,idefrm,bcvali,bcvalj,</span><br><span class="line">     .                 bcvalk,nbci0,nbcidim,nbcj0,nbcjdim,</span><br><span class="line">     .                 nbck0,nbckdim,ibcinfo,jbcinfo,kbcinfo,bcfilei,</span><br><span class="line">     .                 bcfilej,bcfilek,ngrid,ncgg,nblg,iemg,inewgg,</span><br><span class="line">     .                 rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,cmxw,cmyw,</span><br><span class="line">     .                 cmzw,n_clcd,clcd,nblocks_clcd,blocks_clcd,</span><br><span class="line">     .                 chdw,swetw,fmdotw,cfttotw,cftmomw,cftpw,</span><br><span class="line">     .                 cftvw,rmstr,nneg,ntr,windex,</span><br><span class="line">     .                 ninter,iindex,nblkpt,dthetxx,dthetyy,dthetzz,</span><br><span class="line">     .                 iibg,kkbg,jjbg,ibcg,dxintg,dyintg,dzintg,iiig,</span><br><span class="line">     .                 jjig,kkig,ibpntsg,iipntsg,mblk2nd,nou,bou,nbuf,</span><br><span class="line">     .                 ibufdim,ireq_qb,igridg,bcfiles,mxbcfil,</span><br><span class="line">     .                 utrnsae,vtrnsae,wtrnsae,omgxae,omgyae,omgzae,</span><br><span class="line">     .                 xorgae,yorgae,zorgae,thtxae,thtyae,thtzae,</span><br><span class="line">     .                 rfrqtae,rfrqrae,icsi,icsf,jcsi,jcsf,</span><br><span class="line">     .                 kcsi,kcsf,freq,gmass,damp,x0,gf0,nmds,maxaes,</span><br><span class="line">     .                 aesrfdat,perturb,islavept,nslave,iskip,jskip,</span><br><span class="line">     .                 kskip,bmat,stm,stmi,gforcn,gforcnm,xxn,</span><br><span class="line">     .                 nsegdfrm,idfrmseg,iaesurf,maxsegdg,nmaster,</span><br><span class="line">     .                 aehist,timekeep,inpl3d,nplots,nplot3d,levelg,</span><br><span class="line">     .                 iadvance,xs,gforcs,xorgae0,yorgae0,zorgae0,</span><br><span class="line">     .                 icouple,lfgm,nblk,limblk,isva,nblelst,</span><br><span class="line">     .                 iskmax,jskmax,kskmax,ue,irdrea,nbli,nummem)</span><br><span class="line">#   ifdef <span class="built_in">CMPLX</span></span><br><span class="line">#   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">use</span> module_kwstm, <span class="keyword">only</span>:kws_init</span><br><span class="line">#   <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<h2 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h2><p>欢迎访问本博客：冰水混合物<br><img src="/images/qr_code_test.jpg" alt="冰水混合物"></p>
]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 公式 </tag>
            
            <tag> 图形 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>

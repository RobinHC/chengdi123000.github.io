<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OpenFOAM在docker中的使用]]></title>
    <url>%2F2018%2F01%2F05%2FOpenFOAM%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[利用docker在windows中使用OpenFOAM。利用共享文件夹功能在windows中进行前后处理。 OpenFOAM在docker中的使用操作系统：windows 10 Pro/Home docker版本：docker有两种，一种是社区版Community Edition，一种是商业版。我们采用免费的社区版，但是由于docker本质上是一个Linux程序，所以即使是社区版，在windows下使用时需要首先用虚拟机运行一个Linux平台（通常是Moby Linux），根据虚拟机平台的不同，也是有两种选择： docker for windows，这个版本是主推的版本，可以利用windows10的HyperV虚拟化平台。但是windows10需要Pro版或者旗舰版才能开启HyperV虚拟化。 docker toolbox，这个版本是比较老的，利用的是Oracle的VirtualBox进行虚拟化，但是可以在Windows10 Home版本下运行，或者在windows 7等老版本操作系统下运行。 两个版本我都会介绍到。 docker 安装下面分别介绍docker for windows和docker toolbox的安装 docker for windows对于可以开启HyperV虚拟化的windows 10 Pro或者旗舰版而言，docker for windows是最好的选择。 网址: https://www.docker.com/ 下载: Docker for Windows Installer.exe 版本: Docker version 17.09.0, 社区版中的最新稳定版。 安装指南: https://docs.docker.com/docker-for-windows/ 一路点击OK,next 安装完成后，运行Docker for Windows. 它会花费一些时间启动 docker engine. 等提示启动完成后，右键单击开始按钮，选择”Windows Powershell”。打开Powershell命令行。（用cmd也是可以的） 运行如下命令： 1234567891011121314151617181920212223242526272829303132333435docker --version## Docker version 17.09.0-ce, build afdb6d4docker-compose --version## docker-compose version 1.16.1, build 6d1ac219docker-machine --version## docker-machine.exe version 0.12.2, build 9371605docker run hello-world## ## Hello from Docker!## This message shows that your installation appears to be working correctly.## ## To generate this message, Docker took the following steps:## 1. The Docker client contacted the Docker daemon.## 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.## (amd64)## 3. The Docker daemon created a new container from that image which runs the## executable that produces the output you are currently reading.## 4. The Docker daemon streamed that output to the Docker client, which sent it## to your terminal.## ## To try something more ambitious, you can run an Ubuntu container with:## $ docker run -it ubuntu bash## ## Share images, automate workflows, and more with a free Docker ID:## https://cloud.docker.com/## ## For more examples and ideas, visit:## https://docs.docker.com/engine/userguide/docker ps -a## CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES## 32a621d46d34 hello-world "/hello" 24 seconds ago Exited (0) 23 seconds ago clever_agnesidocker rm 32a621d46d34 #change it to your container ID## 32a621d46d34 docker ps -a## CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES docker toolbox安装网址和安装指南：https://docs.docker.com/toolbox/toolbox_install_windows/ 下载：https://download.docker.com/win/stable/DockerToolbox.exe 这个docker toolbox也要求至少是64位的windows 操作系统，win 7 以上。并且在BIOS中开启了虚拟化（Virtualization，和HyperV不同） docker toolbox安装时会安装VirtualBox。 安装完成后会出现以下几个图标： 双击“Docker Quickestart”可以启动MSYS2 ，用如下命令进行测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243docker --version#Docker version 17.10.0-ce, build f4ffd25#docker-compose --version#docker-compose version 1.16.1, build 6d1ac219#docker-machine --version#docker-machine.exe version 0.13.0, build 9ba6da9#docker run hello-world##Hello from Docker!#This message shows that your installation appears to be working correctly.##To generate this message, Docker took the following steps:# 1. The Docker client contacted the Docker daemon.# 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.# (amd64)# 3. The Docker daemon created a new container from that image which runs the# executable that produces the output you are currently reading.# 4. The Docker daemon streamed that output to the Docker client, which sent it# to your terminal.##To try something more ambitious, you can run an Ubuntu container with:# $ docker run -it ubuntu bash##Share images, automate workflows, and more with a free Docker ID:# https://cloud.docker.com/##For more examples and ideas, visit:# https://docs.docker.com/engine/userguide/##docker ps -a#CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES#a8e15cba83b6 hello-world "/hello" 10 seconds ago Exited (0) 10 seconds ago musing_hamilton#docker rm a8e15cba83b6#a8e15cba83b6#docker ps -a#CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES# 至此，docker就安装好了。 下载OpenFOAM的 docker image很简单： 12345678docker pull openfoamplus/of_v1706_centos73 # OF+# or# docker pull openfoam/openfoam5-paraview54 # OF5# list imagesdocker image ls# REPOSITORY TAG IMAGE ID CREATED SIZE# hello-world latest f2a91732366c 6 weeks ago 1.85kB# openfoamplus/of_v1706_centos73 latest 9b81f0cd518b 6 months ago 1.76GB 映射共享文件夹并测试OpenFOAM共享文件夹是与docker交换数据最方便的工具。windows下的docker可以通过虚拟机的功能配合docker工具自带的映射功能，实现映射共享文件夹的功能。为了避免问题过于复杂化，本文的共享文件夹位于C:\Users\cheng目录之下，这样可以避免对虚拟机的大幅变动。如果需要共享位于其他位置的文件夹，使用docker toolbox的请参考How to use a directory outside C:\Users with Docker Toolbox on Windows，使用docker for windows的可以参考：Docker on Windows — Mounting Host Directories docker for windows: 采用powershell 12345678910111213141516171819202122232425cd c:\Users\chengmkdir OpenFOAMdocker run \-i -t \--name myOFplus_1706 \-v "/c/Users/cheng/OpenFOAM:/home/ofuser/OpenFOAM" \openfoamplus/of_v1706_centos73 \bash# 下面的代码在进入bash后输入su ofusercd mkdir -p $FOAM_RUNruncp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity ../Allrun# 想要临时退出，但不中断执行# 按Ctrl+p, Ctrl+q## 再次进入docker image的bashdocker attach myOFplus_1706 docker toolbox: 采用“Docker Quickestart”启动的仿bash界面。 123456789101112131415161718192021cd c:\Users\chengmkdir OpenFOAMdocker run \-i -t \--name myOFplus_1706 \-v "/c/Users/cheng/OpenFOAM:/home/ofuser/OpenFOAM" \openfoamplus/of_v1706_centos73 \bash# 下面的代码在进入bash后输入su ofusercd mkdir -p $FOAM_RUNruncp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity ../Allrun# 想要临时退出，但不中断执行# 按Ctrl+p, Ctrl+q docker 中的OpenFOAM环境以下命令在docker中可以查看出安装环境 1234567891011121314151617181920212223242526272829303132cd clearecho $WM_PROJECT_DIR #OpenFOAM安装位置#/opt/OpenFOAM/OpenFOAM-v1706echo $WM_THIRD_PARTY_DIR #第三方软件文件夹位置#/opt/OpenFOAM/ThirdParty-v1706echo $WM_PROJECT_VERSION#v1706echo $WM_PROJECT_USER_DIR #OpenFOAM用户文件夹位置#/home/ofuser/OpenFOAM/ofuser-v1706echo $WM_OPTIONS #编译配置#linux64GccDPInt32Opt #编译配置为# linux64:64位Linux版本# DP:双精度# Gcc: GCC编译器# Int32: 32位整型# Opt: 性能优化版本，没有调试信息。g++ --version #采用的编译器版本#g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-11)#Copyright (C) 2015 Free Software Foundation, Inc.#This is free software; see the source for copying conditions. There is NO#warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.#mpirun --version # 采用的mpi版本#mpirun (Open MPI) 1.10.4##Report bugs to http://www.open-mpi.org/community/help/ 后处理可以用paraview 进行后处理 paraview 安装 网址：https://www.paraview.org/ 下载地址：https://www.paraview.org/paraview-downloads/download.php?submit=Download&amp;version=v5.4&amp;type=binary&amp;os=Windows&amp;downloadFile=ParaView-5.4.1-Qt5-OpenGL2-Windows-64bit.exe 版本：最新稳定版：5.4.1 安装很容易。 由于windows版本的paraview没有编译安装OpenFOAM专用reader，所以需要在shell中，位于算例文件目录下用touch a.foam建立一个文件（一些教程中的touch a.OpenFOAM无效）。 后处理结果如下：]]></content>
      <categories>
        <category>OpenFOAM</category>
      </categories>
      <tags>
        <tag>OpenFOAM</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenFOAM输出完整矩阵]]></title>
    <url>%2F2018%2F01%2F04%2FOpenFOAM%E8%BE%93%E5%87%BA%E5%AE%8C%E6%95%B4%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[输出单CPU算例带耦合边界条件的fvScalarMatrix中的完整矩阵信息。 OpenFOAM输出完整矩阵背景OpenFOAM采用的特殊矩阵模式导致输出完整矩阵很困难。本文尝试解决的是输出单CPU算例带耦合边界条件的问题中的fvScalarMatrix的问题。 首先，需要限定是单CPU，否则可能存在CPU间的processorFvPatch耦合界面边界条件，fvScalarMatrix将无法包含所有的边界条件相关的源项。 其次耦合边界条件中仅支持cyclic类边界条件，jumpCyclic边界条件可能存在线性代数上的一致性问题，暂时不考虑。 再次，输出限于fvScalarMatrix，fvVectorMatrix的情况类似，但是涉及到更加复杂一些的操作。 最后，采用cnpy库输出为numpy支持的npy或npz格式，便于进一步分析，具体模式为COO模式，同时cnpy还提供了npy2mat, npz2mat, mat2npz等工具用于与matlab交换数据。 代码需要首先安装一个cnpy的小程序库，用于生成numpy和matlab可以直接读取的文件。 网址: https://github.com/rogersce/cnpy 命令行: 12345678910111213141516# 在root账户下yum install cmake git -y# `su ofuser`到ofuser账户， check toolscmake --versiong++ --versiongit --version# clone, configure, build and installgit clone https://github.com/rogersce/cnpy.git cnpy_srccd cnpy_srcmkdir buildcd buildcmake .. -DENABLE_STATIC=ON -DCMAKE_INSTALL_PREFIX=$HOME/lib/cnpymake make install 实际程序中#include如下代码：dumpFvScalarMatrix.H 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#pragma once#include "fvCFD.H"#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include"cyclicFvPatch.H"#include"cnpy.h"/**path: 想要储存的文件名Eqn: fvScalarMatrix 的常量引用*/void dumpFvScalarMatrix( const fvScalarMatrix&amp; Eqn,fileName filepath)&#123; if (filepath.hasExt() == false) &#123; filepath = filepath.ext("npz"); &#125; const label nCells = Eqn.diag().size(); const label nFaces = Eqn.lower().size(); const scalar* const __restrict__ diagPtr = Eqn.diag().begin(); const label* const __restrict__ uPtr = Eqn.lduAddr().upperAddr().begin(); const label* const __restrict__ lPtr = Eqn.lduAddr().lowerAddr().begin(); const scalar* const __restrict__ upperPtr = Eqn.upper().begin(); const scalar* const __restrict__ lowerPtr = Eqn.lower().begin(); std::vector&lt;scalar&gt; AA(nCells+2*nFaces); std::vector&lt;scalar&gt; S(nCells); std::vector&lt;scalar&gt; x0(nCells); std::vector&lt;label&gt; JR(nCells+2*nFaces); std::vector&lt;label&gt; JC(nCells+2*nFaces); auto psi=Eqn.psi(); auto s=Eqn.source(); // diag for(label cell=0;cell&lt;nCells;cell++) &#123; AA[cell]=diagPtr[cell]; JR[cell]=cell; JC[cell]=cell; S[cell]=s[cell]; x0[cell]=psi[cell]; &#125; //Upper for(label face=0;face&lt;nFaces;face++) &#123; AA[face+nCells]=upperPtr[face]; JR[face+nCells]=uPtr[face]; JC[face+nCells]=lPtr[face]; &#125; //Lower for(label face=0;face&lt;nFaces;face++) &#123; AA[face+nCells+nFaces]=lowerPtr[face]; JR[face+nCells+nFaces]=lPtr[face]; JC[face+nCells+nFaces]=uPtr[face]; &#125; //边界贡献 auto I = Eqn.internalCoeffs(); auto B = Eqn.boundaryCoeffs(); auto psib = psi.boundaryField(); forAll(psib,patchI) &#123; const fvPatch&amp; pp = psib[patchI].patch(); if(pp.coupled()) //耦合边界 &#123; if(isA&lt;cyclicFvPatch&gt;(pp)) //只处理循环边界 &#123; const cyclicFvPatch&amp; pnp= (refCast&lt;const cyclicFvPatch&gt;(pp)).neighbPatch(); forAll(pp,faceI) &#123; label cellI = pp.faceCells()[faceI]; label cellJ = pnp.faceCells()[faceI]; AA[cellI] += I[patchI][faceI]; AA.push_back(B[patchI][faceI]); JR.push_back(cellI); JC.push_back(cellJ); &#125; &#125; else //其他非循环边界的耦合边界，统统报错退出 &#123; SeriousError&lt;&lt;"Only support cyclic coupled BC!"&lt;&lt;endl; &#125; &#125; else //非耦合边界 &#123; forAll(pp,faceI) &#123; label cellI = pp.faceCells()[faceI]; AA[cellI] += I[patchI][faceI]; S[cellI] += B[patchI][faceI]; &#125; &#125; &#125; cnpy::npz_save(filepath,"AA",&amp;AA[0],&#123;AA.size()&#125;,"w"); cnpy::npz_save(filepath,"JR",&amp;JR[0],&#123;JR.size()&#125;,"a"); cnpy::npz_save(filepath,"JC",&amp;JC[0],&#123;JC.size()&#125;,"a"); cnpy::npz_save(filepath,"S",&amp;S[0],&#123;S.size()&#125;,"a"); cnpy::npz_save(filepath,"x0",&amp;x0[0],&#123;x0.size()&#125;,"a"); return;&#125; 测试基于 icoFoam的源代码建立myIcoFoam123456789101112131415161718192021runcd ..mkdir -p applications/solverscd applications/solvers# I put my solver here.pwd # /OF/OpenFOAM/-v1706/applications/solverscp $FOAM_SOLVERS/incompressible/icoFoam -r .mv icoFoam myIcoFoamcd myIcoFoammv icoFoam.C myIcoFoam.Csed -i s/icoFoam/myIcoFoam/g myIcoFoam.Csed -i s/icoFoam/myIcoFoam/g Make/filessed -i s/FOAM_APPBIN/FOAM_USER_APPBIN Make/files# 编译wmake# runruncd cavityfoamJob -screen myIcoFoam 修改myIcoFoam的代码，输出pEqn的矩阵12345678910111213141516171819//myIcoFoam.C#include "fvCFD.H"#include "pisoControl.H"//添加#include "dumpFvScalarMatrix.H"... if (piso.finalNonOrthogonalIter()) &#123; phi = phiHbyA - pEqn.flux(); &#125; //添加 if (runTime.timeIndex()==2) &#123; Info&lt;&lt; "TimeIndex = 2, output matrix pEqn"&lt;&lt;endl; dumpFvScalarMatrix(pEqn,"Eqn.npz"); &#125;... Make/options 文件： 123456789EXE_INC = \ -I$(LIB_SRC)/finiteVolume/lnInclude \ -I$(LIB_SRC)/meshTools/lnInclude \ -I$(HOME)/lib/cnpy/include EXE_LIBS = \ -lfiniteVolume \ -lmeshTools \ -Wl,-rpath -Wl,$(HOME)/lib/cnpy/lib -L$(HOME)/lib/cnpy/lib -lcnpy python后处理python需要安装scipy，在docker下比较简单的方法是到root账户下进行安装 1234567891011# 进root账户cdcurl "https://bootstrap.pypa.io/get-pip.py" -o "get-pip.py"python get-pip.pypip install scipy# 回到ofuser账户su ofusercdpython -c "import scipy as sp;print(sp.version.version)"# 1.0.0 python后处理代码： 12345678910import numpy as npimport scipy as spdata = np.load("Eqn.npz")AA,JR,JC,S,x0 = data['AA'],data['JR'],data['JC'],data['S'],data['x0']N = S.shape[0]from scipy.sparse import coo_matrixsm = coo_matrix((AA,(JR,JC)),shape=(N,N))m = sm.toarray()print m.shape 参考 OpenFOAM －空間の離散化と係数行列の取り扱い（Spatial Discretization and Coefficient Matrix）－byFumiya Nozaki中的第38页。]]></content>
      <categories>
        <category>OpenFOAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenFOAM的耦合边界处理]]></title>
    <url>%2F2018%2F01%2F04%2FOpenFOAM%E7%9A%84%E8%80%A6%E5%90%88%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于OpenFOAM中耦合边界的具体实现 OpenFOAM的耦合边界处理摘要首先，在计算机里，大量的矩阵其实是稀疏矩阵，而矩阵的表示方式都是非零元素（non-zero elements）和索引（index，即元素所在行列号，本文按照c语言的约定，从0开始）分开的。这是稀疏矩阵算法的特殊性，所以指明OpenFOAM中的矩阵时，需要同时制定非零元素的存放之处和索引的存放之处。 而常见的稀疏矩阵的表示方式有： 序列对角模式：对于对角阵而言，如果是按照对角顺序储存非零元素，可以无需储存索引； 坐标对角模式：对于对角阵而言，如果没有按照对角顺序储存非零元素，需要一列坐标指定对角元素顺序； COO坐标模式：有三列数组，一列储存非零元素，一列储存行号，一列储存列号，是最广义可用的稀疏矩阵储存模式，但是往往有信息的冗余； CSR/CSC压缩行/列模式：一列储存非零元素（先从上到下行号递增，再从左到右列号递增），一列储存行号，一列储存压缩后的列号，这也是OpenFOAM的lduAddress类实际采用的储存格式； Banded，带状储存模式：对于带状结构，可以采用此种模式，对于一维问题，矩阵一般来说都是带状的，但是对于三维问题，很难是窄带结构的； 实际上，OpenFOAM采用的是一种极为特殊的分割储存的COO模式，常见教材称之为LDU分裂模式，常记为$A=L+D+U$，其中$L,D,U$分别代表矩阵$A$的下三角部分（行号大于列号），对角部分和上三角部分（行号小于列号）。但是其实它远比上述LDU分裂（或者称之为LDU加法分解，注意与矩阵的LU乘法分解的区别）要复杂得多。 记号首先引入以下记号和符号： $N_i$，第i个处理器中的单元数，$\sum_i {N_i} = N$为单元总数。由于OpenFOAM是cell-center based FVM，所以$N$就是求解的自由度数，也就是待求解变量集合$x$的维度； 同理，$x$也可以视为各个处理器上待求解变量$xi$的垂直连接（vertical concatenation）$x=x_0||x_1||x_2||x_3||\dots||x{N-1}$ x= \begin{bmatrix} x_0\\ x_1\\ \vdots\\ x_i\\ \vdots\\ x_{N-1} \end{bmatrix} $F_i$为第i个处理器中的总面数（一般等于网格中的owner数），$K_i$为内部面数（一般等于网格中的neighbour数），$P_i$为边界面数（$F_i=K_i+P_i$） 但是边界面分为两种，耦合边界（coupled BC, 在OpenFOAM中等价于interface，fvPatch::coupled()返回true）和非耦合边界（普通边界），第i个处理器中的第c号耦合边界的面数记为$ C{i,c}$，第r号普通边界的面数记为$R{i,r}$。 耦合边界和普通边界的相同点和区别在于，他们都有一些面，实现为patchField()，每个面的owner对应的内部单元internalField()，但是普通边界的面外侧没有单元，而耦合边界外侧是它所对应的另一个耦合边界，在实现的时候记为neighbPatch()， neighbPatch 是有内部单元的，这些neighbPatch的内部单元在原耦合边界中实现为patchNeighbourField() 有了internalField()和patchNeighbourField()，耦合边界的处理起来很多时候其实就和内部边界面差不多了。 网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。 简单的情况下（没有AMI, ACMI等复杂的边界条件时），整个问题总的面数为$F=\sumi{F_i}-\sum{i}\sumc{C{i,c}}$ 记总的矩阵为$A$，大小为$N\times N$，按处理器可以分裂为$Ai$和耦合系数矩阵$I^C{i,c}$和$B^C_{i,c}$。排列如下： A= \begin{bmatrix} A_0 & 0\\ 0 &A_1 & 0 \\ 0 &0 & A_2 & 0\\ 0 &\vdots &\vdots &\vdots \\ 0 &\dots & \dots &\dots &A_i &0 \\ 0 &\dots &\dots &\dots &\dots &A_{N-1} \end{bmatrix} + O $A_i=L_i+D_i+U_i+I_i$，采用LDU分裂模式表示。 $O$表示Off diagonal部分，也就是不在LDU分裂模式表示范围内的，和处理器之间的耦合边界的系数 源项为$s$，同理也可以按处理器分裂为$s_i$。 总体的方程为$A\cdot x=s$，展开之后应该是$L+D+U$ 但是在每个处理器上为$Ai\cdot x_i = A’_i\cdot x-\sum{j}\sumc{B^C{j,c}x^0_j}= s_i $ $Ai = A’_i+\sum I^N = L_i+D_i+U_i+I^N{i,c}$ 网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。 各种情况下的矩阵组成单一处理器无耦合边界情况单一处理器，无耦合边界，仅有普通边界。 此时方程$A\cdot x= s$可分解为： $[L+(D+\sum_n{I^N_n})+U]\cdot x = s’ + \sum_n{ b^N_n}$ 其中$L,D,U$的非零元素为lduMatrix中储存的lower_, diag_, upper_，$D$采用序列对角模式进行索引，没有索引，$L,D$采用COO模式，其索引分别为[lduAddr().lowerAddr(), lduAddr().upperAddr()]和 [lduAddr().upperAddr(), lduAddr().lowerAddr()]； $I^Nn,b^N_n$的非零元素分别为fvMatrix&lt;T&gt;中储存的`internalCoeffs, boundaryCoeffs_，分为若干patch进行索引，其中$I^N_n$是矩阵，采用坐标对角索引模式，对于编号n的索引为：fvm.psi().lduAddr().patchAddr(n)。而$b^N_n$是向量，但并非顺序排列的，也具有索引，索引也是fvm.psi().lduAddr().patchAddr(n)`。 $s’$是内部离散和物理源汇产生的源项； 单一处理器有耦合边界情况单一处理器的耦合边界通常为cyclic循环边界条件。 此时方程$A\cdot x= s$可分解为： $[L+(D+\sum_n{I^N_n}+\sum_c{I^C_c})+U]\cdot x = s’ + \sum_n{b^N_n}+\sum_c{ B^C_c} T_c(x^0)$ 其中增加的$I^Cc, B^C_c$的非零元素依然是储存为fvMatrix&lt;T&gt;中的`internalCoeffs, boundaryCoeffs_，分为若干patch进行索引，其中$I^C_c$和$I^N_n$没有本质差别，对于编号为n的patch的索引为fvm.psi().lduAddr().patchAddr(n)`。 但 $B^C_c$和 $b^N_n$ 的差别较大，一个是矩阵，一个是向量，二者量纲也不相同！$B^C_c$的索引包括行列两个索引，其中行索引还是fvm.psi().lduAddr().patchAddr(n)，列索引则是neighbPatch().faceCells() 而$T_c$ 则是element wise的坐标变换矩算子，对于$x$为标量的情形，$T_c$的作用就是单位阵。 但是$T_c$的作用可以非常复杂，比如fixedJump条件就还涉及到$x^0$ 的平移。（但是此时存在一些问题，比如0场的Amul()作用之后非0。） $x^0$表示$x$ 的旧值。 多处理器存在耦合边界的情况多处理器的耦合边界通常为processor边界条件。 此时方程$A\cdot x= s$可分解在每个处理器i上： $[Li+(D_i+\sum_n{I^N{i,n}}+\sumc{I^C{i,c}})+Ui]\cdot x_i = s’_i + \sum_n{b^N{i,n}}+\sumc{ B^C{i,c}} T_{ji,c}(x^0_j)$ 注意，下标中含$i​$的量才储存在processor i的内存中。$x^0_j,j\ne i​$的访问需要通信。 一些奇怪的情形lduMatrix中定义的Amul, Tmul和residual函数采用的约定和常规数学教科书不同。 理论上Amul应该定义了$A\cdot x = (L+D+U)\cdot x ​$操作。实际上它定义的是$[L+D+U]\cdot x - \sum_c{ B^C_c} T_c(x) ​$操作，我猜这样是便于和$s​$源项直接比较。实际上A的定义应该是$L+D+U- \sum_c{ B^C_c} T_c​$ 。 Tmul同理，不过把$B^C_c​$的非零元素换成了$I^C_c​$的非零元素。 residual的约定是$s-A\cdot x$，而不是反过来。 另外，fvMatrix和lduMatrix对方程组的定义是有差别的。lduMatrix::solve()求解时给定了$L,D,U$，并传入源项$s$和边界系数$B^C_c$，求解的是$[L+D+U]\cdot x = s+\sum_c{ B^C_c} T_c(x)$。 但fvMatrix::solveSegregated()求解时，会调用lduMatrix::solve()，但在调用之前，它修改了$D=D+\sum_n{I^N_n}+\sum_c{I^C_c}$和$s=s+ \sum_n{b^N_n}$ ，再传入新的源项和边界系数。 符号表 符号 非零元素 含义 索引 大小 $D_i$ fvm.diag() 非边界贡献的对角项 序列对角模式 $N_i$ $L_i$ fvm.lower() 非边界贡献的下三角阵 COO模式fvm.lduAddr().[lowerAddr(), upperAddr()] $K_i$ $U_i$ fvm.upper() 非边界贡献的上三角阵 COO模式 fvm.lduAddr().[upperAddr(), lowerAddr()] $K_i$ $s_i$ fvm.source() 非边界贡献的源项 序列对角模式 $N_i$ $I^N_{i,r}$ fvm.internalCoeffs()[r] 第r个普通边界的对角项贡献 坐标对角模式 fvm.psi().lduAddr(). patchAddr(r) $R_{i,r}$ $I^C_{i,r}$ fvm.internalCoeffs()[c] 耦合边界的对角项贡献 坐标对角模式 fvm.psi().lduAddr(). patchAddr(c) $C_{i,c}$ $b^N_{i,n}$ fvm.boundaryCoeffs()[r] 第r个普通边界的源项贡献 坐标模式向量 fvm.psi().lduAddr().patchAddr(r) $R_{i,r}$ $B^C{i,c}T{ji,c}(x^0_j)$ 计算得到 第c个耦合边界的显式耦合源项贡献 同上，且false==fvm.psi().boundaryField()[patchi].coupled() $C_{i,c}$ $B^C_{i,c}$ fvm.boundaryCoeffs()[c] 第c个耦合边界的显式耦合源项贡献的系数 全局行为类似COO模式，行坐标为fvm.psi().lduAddr().patchAddr(c) 列坐标对cyclic BC 为 neighbPatch().faceCells() 对于processor BC 为另一个processor上的fvm.psi().lduAddr().patchAddr(c) $C_{i,c}$ $x^0_{j}$ fvm.psi(). boundaryField(). scalarInterfaces()[c]. patchNeighbourField() 第c个耦合边界另一侧的初值 序列对角模式 $C_{i,c}$ $T_{ji,c}$ forwardT() 第c个耦合边界的坐标变换算子，通常可表示为一个张量 这是Element Wise的操作。 3*3 参考http://sssslide.com/www.slideshare.net/fumiyanozaki96/openfoam-32087641中的38页。 fvMatrix::solveSegregated()基本结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132// fvMatrix.H +397//- Solve segregated returning the solution statistics.// Use the given solver controlsSolverPerformance&lt;Type&gt; solveSegregated(const dictionary&amp;); //声明// fvMatrixSolve.C +102template&lt;class Type&gt;Foam::SolverPerformance&lt;Type&gt; Foam::fvMatrix&lt;Type&gt;::solveSegregated( const dictionary&amp; solverControls)&#123; if (debug) &#123; Info.masterStream(this-&gt;mesh().comm()) &lt;&lt; "fvMatrix&lt;Type&gt;::solveSegregated" "(const dictionary&amp; solverControls) : " "solving fvMatrix&lt;Type&gt;" &lt;&lt; endl; &#125; GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; psi = const_cast&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp;&gt;(psi_); SolverPerformance&lt;Type&gt; solverPerfVec ( "fvMatrix&lt;Type&gt;::solveSegregated", psi.name() ); scalarField saveDiag(diag());//复制原有的diag_，注意diag_是标量数组 Field&lt;Type&gt; source(source_);//复制原有的source_，注意source_是Field&lt;Type&gt;数组 // At this point include the boundary source from the coupled boundaries. // This is corrected for the implict part by updateMatrixInterfaces within // the component loop. //源项中加入非耦合边界项，以及耦合边界项 // s' = s + boundary source (including coupled BC's contribution) //注意这里是加！ addBoundarySource(source); typename Type::labelType validComponents ( psi.mesh().template validComponents&lt;Type&gt;() ); for (direction cmpt=0; cmpt&lt;Type::nComponents; cmpt++) &#123; if (validComponents[cmpt] == -1) continue; //有时候有的分量不用求解。比如对称张量，球张量等 // copy field and source scalarField psiCmpt(psi.primitiveField().component(cmpt));//复制cmpt分量 //加入对角项不区分耦合边界和非耦合边界 //D' = D + I(边界对对角项的贡献) addBoundaryDiag(diag(), cmpt); scalarField sourceCmpt(source.component(cmpt));//源项cmpt分量 FieldField&lt;Field, scalar&gt; bouCoeffsCmpt ( boundaryCoeffs_.component(cmpt) );//边界系数的cmpt分量：非耦合边界是源项，耦合边界是邻侧系数 FieldField&lt;Field, scalar&gt; intCoeffsCmpt ( internalCoeffs_.component(cmpt) );//边界对角系数的cmpt分量 lduInterfaceFieldPtrsList interfaces = psi.boundaryField().scalarInterfaces(); //对于非耦合求解器，采用的是scalarInterfaces() // Use the initMatrixInterfaces and updateMatrixInterfaces to correct // bouCoeffsCmpt for the explicit part of the coupled boundary // conditions //先接收耦合边界发来的消息，然后把耦合边界内侧的值发出去。 //根据几个实现来看，其实并不更改sourceCmpt initMatrixInterfaces ( bouCoeffsCmpt, //用边界系数去update interfaces, //用那些耦合边界 psiCmpt, //耦合时的初值 sourceCmpt, //结果加入sourceCmpt中 cmpt //指定cmpt分量 ); //更新sourceCmpt的值 //sourceCmpt -= bouCoeffsCmpt*scalarReceiveBuf_ // s'' = s' - 耦合边界的源项贡献 //注意这里是减去 //此时源项s''中只剩下非耦合边界的贡献了。 updateMatrixInterfaces ( bouCoeffsCmpt, //用边界系数去update interfaces, psiCmpt, sourceCmpt, //结果加入sourceCmpt中 cmpt ); solverPerformance solverPerf; // Solver call solverPerf = lduMatrix::solver::New ( psi.name() + pTraits&lt;Type&gt;::componentNames[cmpt], *this, bouCoeffsCmpt, intCoeffsCmpt, interfaces, solverControls )-&gt;solve(psiCmpt, sourceCmpt, cmpt); if (SolverPerformance&lt;Type&gt;::debug) &#123; solverPerf.print(Info.masterStream(this-&gt;mesh().comm())); &#125; solverPerfVec.replace(cmpt, solverPerf); solverPerfVec.solverName() = solverPerf.solverName(); psi.primitiveFieldRef().replace(cmpt, psiCmpt); diag() = saveDiag; &#125; psi.correctBoundaryConditions(); psi.mesh().setSolverPerformance(psi.name(), solverPerfVec); return solverPerfVec;&#125;]]></content>
      <categories>
        <category>OpenFOAM</category>
      </categories>
      <tags>
        <tag>OpenFOAM</tag>
        <tag>coupledBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenFOAM的残差定义]]></title>
    <url>%2F2018%2F01%2F04%2FOpenFOAM%E7%9A%84%E6%AE%8B%E5%B7%AE%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[关于OpenFOAM中残差定义的具体实现 关于normFactor根据代码，OpenFOAM求解器输出的标量残差initialResidual为量化的向量$L1$ 模。 定义为: Res = \frac{|r|_1}{normFactor}= \frac{|s-A\cdot x|_1}{|A\cdot x^0 - A\cdot W \cdot x^0|_1+|s - A\cdot W\cdot x^0|_1+\epsilon}其中$W$是有效权重矩阵 W= \frac 1 N \begin{bmatrix} 1 & 1 & \dots &1 &1 \\ 1 & \vdots & \ddots &\vdots & 1 \\ 1 & \dots & \dots & 1 & 1 \\ \end{bmatrix}_{N\times N} = \begin{bmatrix} 1 \\ 1 \\ \vdots \\ 1\\ 1 \end{bmatrix}_{N\times1} \times \begin{bmatrix} \frac 1 N & \frac 1 N & \dots &\frac 1 N &\frac 1 N \end{bmatrix} _{1\times N}\\ =S\cdot M$S$代表对矩阵行和算子，$M$ 代表对列向量的平均算子。 $\epsilon$是非常小量，OpenFOAM常定义为+1e-20。 向量$L1$模的定义为：$|x|_1= \sum_i{|x_i|}$ 但是要做MMS比较需要用到函数的L1模： |r|_{L1}=\frac{\int_{\Omega}{|r|dx}}{\int_{\Omega}{dx}} \approx \frac{\sum_i{V_i |r|}}{\sum_i V_i}与向量$L1$模相比，相差了一个单元体积的权重。 我想这部分解释了为何学术界的文章里残差收敛特别快，而OpenFOAM总是收敛到一定程度就收敛不下去了，因为OpenFOAM的残差采用的normFactor每次都在随$x^0​$变化，随着解的收敛，normFactor在减小，从而导致OpenFOAM输出的残差收敛速度降低。 1234567891011121314151617181920212223242526272829303132333435//PCG.C:107... // --- Calculate normalised residual norm solverPerf.initialResidual() = gSumMag(rA, matrix().mesh().comm()) //this is the vector L1 norm向量L1模 /normFactor;...//lduMatrixSolver.C:175Foam::scalar Foam::lduMatrix::solver::normFactor( const scalarField&amp; psi, const scalarField&amp; source, const scalarField&amp; Apsi, scalarField&amp; tmpField) const&#123; // --- Calculate A dot reference value of psi matrix_.sumA(tmpField, interfaceBouCoeffs_, interfaces_); //tmpField = A*S tmpField *= gAverage(psi, matrix_.lduMesh_.comm()); //tmpField = A*S*M*x0 // normFactor = |A*x0-A*S*M*x0|_1+|s-A*S*M*x0|_1+eps return gSum ( (mag(Apsi - tmpField) + mag(source - tmpField))(), matrix_.lduMesh_.comm() ) + solverPerformance::small_; // At convergence this simpler method is equivalent to the above // return 2*gSumMag(source) + solverPerformance::small_;&#125;]]></content>
      <categories>
        <category>OpenFOAM</category>
      </categories>
      <tags>
        <tag>OpenFOAM</tag>
        <tag>coupledBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello World! 对公式、代码和插入图片进行测试。 测试公式 行内公式: $e^{\pi i}+1=0$ 块公式: F=\frac{Gm_1m_2}{r^2} F=\frac{Gm_1m_2}{r^2} 关于$\rho$的连续性方程 \frac{\partial \rho}{\partial t}+\vec v\cdot\frac{\partial \rho}{\partial x}=0代码CFL3D主程序中的Setup子程序声明1234567891011121314151617181920212223242526272829303132333435 subroutine setup(lw,lw2,w,mgwk,wk,nwork,iwk,iwork,itest, . jtest,ktest,maxbl,mxbli,maxgr,maxseg,nsub1, . maxxe,intmax,iitot,ncycmax,lwdat,lig,lbg,iovrlp, . qb,nblock,iviscg,jdimg,kdimg,idimg,utrans, . vtrans,wtrans,omegax,omegay,omegaz,xorig, . yorig,zorig,dxmx,dymx,dzmx,dthxmx,dthymx, . dthzmx,thetax,thetay,thetaz,rfreqt,rfreqr, . xorig0,yorig0,zorig0,time2,thetaxl,thetayl, . thetazl,itrans,irotat,idefrm,bcvali,bcvalj, . bcvalk,nbci0,nbcidim,nbcj0,nbcjdim, . nbck0,nbckdim,ibcinfo,jbcinfo,kbcinfo,bcfilei, . bcfilej,bcfilek,ngrid,ncgg,nblg,iemg,inewgg, . rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,cmxw,cmyw, . cmzw,n_clcd,clcd,nblocks_clcd,blocks_clcd, . chdw,swetw,fmdotw,cfttotw,cftmomw,cftpw, . cftvw,rmstr,nneg,ntr,windex, . ninter,iindex,nblkpt,dthetxx,dthetyy,dthetzz, . iibg,kkbg,jjbg,ibcg,dxintg,dyintg,dzintg,iiig, . jjig,kkig,ibpntsg,iipntsg,mblk2nd,nou,bou,nbuf, . ibufdim,ireq_qb,igridg,bcfiles,mxbcfil, . utrnsae,vtrnsae,wtrnsae,omgxae,omgyae,omgzae, . xorgae,yorgae,zorgae,thtxae,thtyae,thtzae, . rfrqtae,rfrqrae,icsi,icsf,jcsi,jcsf, . kcsi,kcsf,freq,gmass,damp,x0,gf0,nmds,maxaes, . aesrfdat,perturb,islavept,nslave,iskip,jskip, . kskip,bmat,stm,stmi,gforcn,gforcnm,xxn, . nsegdfrm,idfrmseg,iaesurf,maxsegdg,nmaster, . aehist,timekeep,inpl3d,nplots,nplot3d,levelg, . iadvance,xs,gforcs,xorgae0,yorgae0,zorgae0, . icouple,lfgm,nblk,limblk,isva,nblelst, . iskmax,jskmax,kskmax,ue,irdrea,nbli,nummem)# ifdef CMPLX# else use module_kwstm, only:kws_init# endif 贴图欢迎访问本博客：冰水混合物]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>公式</tag>
        <tag>图形</tag>
        <tag>测试</tag>
      </tags>
  </entry>
</search>

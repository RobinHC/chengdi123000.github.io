<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FEniCS在docker中的使用]]></title>
    <url>%2F2018%2F01%2F07%2FFENICS%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[FEniCS在docker中的使用 FEniCS在docker中的使用有限元是计算方法里很重要的一部分，目前有限元软件很多，不开源的像ANSYS, ABAQUS, Nastran, COMSOL都非常强大，开源的详见比较列表1。 开源的FEM里有几个比较有意思： FEniCS 是FEM解PDE的程序包，学术货，语言层次很高级，流程上应用了代码自动生成技术。 Code-Aster是法国货，法国电力公司EDF开发的，所以有的代码注释是用法语写的，偏向结构和热机械分析。 Deal II是密歇根大学的开发的，官方教程比较齐全，并行能到了147k核。 Firedrake，FEM解PDE的程序包，和FEniCS有合作（2015 Wilkinson奖，DOLFIN-adjoint项目），更新，更现代软件工程化。 1. FEM-compare-table &#8617; 个人觉得FENICS更好玩一些。 FEniCS的结构FENICS的结构 术语 FEniCS: Finite Element nice Computational Software，关于这个名词参考网页2 DOLFIN: C++/Python库，Anders Logg 和Johan Hoffman写的，用于描述网格、求解器和双线性形式。 FIAT: Finite element Automatic Tabulator, Python库，自动生成基函数表，但只针对区间、三角形和四面体。 mshr: FEniCS的网格生成模块。只能生成三角网格。 dijitso: python模块，用于即时生成动态链接库（.so, .dll） Bamboo: FEniCS的自动化测试系统。 FFC: FEniCS Form Compiler, 代码生成软件包，可以生成DOLFIN可以调用的底层代码； UFL: Unified Form Language，FFC的输入的语言格式，一种特定领域的语言（domain specific language, DSL）。 UFC: Unified Form-assembly Code，一个c++界面，可以利用底层函数组装有限元的变分形式，2014年2月起已经被废弃，并被FFC取代。 Instant: python模块，可以嵌入c/c++代码，但是它在2017.2版本之后就退休（retire）了。 Dorsal: 一个编译FEniCS的脚本集合，已退休，由cmake取代。 FEATool: Finite Element Analysis multiphysics Toolbox，基于Matlab/Octave的有限元分析环境，外部接口包括网格（DistMesh, gmsh, triangle）和求解器（FeatFlow, FEniCS）。 NumFOCUS: 是美国的一个非盈利组织（ 所谓501(c)(3)组织，免税），致力于促进世界级创新开源的科学计算。 2. Origin of the name “FEniCS” &#8617; FEniCS的docker安装安装docker不详叙，可参考OpenFOAM在docker中的使用中的前面部分。 启动docker engine服务之后，在Docker Quickstart Terminal或者powershell中输入命令： 12345678910mkdir fenicscd fenics// -ti: 分配tty和进行交互（interaction）// -v: 映射文件夹$(pwd)到docker 镜像中的/home/fenics/shared// -w: docker镜像中的运行目录为/home/fenics/shared// quay.io是docker 镜像服务商// 如果是单纯下载镜像，可以运行：// docker pull quay.io/fenicsproject/stabledocker run -ti -v $(pwd):/home/fenics/shared -w /home/fenics/shared quay.io/fenicsproject/stable:current 然后就自动下载安装好了。并且进入了如下shell界面： 更详细的使用可以参考官网的容器教程：3 3. FEniCS in Docker &#8617; FEniCS在docker中使用最简单版生成以下文件： my-code.py 1234567from dolfin import *print("Running FEniCS...")mesh = UnitSquareMesh(10, 10)V = FunctionSpace(mesh, "P", 1)u = interpolate(Expression('1 + x[0]*x[0] + 2*x[1]*x[1]', degree=2), V)with XDMFFile("f.xdmf") as f: f.write(u) 由于进行了文件夹映射，所以可以直接放到$(pwd)中 ，运行： 1234567891011121314151617181920212223242526272829cat my-code.py# from dolfin import *# print("Running FEniCS...")# mesh = UnitSquareMesh(10, 10)# V = FunctionSpace(mesh, "P", 1)# u = interpolate(Constant(1.0), V)# with XDMFFile("f.xdmf") as f:# f.write(u)python3 my-code.py# Running FEniCS...# Calling DOLFIN just-in-time (JIT) compiler, this may take some time.# --- Instant: compiling ---cat f.xdmf# &lt;?xml version="1.0"?&gt;# &lt;Xdmf Version="3.0"&gt;# &lt;Domain&gt;# &lt;Grid Name="mesh" GridType="Uniform"&gt;# &lt;Topology NumberOfElements="200" TopologyType="Triangle" NodesPerElement="3"&gt;# &lt;DataItem Dimensions="200 3" NumberType="UInt" Format="HDF"&gt;f.h5:/Mesh/mesh/topology&lt;/DataItem&gt;# &lt;/Topology&gt;# &lt;Geometry GeometryType="XY"&gt;# &lt;DataItem Dimensions="121 2" Format="HDF"&gt;f.h5:/Mesh/mesh/geometry&lt;/DataItem&gt;# &lt;/Geometry&gt;# &lt;Attribute Name="f_6" AttributeType="Scalar" Center="Node"&gt;# &lt;DataItem Dimensions="121 1" Format="HDF"&gt;f.h5:/VisualisationVector/0&lt;/DataItem&gt;# &lt;/Attribute&gt;# &lt;/Grid&gt;# &lt;/Domain&gt;# &lt;/Xdmf&gt; 可以发现生成了f.xdmf和f.h5文件。可以用paraview打开如下： jupyter方式首先找到自己docker服务器的ip 12docker-machine ip $(docker-machine active)# 我的是：192.168.99.100 然后运行： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849mkdir fenicscd fenics#根据镜像建立一个container，并使其开始运行# -t，分配tty，使其不会退出，一直running# --name notebook，把这个运行的实例叫做notebook，可以用docker ps -a 看到，最后一列。# -v $(pwd):/home/fenics/shared# -d detach模式，后台运行# -p $(docker-machine ip $(docker-machine active)):8888:8888 端口映射，把上述docker服务器的端口8888映射到本地8888docker run -it --name notebook -w /home/fenics -v $(pwd):/home/fenics/shared -w /home/fenics/shared -p $(docker-machine ip $(docker-machine active)):8888:8888 quay.io/fenicsproject/stable:current#建立配置# 在notebook container中输入jupyter notebook --generate-config# Writing default config to: /root/.jupyter/jupyter_notebook_config.py#设置密码# 在notebook container中输入jupyter notebook password# Enter password: 比如123# Verify password:# [NotebookPasswordApp] Wrote hashed password to /root/.jupyter/jupyter_notebook_config.json#运行notebook# 在notebook container中输入jupyter notebook --ip=0.0.0.0# [I 16:31:04.584 NotebookApp] Writing notebook server cookie secret to /home/fenics/.local/share/jupyter/runtime/notebook_cookie_secret# [I 16:31:04.825 NotebookApp] Serving notebooks from local directory: /home/fenics/shared# [I 16:31:04.825 NotebookApp] 0 active kernels# [I 16:31:04.825 NotebookApp] The Jupyter Notebook is running at:# [I 16:31:04.825 NotebookApp] http://0.0.0.0:8888/# [I 16:31:04.825 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).# [W 16:31:04.826 NotebookApp] No web browser found: could not locate runnable browser.#退出container的shell界面但是不关闭这个程序# 在notebook container中输入## 按CTRL+P, CTRL+Q#再次进入container的shell界面# docker terminal中输入docker attach noteobook#退出container并使其停止运行# 在notebook container中输入exit#删除container# docker terminal中输入docker rm notebook# 如有必要，需要先停止container：`docker stop notebook` 用浏览器打开http://192.168.99.100:8888，输入密码123即可登录，界面显示如下： 然后就可以运行一个常规算例了，参考4 4. FEniCS tutorial jupyter notebook &#8617; 代码如下： 123456789101112131415161718192021222324252627%matplotlib inlinefrom fenics import *# Create mesh and define function spacemesh = UnitSquareMesh(32, 32)V = FunctionSpace(mesh, 'P', 1)# Define boundary conditionu_D = Expression('1 + x[0]*x[0] + 2*x[1]*x[1]', degree=2)def boundary(x, on_boundary): return on_boundarybc = DirichletBC(V, u_D, boundary)# Define variational problemu = TrialFunction(V)v = TestFunction(V)f = Constant(-9.0)a = dot(grad(u), grad(v))*dxL = f*v*dx# Compute solutionu = Function(V)solve(a == L, u, bc)# Plot solutionplot(u) 结果如图：]]></content>
      <categories>
        <category>FEniCS</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>FEniCS</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建网站写博客]]></title>
    <url>%2F2018%2F01%2F07%2F2018-01-07-%E5%BB%BA%E7%BD%91%E7%AB%99%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[用typora写markdown文档 利用HEXO建博客 用NexT主题 利用mathjax 支持latex 放在github.io上 修改默认宽度 建网站写博客貌似现在比较流行自己建博客网站，有了github pages（国内有类似的coding pages）之后，建站也不用申请空间了，维护也非常的方便。 用typora写markdown文档个人比较喜欢用typora写markdown文档。 网站：https://typora.io/ 下载地址：https://typora.io/windows/typora-setup-x64.exe? Markdown使用参考：http://support.typora.io/Markdown-Reference/ 设置拷贝图片到指定目录：http://support.typora.io/Images/#copy-image-files-to-target-folder-when-insert-local-image 我的markdown文件开头： 123456789101112131415161718192021---title: 建网站写博客date: 2018-01-07 23:16:30updated: 2018-01-07 23:16:30categories: - Website- Blogtags:- mathjaxtypora-root-url: ..typora-copy-images-to: ..\images---短摘要&lt;!--more--&gt;# 标题内容inline公式：$a=b+c$display公式：$$f=ma$$ 这样可以直接用HEXO转化为静态网页，并且可以自动处理好图片拷贝和上传的问题。 用HEXO建立静态网站HEXO是一个利用node.js渲染markdown文件建立静态博客的工具。反正比较程序员向。 官网：https://hexo.io/ 首先需要安装git网址：https://git-scm.com/ 下载地址：https://git-scm.com/download/win 版本：最新版 安装选项：默认即可 安装完之后需要进行一下全局设置，打开开始菜单中的git bash 12git config --global user.name "name" #你的名字git config --global user.email "johndoe@example.com" #你的邮箱 其次需要安装node.jsnodejs官网：https://nodejs.org/ 下载地址：https://nodejs.org/dist/v8.9.4/node-v8.9.4-x64.msi 版本：稳定LTS版，v8.9.4-x64 安装好之后开始菜单会有一个node.js command prompt的快捷方式，打开之后如下图所示： 然后就可以利用npm（nodejs package manager）来安装需要的软件包了。 安装HEXO很简单 12rem 安装hexonpm install hexo-cli -g 建立站点并测试12345678910rem 新建一个站点文件夹，名为bloghexo init blogrem 进入blog文件夹cd blogrem 安装需要的软件包npm installrem 测试生成网站hexo g rem 测试访问网站，访问http://localhost:4000/hexo s 访问的网站默认如下： 此时只要是放入blog/source/_posts中的markdown文件都会被自动渲染成网页出现在这个界面上，只要重新运行一次hexo g &amp;&amp; hexo s即可。 hexo g等价于hexo generate hexo s等价于hexo server 其他注意事项国内由于网络原因对于npm支持不佳，可以采用cnpm，参考taobao npm 镜像网站 123456789rem 安装cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.orgrem 然后用cnpm代替上面命令中的npm就可以了，比如：cnpm install hexo-cli -ghexo init blogcd blogcnpm installhexo ghexo s 使用NexT主题HEXO支持各种各样的主题，其中NexT主题因为是中国人做的还比较友好，并且支持很多国内的链接和网站，所以就选它了。 官网：http://theme-next.iissnan.com/ 源代码：https://github.com/iissnan/hexo-theme-next 安装只需要3步： 把主题文件下载到themes/next文件夹 12cd bloggit clone https://github.com/iissnan/hexo-theme-next themes/next 修改blog/_config.yml文件中的theme 1234//原来默认的是：//theme: landscape//修改为：theme: next 重新生成 123hexo cleanhexo generatehexo server 配置blog这个站点目录里现在有两个文件需要配置： 站点配置文件blog\_config.yml 主题配置文件blog\themes\next\_config.yml 参考http://theme-next.iissnan.com/getting-started.html进行配置即可。 利用Mathjax支持latex公式NexT对公式的支持还算可以，简单的公式只要用以下命令即可： 123456rem 安装相关包npm install hexo-math --saverem 卸载不兼容latex公式的渲染器npm uninstall hexo-render-marked --saverem 安装支持latex公式的渲染器npm install hexo-render-kramed --save 然后保证站点配置文件blog\_config.yml下存在以下内容 123# MathJax Supportmath: engine: mathjax 并且在主题配置文件blog\themes\next\_config.yml中存在以下内容 12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML 重新生成即可渲染绝大部分公式。 额外设置对于少部分公式还是支持有问题，我采用以下方法解决的。 修改blog\node_modules\kramed\lib\rules\inline.js文件中的11行和20行为： 12345var inline = &#123; escape: /^\\([`*\[\]()#$+\-.!_&gt;])/, //修改这里 ... em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, //修改这里 ... 上述//符号之后的注释不要。 上述修改的作用是使其正确处理latex公式中的\\,\{,\},_等标记。 参考：http://xudongyang.coding.me/math-in-hexo/ 网站部署到 github pages上网站不部署只能自己看到，部署之后所有人就都能看到了。 但是普通空间都是需要钱的，一个比较方便又免费的空间就是github pages了。 申请分为两步： github账号的申请，这里不详谈，参考：https://github.com/join github pages 空间的申请，参考：https://pages.github.com/ github pages 空间的申请 假设你的id是iamgod，空间申请只要去https://github.com/new建立一个名为`iamgod.github.io`的仓库（repository）即可。 注意：不要添加任何文件，包括README.md 部署HEXO的部署可以参考：https://hexo.io/docs/deployment.html 基本步骤如下： 安装git部署器 1234rem 进入blog文件夹cd blogrem 安装git部署器npm install hexo-deployer-git --save 修改站点配置文件blog\_config.yml，可在末尾加上以下部分. 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/iamgod/iamgod.github.io.git branch: master 运行部署命令 123456rem 进入blog文件夹cd blogrem 先生成hexo generaterem 然后部署，此时它会要求你输入github的登录账号和密码hexo deploy 等一会儿访问https://iamgod.github.io就可以看到更新网站了。 修改NexT主题默认宽度参考：http://theme-next.iissnan.com/faqs.html#custom-content-width 编辑blog\source\css\_variables\custom.styl文件，添加以下内容： 12345// 修改成你期望的宽度$content-desktop = 700px //我改成了1000px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px //我改成了1200 px]]></content>
      <categories>
        <category>Website</category>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>website</tag>
        <tag>blog</tag>
        <tag>latex</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenFOAM的不可压缩流算法]]></title>
    <url>%2F2018%2F01%2F05%2FOpenFOAM%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8E%8B%E7%BC%A9%E6%B5%81%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对不可压缩流的几个经典算法及其在OpenFOAM中的实现进行了梳理。 主要针对OpenFOAM 5.x版本 SIMPLE, PISO和PIMPLE算法简介均质-不可压缩-无体积力-常粘性的NS方程为： { {\partial \mathbf{u} } \over {\partial t} } + \mathbf{u} \cdot \nabla \mathbf{u} = {-{1 \over \rho} \nabla p} + {\nu \nabla^2 \mathbf{u} }\\ \nabla\cdot \mathbf{u}=0OpenFOAM和其他的CFD软件常用来解它的算法有： SIMPLE: Semi-Implicit Method of-Pressure Linked Equations，用于稳态计算 PISO:= Pressure Implicit Split Operator，用于瞬态计算，可以使用的Courant数往往小于11 PIMPLE:= Merged PISO–SIMPLE，可以使用Courant数&gt;&gt;1 但是找文献和教科书对的时候你会发现很多时候算法和OpenFOAM里的实现对不上。比如wiki和cfd-online上给的SIMPLE算法描述就是（Wiki: SIMPLE Algorithm）： 修正边界条件； 计算速度和压力梯度； 求解离散动量方程（ discretized momentum equation），求得体心临时速度场；这一步是显式的 用体心临时速度场插值计算面心质量通量场； 计算压力修正方程（pressure correction equation），得到体心压力修正场；这一步是隐式的 对体心压力场进行亚松弛修正； 对压力场修正边界条件； 修正面心质量通量场； 修正体心速度场； 更新密度； 但是明显OpenFOAM中的simpleFoam并没有求解过所谓的修正方程，而是自己玩了一个Picard迭代9直接求的全量方程（你会发现OpenFOAM似乎从来就没求过修正量的Newton迭代，个人理解是因为OpenFOAM玩Newton迭代时边界条件不是很方便处理。） 于是我做了一点儿考古和分析。 SIMPLE算法SIMPLE: Semi-Implicit Method of Pressure Linked Equations，这个方程的名字就满是问题，首先什么是半隐式方法（Semi-Implicit Method），什么又是压力联系方程（Pressure Linked Equations）？在原始文献2 中是没有用SIMPLE这个名字的。搜索文献也很难找到压力联系方程的说法。我至今没有找到这个术语最开始的出处，查到最早的是他们自己1973年的文献5 是叫SIMPLE了，但似乎大家都是以讹传讹地引用1972年的那篇文献。 根据一些参考文献3 的分类法，SIMPLE, PISO都属于一类叫压力修正格式（Pressure Correction Schemes）的算法，其特征是构造一个压力场来满足不可压缩条件，再得到一个速度场，至于这个速度场能不能满足新得到的压力场，呵呵，要是能满足就不用再继续迭代了。由于求解的动量方程已经是线性化之后的了，所以你把这个速度对应的面心通量场再去线性化一次动量方程，如此往复才能最后得到稳态解。 压力联系方程之到底是哪个方程查来查去，发现不可压缩CFD解的主要是以下方程： 压力修正方程（Pressure Correction Equation, PCE）4 : 两次迭代间压力需要的修正量的方程 \nabla^2 (p^{n+1}-p^n) =\frac 1 {\Delta t}\nabla\cdot U^* 压力泊松方程（Pressure Poisson Equation, PPE） 6: 动量方程求散度，消去速度散度项 稳定化的一阶欧拉时间离散时的形式。 \nabla^2 p^{n+1} = \rho { {\nabla \cdot \mathbf{u}^n} \over {\Delta t} }- \rho \nabla \cdot (\mathbf{u}^n \cdot \nabla \mathbf{u}^n)+ \mu \nabla^2 (\nabla \cdot \mathbf{u}^n)​ 速度场保持无散时的形式。 -\frac 1 \rho \nabla^2 p = \nabla \cdot (\mathbf{u} \cdot \nabla \mathbf{u}) 压力联系方程（Pressure Linked Equation, PLE）：原始文献并没有说什么是PLE，参考另一篇文献7的说法，压力联系方程的形式如下（符号定义参考文献）： \frac{\partial}{\partial x}\left( \gamma\frac{\partial p}{\partial x} \right) +\frac{\partial}{\partial y}\left( \gamma\frac{\partial p}{\partial y} \right) = \hat \epsilon \\ \hat\epsilon = (\hat u_e- \hat u_w)/\Delta x +(\hat v_n - \hat v_s)/\Delta y可见，所谓PLE非常诡异，它不是个微分方程，而是一个代数方程。对应到OpenFOAM里的simpleFoam则是8： \begin{equation} \nabla \cdot (\mathbf{HbyA}^{n+1}) = \nabla \cdot(\frac{1}{A_{\mathrm{P},f} } \nabla p^{n+1}) \label{poss} \end{equation}同时，对比PLE和PPE，可以发现，二者都是把某种形式的动量方程带入了质量守恒方程得到的，但不同之处在于 PLE是把线性化的离散动量方程中得到速度表达式带入了质量守恒方程，得到$\nabla\cdot(\frac 1 a \nabla p) = \dots $。 大概是这么个过程： 线性化离散动量方程记为 $M\cdot u = \nabla p $， $M$是一个矩阵。 先LDU加法分解： $M\cdot u = (D+L+U) \cdot u = \nabla p$ 然后进行Jacobi迭代：$ D \cdot u = \nabla p - (L+U) \cdot u^0$ 左边： $D$记为$A$ （实际上是对角系数除以单元体积，以保持量纲一致性）， 因为是对角阵，所以可以把$D^{-1}=A^{-1}$记为 $\frac 1 A$ ，OpenFOAM里实现为一个几何场而不是矩阵fvMatrix； 右边：$(L+U)\cdot u^0$记为 $H$ 这样$u = \frac 1 A \nabla p - \frac H A$ 然后再利用$\nabla \cdot u = 0 $ 得到$\nabla\cdot(\frac 1 A \nabla p ) = \nabla \cdot \frac H A$ ，这就是PLE，也是实际OpenFOAM中求解的方程。 英语里$\frac H A$ 可以读作”H by A” OpenFOAM里的$\frac 1 A$ 对应变量为rUA PPE是把动量方程直接求散度得到的，所以是$\nabla\cdot\nabla p=\dots$。 FAQ 问：为啥要费劲心力去算$\mathbf{HbyA}$，再算PLE，直接离散PPE或者质量守恒方程不行么？ 答：我也不知道 但是玩FEM的家伙们就是这么干的（当然实际上他们也有很多流派，但是他们更多的是玩函数空间，LBB条件而不是玩方程系数，玩系数太low） 似乎只有玩FVM的人才玩PLE。 而且投影法10那个流派的FVM也是玩的PPE，参考Chorin’s_projection_method#Chorin’s_projection_method)。 而且为了玩PLE，作为使用OpenFOAM的同位网格玩家，还必须引入Rhie-Chow插值这种大坑，虽然OpenFOAM似乎轻巧地避开了这个坑。 Semi-Implicit-Method半隐式方法我认为之所以叫半隐式方法，是因为： 求解过程中，求速度预测步的方程对于速度是隐式的，但对于压力是固定的显式离散，所以称之为半隐式。 求解压力方程时，压力是隐式离散的，但是此时的速度是固定不变的。 所以本质上这个半隐式等价于解耦算法。 文献5 摘要中提到，SIMPLE的半隐式是和SIVA（SImultaneous Variable Adjustment）全隐算法相对的提法，其特点是每次迭代要同时更新周围的速度和压力。 SIMPLE算法因此具有一些特性： 解耦计算，内存占用小。 用于稳态计算，所以timeStep无意义，但通常设置timeStep=1，这样解算输出时间等于时间步数； 由于没有时间项来稳定化计算，需要加入松弛因子（在矩阵上加在和时间项几乎相同的位置），但是这个松弛因子在实现时搞不好会对最终稳态解产生影响。 关于consistent对于SIMPLE-C算法16而言，比SIMPLE算法只多了一个步骤： 123456789101112131415161718//applications/solvers/incompressible/pimpleFoam/pEqn.H +16if (pimple.consistent())&#123; rAtU = 1.0/max(1.0/rAU - UEqn.H1(), 0.1/rAU); //有max! phiHbyA += fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf(); HbyA -= (rAU - rAtU())*fvc::grad(p);&#125;//applications/solvers/incompressible/simpleFoam/pEqn.H +10if (simple.consistent())&#123; rAtU = 1.0/(1.0/rAU - UEqn.H1()); //没有max! phiHbyA += fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf(); HbyA -= (rAU - rAtU())*fvc::grad(p);&#125; 值得注意的是，pimpleFoam和simpleFoam的consistent选项对rAtU的计算公式是有区别的！ 其中修改了的变量有： rAtU 1.0/rAU - UEqn.H1()的实际含义应该是$[1/(\frac{1}{D})-(-(L+U)\cdot \mathbf{1})] = (L+D+U)\cdot \mathbf{1}$，也就是矩阵系数的行和，中间最多差一个网格体积的因子。 0.1/rAU的含义应该是$\frac{1}{10} D$ 由于系数矩阵元素的大小往往是对角项为负，非对角项为正，其行和为略小的负数（对于laplace方程，某些行和可能为0，但是对于动量方程，应该不为零）。所以为了避免除以0，pimpleFoam采用了max函数的技巧。 而对于simpleFoam，只取了第一项的倒数。 phiHbyA 按照rAtU-rAU的差值，和grad(p)对界面流量进行更新 把这项代入到pEqn的表达式中，可以发现和原来是一样的 12345678910111213141516171819//原来的方程，如pisoFoam, icoFoam就采用了这个方程fvScalarMatrix pEqn( fvm::laplacian(rAU, p) == fvc::div(phiHbyA));//simpleFoam, pimpleFoam采用的方程，将phiHbyA改记为phiHbyA2fvScalarMatrix pEqn( fvm::laplacian(rAtU(), p) == fvc::div(phiHbyA2));//两者相减fvScalarMatrix pEqn( fvm::laplacian(rAtU()-rAU, p) == fvc::div(fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf()));//可见二者是一致的。 HbyA 同上，按照rAtU-rAU的差值，对临时体心速度进行更新。 便于后面用U = HbyA - rAtU()*fvc::grad(p);去更新真正的体心速度！ 至此，正确性没有问题，但是为啥rAtU要这么改？！。 对于pimpleFoam中的rAtU，max()函数在分母，应该是取了较为稳定的一组系数，并避免了除以0。 对于simpleFoam而言，rAU是矩阵系数中的对角部分，而rAtU则是取了矩阵每一行系数的和。 参考原始文献16 ，作者就是这么干的！ 本质上你可以任意的分解： M=L+D+U \\ M\cdot u = (L+D+U)\cdot u = (D_s+(M-D_s) )\cdot u = - \nabla p \\ 所以对于consistent=false的情形： A=\frac 1 D \\ H=-(L+U)\cdot u^0 对于consistent=true的情形： H_1 =- (L+U)\cdot \mathbf{1} \\ A'=D-H_1 = M\cdot \mathbf{1} 根据wiki上的说明，如果压力-速度耦合是解收敛的主要问题，SIMPLE-C算法可以加速收敛，SIMPLE-C比SIMPLE要快大概是120%-130%左右。 如果压力-速度耦合不是收敛的主要障碍，SIMPLE-C效率与SIMPLE差不多。 关于H1和H的区别 意义不一样：假设$M=(L+D+U)$，初值为$x^0$ 则$H_1 = H(x^0=\mathbf1)$ $H(x^0)=-(L+D)\cdot x^0$ $\mathbf 1$表示全是1的向量。 都是定义在lduMatrix中的，但是H1是不带参数的，而H是带参数的。 实现的地方也不一样，一个在lduMatrixATmul.C，另一个在lduMatrixTemplates.C： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//H1()//src/OpenFOAM/matrices/lduMatrix/lduMatrix/lduMatrixATmul.C +298Foam::tmp&lt;Foam::scalarField &gt; Foam::lduMatrix::H1() const&#123; tmp&lt;scalarField &gt; tH1 ( new scalarField(lduAddr().size(), 0.0) ); if (lowerPtr_ || upperPtr_) &#123; scalarField&amp; H1_ = tH1.ref(); scalar* __restrict__ H1Ptr = H1_.begin(); const label* __restrict__ uPtr = lduAddr().upperAddr().begin(); const label* __restrict__ lPtr = lduAddr().lowerAddr().begin(); const scalar* __restrict__ lowerPtr = lower().begin(); const scalar* __restrict__ upperPtr = upper().begin(); const label nFaces = upper().size(); for (label face=0; face&lt;nFaces; face++) &#123; H1Ptr[uPtr[face]] -= lowerPtr[face]; H1Ptr[lPtr[face]] -= upperPtr[face]; &#125; &#125; return tH1;&#125;//H(psi)//src/OpenFOAM/matrices/lduMatrix/lduMatrix/lduMatrixTemplates.C +34template&lt;class Type&gt;Foam::tmp&lt;Foam::Field&lt;Type&gt;&gt; Foam::lduMatrix::H(const Field&lt;Type&gt;&amp; psi) const&#123; tmp&lt;Field&lt;Type&gt;&gt; tHpsi ( new Field&lt;Type&gt;(lduAddr().size(), Zero) ); if (lowerPtr_ || upperPtr_) &#123; Field&lt;Type&gt; &amp; Hpsi = tHpsi.ref(); Type* __restrict__ HpsiPtr = Hpsi.begin(); const Type* __restrict__ psiPtr = psi.begin(); const label* __restrict__ uPtr = lduAddr().upperAddr().begin(); const label* __restrict__ lPtr = lduAddr().lowerAddr().begin(); const scalar* __restrict__ lowerPtr = lower().begin(); const scalar* __restrict__ upperPtr = upper().begin(); const label nFaces = upper().size(); for (label face=0; face&lt;nFaces; face++) &#123; HpsiPtr[uPtr[face]] -= lowerPtr[face]*psiPtr[lPtr[face]]; HpsiPtr[lPtr[face]] -= upperPtr[face]*psiPtr[uPtr[face]]; &#125; &#125; return tHpsi;&#125;template&lt;class Type&gt;Foam::tmp&lt;Foam::Field&lt;Type&gt;&gt;Foam::lduMatrix::H(const tmp&lt;Field&lt;Type&gt;&gt;&amp; tpsi) const&#123; tmp&lt;Field&lt;Type&gt;&gt; tHpsi(H(tpsi())); tpsi.clear(); return tHpsi;&#125; 其他wiki和cfd-online上的SIMPLE算法是和simpleFoam不一致的。正确的描述可以参考openfoamwiki上的描述：the SIMPLE Algorithm simple算法在OpenFOAM中的实现也是和版本相关的，比如foam-extend 4.0的simpleFoam里Jasak就采用了一种新的算法来避免时间步和松弛因子对解的影响。OpenFOAM.org和OpenFOAM.com的似乎还没变化。 此外，SIMPLE算法还有一些衍生算法： SIMPLEC: SIMPLE-Consistent SIMPLER: SIMPLE-Revised Rhie-Chow插值Rhie-Chow插值，有人又叫压力加权插值方法(pressure-weighted interpolation method, PWIM)，但是其实这个插值并不是用压力来加权的。 刚开始我以为这个插值的作用是来插值计算面心压力的，后来发现其实它是用来计算面心速度的插值方法。 本质上它等效于引入了4阶耗散项进入压力修正方程中，有利于计算的稳定化： 按照Rhie-Chow插值，均匀一维网格的面心速度表达式会含有P的三次导数成分。 U_e = \frac 1 2 (U_E+U_P)+\frac{\delta V}{4a_P\Delta x}[P_{EE}-3P_E+3P_P-P_W]带入连续性方程之后，就会含有四次导数成分，成为稳定化压力方程的高阶耗散项，从而可以平抑压力波动： \int_e^w{\frac {dU }{dx} dx} =U_e - U_w = \frac 1 2 (U_E - U_W)+\frac{\delta V}{4a_P\Delta x}[P_EE-4P_E+6P_{P}-4P_W+P_{WW}]详细的说明可以看参考文献13 而且玩高阶导数的人都应该知道，压力梯度都特别大的时候，高阶项会更大，所以有时候Rhie-Chow插值也会出问题。 面心速度的作用（注：面心速度（$\mathbf{u}_f$）和界面通量（程序里常用phi表示 ）仅相差一个面积，所以实际上差不多是同一回事儿。） 根据文献11 ，面心速度有三个作用： 格式系数作用：构成关于体心速度的矩阵方程UEqn时，界面通量是系数的重要组成部分，系数不同，方程就不同，解就不同； 耦合作用：耦合速度和压力，在simple算法构造关于体心压力的矩阵方程时，需要用到界面通量； 质量守恒作用：界面通量应满足质量守恒。 按照我的理解，在OpenFOAM中，这些作用在程序中分别由不同的变量承担了，并不是同一个面心速度了。 格式系数作用：由于采用的是Picard迭代，所以OpenFOAM组成速度方程UEqn的矩阵系数是采用直接按fvScheme指定格式插值得到的界面通量phi在fvm::div(phi,U)生成的（准确地说在simpleFoam中第一次迭代用的插值phi，后面用的pEqn.flux()和phiHbyA构造的phi）。在simpleFoam中如以下代码所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//UEqn.Htmp&lt;fvVectorMatrix&gt; tUEqn ( fvm::div(phi, U) //这里用的界面通量是phi + MRF.DDt(U) + turbulence-&gt;divDevReff(U) == fvOptions(U) ); fvVectorMatrix&amp; UEqn = tUEqn.ref();//src/finiteVolume/cfdTools/incompressible/createPhi.HsurfaceScalarField phi( IOobject ( "phi", runTime.timeName(), mesh, IOobject::READ_IF_PRESENT, IOobject::AUTO_WRITE ), fvc::flux(U) //调用的是fvc::flux());//src/finiteVolume/finiteVolume/fvc/fvcFlux.C Foam::tmp&lt;Foam::surfaceScalarField&gt; Foam::fvc::flux( const volVectorField&amp; vvf)&#123; return scheme&lt;vector&gt; // scheme&lt;vector&gt;(mesh,name) 返回 tmp&lt;surfaceInterpolationScheme&gt;对象 ( vvf.mesh(), "flux(" + vvf.name() + ')' )().dotInterpolate(vvf.mesh().Sf(), vvf); //插值并点乘&#125;//pEqn.H while (simple.correctNonOrthogonal()) &#123; //... if (simple.finalNonOrthogonalIter()) &#123; phi = phiHbyA - pEqn.flux(); //更新phi &#125; &#125; 而耦合作用反映在phiHbyA这个界面通量中，它最终构成了pEqn中的源项部分，在OpenFOAM的simpleFoam求解器中，phiHbyA是用fvc::flux(HbyA) 构造的。 但是值得注意的是，simpleFoam只构造出了不含压力梯度贡献的临时速度$u^*$ = HbyA，并且没有直接使用它，而是用它构造了phiHbyA。 simpleFoam没有在pEqn求解之前构造含有压力梯度贡献的U，这是在求解完压力方程后，用U = HbyA - rAtU()*fvc::grad(p) 构造的。 所以dyfluid上说在OpenFOAM中，并没有直接采用Rhie-Chow插值的原始步骤。相反的，其通过对拉普拉斯项的离散巧妙的获得一种近似Rhie-Chow插值的原理。 因为原始步骤是通过$\nabla\cdot U=0$构造pEqn，而实际上因为pEqn是通过phiHbyA 和rUA构造的，所以跳过了原始的Rhie-Chow插值。 而因为fvm::laplacian(rUA,p)的实现已经是利用了周围相邻单元的压力，并没有原始构造方式中压力的奇偶失耦（odd-even decoupling）情况，所以认为是实现了Rhie-Chow插值的效果。 按照参考文献18 的搞法（Listing 15.18），Rhie-Chow插值似乎是用于产生phiHbyA的，但是由于那本书严格地遵守了解PCE的思路，所以还不能完全相互比较。 质量守恒作用其实是靠pEqn实现的PLE完成的，simpleFoam除了在continuityErrs.H之外不直接检查质量守恒，检查时也是用的fvc::div(phi)而不是速度U。 PISO算法PISO = Pressure Implicit Split Operator。同样的问题，什么是压力隐式(pressure implicit)，什么是算子分裂(split operator)。就icoFoam来看，我的理解是： 压力隐式(pressure implicit)：求解的压力方程是隐式的（废话）； 算子分裂(split operator)：把$\frac {dx}{dt}|_t^{t+\Delta t}=O(x) = (O_1+O_2)(x) $ 近似成$ \frac{dx}{dt}|_t^{t+\Delta t} = O_1(x’), \frac{dx’}{dt}|_t^{t+\Delta t}=O_2(x)$来求解 原始文献15中其实也就是解耦速度和压力的意思： The principle is here extended to apply to the coupling between variables, namely, the pressure and velocity, whereby operations involving different variables are split into a series of predictor-corrector steps. 算子分裂的一个问题在于，它有时候不能保证到达稳态解的正确性！详见参考文献14 。 算法的具体描述请参考OpenFOAMwiki的PISO Algorithm （这里的描述所用的版本有点老，和最新版OpenFOAM中使用的变量名有所不同）： Set the boundary conditions 施加边界条件. Solve the discretized momentum equation to compute an intermediate velocity field. 解离散动量方程得到中间阶段的速度场$U^*$ 但是其实这一步可以设置momentumPredictor=false来跳过去。 因为最重要的其实是压力方程，这个速度场方程UEqn主要用来提取$A$和$H$，以构造后面压力方程要用的phi 因为有非定常项，所以这里是没有松弛的！有松弛就不对了。 Compute the mass fluxes at the cells faces，构造phiHbyA. 与simple不同，这里的phiHbyA加入了fvc::ddtCorr项 fvc::ddtCorr项的定义参考这里。 Solve the pressure equation.解压力方程，其实应该是解的PLE Correct the mass fluxes at the cell faces.更新phi Correct the velocities on the basis of the new pressure field. 更新U Update the boundary conditions.更新U的边界条件 Repeat from 3 for the prescribed number of times. 重复piso循环， 这个是由piso.correct()控制的，而piso.correct()是由变量label corrPISO_控制的。 重复的时候，UEqn所引用的U是有更新的。所以用UEqn构造的UEqn.A(), UEqn.H()也可能会有所更新。 Increase the time step and repeat from 1. 下一个时间步，这里是由runTime.loop()控制的。 OpenFOAM中的PISO求解器其实有两个，最简单的是icoFoam，用的是PISO算法解层流。复杂一点的是pisoFoam，带有湍流模型。 其他solutionControl及其子类的继承关系 pisoControl是pimpleControl的子类！ pimpleContrl是solutionControl的子类 simpleControl是solutionControl的子类。 松弛从代码中可以发现，pisoFoam和icoFoam对于压力和动量方程是没有进行松弛的。这是因为它要进行的是时间精确的模拟。 但是如果你用的ddt格式本来就不是时间精确的话，额，还是不要用PISO了，改用PIMPLE吧。加点松弛因子可能还稳定些。 PIMPLE算法PIMPLE算法是SIMPLE和PISO的结合。因为PISO只有一个预测步，所以PISO的稳定性限制了它只能用于瞬态计算并且时间步不能取得太大，而SIMPLE没有时间项只能用于稳态计算（或者采用伪时间步方法用于瞬态计算）。PIMPLE算法的核心是把UEqn重新生成并解了很多次！ pimpleFoam中的#include &quot;UEqn.H&quot; 语句是被包在pimple.loop()循环内的。 pisoFoam中的#include &quot;UEqn.H&quot;语句没有被包裹，每次runTime.loop()只运行一次。 pisoFoam中没有使用consistent关键字，所以没有SIMPLE-C修正。 pimpleFoam中使用了consistent关键字，所以和simpleFoam一样，对phiHbyA进行了SIMPLE-C处理。 simpleFoam中使用的simple.loop()而不是runTime.loop()，但是它调用了runTime.loop() PIMPLE里的三层循环总结起来，PIMPLE算法每个时间步（由runTime.loop()控制）有三层循环： 外层pimple.loop()类似SIMPLE循环 利用当前的U，生成并求解UEqn 中层pimple.correct()，几乎就是PISO循环，负责压力求解 利用UEqn 构造rAU, HbyA HbyA 生成phiHbyA，加入fvc::ddtCorr(U,phi)修正。 adjustPhi() 利用consistent关键字对phiHbyA进行SIMPLE-C一致性修正 constrainPressure() 内层pimple.correctNonOrthogonal()非正交修正循环 构造压力联系方程pEqn pEqn.setReference() 用新的p作为初始值求解pEqn，进行非正交修正。 更新U和phi 而SIMPLE算法没有中层循环，PISO算法没有外层循环。所以PIMPLE算法可以简化为PISO算法，但是由于SIMPLE算法中没有包含非定常项，所以PIMPLE算法要等同于SIMPLE算法需要使ddt项的格式需要指定为steadyState。 一些编程细节此外在程序代码中还有好多稀奇古怪的乱七八糟玩意儿。 solutionControl及其子类的变量命名规范OpenFOAM里的求解控制类是solutionControl 及其子类simpleControl, pisoControl和pimpleControl。其中定义了很多变量，其命名规范是： label xxx_表示迭代变量，比如corr_, corrNonOrtho_,pimpleControl中的 corrPISO_等。 label nXxx_表示迭代上限次数，比如nCorrNonOrtho_（实际迭代次数是nCorrNonOrtho_+1，因为第一次求解不算所谓修正），pimpleControl中的nCorrPIMPLE_, nCorrPISO_ bool yyy_表示标志量，比如transonic_, consistent_, momentumPredictor_ residualControl_ 残差控制。 以pimpleControl为例，其迭代循环变量和控制变量标志如下表 含义 迭代量的变量名 迭代上限的变量名 配置文件中的关键字 默认值 判断是否执行的函数 外部迭代，又叫PIMPLE迭代 label corr_ nCorrPIMPLE_ nOuterCorrectors 1 loop() PISO压力修正循环 label corrPISO_ nCorrPISO_ nCorrectors 1 correct() 非正交修正 label corrNonOrtho_ nCorrNonOrtho_ 这是实际迭代次数上限减1 nNonOrthogonalCorrectors 0 correctNonOrthogonal() 是否执行动量预测步 bool momentumPredictor_ momentumPredictor true momentumPredictor() 一致性 bool consistent_ consistent false consistent() 跨声速 bool transonic transonic false transonic() 是否在PISO循环外更新密度 bool SIMPLErho_ SIMPLErho false SIMPLErho() 仅在最后迭代启用湍流 bool turbOnFinalIterOnly_ turbOnFinalIterOnly true momentumPredictor() simpleFoam中phi变量的更新。如果仔细的人应该会发现，phi这个变量在simpleFoam中是由createFields.H调用createPhi.H创建的，然后在UEqn.H中被fvm::div(phi,U)使用，那么在下一次迭代之前它是如何更新的呢？ 我们发现它是在pEqn.H中更新的。 12345//pEqn.H if (simple.finalNonOrthogonalIter()) &#123; phi = phiHbyA - pEqn.flux(); &#125; 关于adjustPhi, 和 setReferenceadjustPhi和pRef针对的是压力方程为全Neuman边界的情况12，这时解的存在唯一性可能会有两个问题: 唯一性：方程系数矩阵M 列秩不满时，解有无穷多（例如$x_1+x_2=1,2x_1+2x_2=2$），互之间相差一组常数（或者一组常函数，或零空间元素），所以需要setReference 存在性：方程的增广矩阵秩和M的秩不一样时（例如$x_1+x_2=1,-x_1-x_2=-2$），存在相容性问题，需要adjustPhi 关于线性代数知识可以参考23 23. 教案： 线性方程组 &#8617; 方程多解问题：setReference当方程为： \Delta p = f \text{ on }\Omega \\ \nabla p \cdot \mathbf n = g \text{ on }\partial \Omega首先，如果$p_1$是一个解，那么$p_2=p_1+const$也是方程的解，方程解不唯一，所以离散方程会有奇异性，无法求解。解决方法是固定一个点的压力为给定值，就是设置setReference。 方程相容性问题：adjustPhip变量前面是直接加了微分的，所以需要对于全Neumann条件的情形还需要满足相容性条件： \int_{\Omega}{f dV} =\int_{\Omega}{\Delta p dV} = \int_{ \partial\Omega}{\nabla p \cdot\mathbf n dS} = \int_{ \partial\Omega}{g dS}这就是adjustPhi去强制满足这个条件。带入f和g的表达式 f= \nabla\cdot\mathbf u^*\\ g=0可得： \int_{\Omega}{\nabla \cdot \mathbf u^* dV} =\int_{\partial \Omega}{\mathbf u^*dS}= 0你再看看adjustPhi出现的位置，是在pEqn.H中，对phiHbyA进行的调整。其实也就是这里的$\mathbf u^*$项。必须使其满足以上相容性条件。 关于constrainPressure和constrainHbyA从OpenFOAM的4.0版本开始，引入了fixedFluxPressure,fixedFluxExtraoplatedPressure边界条件，从而使入口的压力可以浮动，且边界压力梯度还可以根据计算情况进行调整，于是引入了constrainPressure()和constrainHbyA()函数。 其说明可以参考Fumiya Nozaki’s CFD Blog的这篇blog：Recent changes in the basics of the OpenFOAM solvers和 fixedFluxPressure 境界条件。 constrainPressure用于调整压力p的边界可压缩流中边界速度$U_f$在离散生成UEqn之后可以表示为： \begin{equation} \rho \boldsymbol{U}_f \cdot \boldsymbol{S}_f = \left(\frac{\rho \boldsymbol{H} }{A_p}\right)_f \cdot \boldsymbol{S}_f\;-\;\left(\frac{\rho}{A_p}\right)_f (\nabla p)_f \cdot \boldsymbol{S}_f. \tag{1} \label{eq:1} \end{equation}所以界面法向压力梯度可以表示为： \begin{equation} (\nabla p)_f \cdot \boldsymbol{n}_f = \frac{1}{|\boldsymbol{S}_f|\left(\frac{\rho}{A_p}\right)_f} \left(\left(\frac{\rho \boldsymbol{H} }{A_p}\right)_f \cdot \boldsymbol{S}_f\;-\;\rho \boldsymbol{U}_f \cdot \boldsymbol{S}_f \right). \tag{2} \label{eq:2} \end{equation}将上述关系运用于压力边界条件，就是constrainPressure要干的事儿。 void constrainPressure(p,rho=1,U,phiHbyA,rhorAU,MRF=NULLMRF) 输出调整的其实是p 必要的输入有U,phiHbyA,rhorAU p边界条件继承于fixedFluxPressureFvPatchScalarField的才会调整。 constrainHbyA(tHbyA,U,p)用于返回调整后的tHbyANew变量 循环每个边界 当U的在这个边界的边界条件是assignable()==false 且p的在这个边界是继承自fixedFluxExtrapolatedPressureFvPatchScalarField tHbyANew的这个 这边界设置为和U的这个边界相同的值。 返回tHbyANew 为什么要这么做：我也不知道。可能这样做了之后constrainPressure()得到的压力和HbyA在固定速度的边界与前述PLE方程就是一致的了，毕竟前面的constrainPressure()是利用了HbyA生成的phiHbyA的。 如果没有用到fixedFluxExtrapolatedPressure和 fixedFluxPressure边界条件，这两个函数其实相当于没有作用。 关于fvc::ddtCorr()和fvc::ddtPhiCorr()对于非稳态的求解器，如pimpleFoam, pisoFoam和icoFoam中，phiHbyA在构造时除了用到HbyA 向的插值，还会用到fvc::ddtCorr()，这一项主要是为了修正非定常和松弛因子对解的影响。而且这一项还是和OpenFOAM版本历史相关的！ 123456789101112131415161718192021222324252627282930313233343536//OpenFOAM 5.x, 4.x//applications/solvers/incompressible/icoFoam/icoFoam.C +77 surfaceScalarField phiHbyA ( "phiHbyA", fvc::flux(HbyA) //这里用了fvc::flux函数，而不是原来的interpolate 和 &amp; 算符 + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi) //用的是ddtCorr! );//OpenFOAM 2.3.x, 2.4.x//applications/solvers/incompressible/icoFoam/icoFoam.C +73 surfaceScalarField phiHbyA ( "phiHbyA", (fvc::interpolate(HbyA) &amp; mesh.Sf()) + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi) //用的是ddtCorr );//OpenFOAM 2.2.x//applications/solvers/incompressible/icoFoam/icoFoam.C +73 surfaceScalarField phiHbyA//用了新的变量名! ( "phiHbyA", (fvc::interpolate(HbyA) &amp; mesh.Sf()) + fvc::ddtPhiCorr(rAU, U, phi) //用的是ddtPhiCorr! );//OpenFOAM 2.1.x//applications/solvers/incompressible/icoFoam/icoFoam.C +72 phi = (fvc::interpolate(U) &amp; mesh.Sf()) + fvc::ddtPhiCorr(rAU, U, phi);//foam-extend 4.0//applications/solvers/incompressible/icoFoam/icoFoam.C +86 U = HUEqn.H()/aU; //注意这里的HUEqn不包含非定常项 phi = (fvc::interpolate(U) &amp; mesh.Sf()); //所以这里也不包含。 太老的就不管了，因为根据OpenFOAM.org官网的更新说明，2.3.0版本时已经把ddtPhiCorr换成了ddtCorr。 首先找OpenFOAM 5.x的代码，看看ddtCorr()到底是干啥的 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//src/finiteVolume/finiteVolume/fvc/fvcDdt.C +183template&lt;class Type&gt;tmp&lt;GeometricField&lt;typename flux&lt;Type&gt;::type, fvsPatchField, surfaceMesh&gt;&gt;ddtCorr( const GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U, const GeometricField &lt; typename flux&lt;Type&gt;::type, fvsPatchField, surfaceMesh &gt;&amp; phi)&#123; return fv::ddtScheme&lt;Type&gt;::New //根据变量名返回tmp&lt;ddtScheme&lt;Type&gt;&gt;的临时对象 ( U.mesh(), U.mesh().ddtScheme("ddt(" + U.name() + ')') ).ref().fvcDdtPhiCorr(U, phi);&#125;//这里涉及到RTS机制，//为了简化，参考steadyState和经典的Euler格式是怎么做的//src/finiteVolume/finiteVolume/ddtSchemes/steadyStateDdtScheme/steadyStateDdtScheme.C +305//steadyState返回的是0，无修正，这很正常。//返回值的量纲是：phi.dimensions()/dimTime//对于不可压缩流应该是L^3/T^2template&lt;class Type&gt;tmp&lt;typename steadyStateDdtScheme&lt;Type&gt;::fluxFieldType&gt;steadyStateDdtScheme&lt;Type&gt;::fvcDdtPhiCorr( const GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U, const fluxFieldType&amp; phi)&#123; return tmp&lt;fluxFieldType&gt; ( new fluxFieldType ( IOobject ( "ddtCorr(" + U.name() + ',' + phi.name() + ')', mesh().time().timeName(), mesh() ), mesh(), dimensioned&lt;typename flux&lt;Type&gt;::type&gt; ( "0", phi.dimensions()/dimTime, Zero ) ) );&#125;//Euler格式的修正//src/finiteVolume/finiteVolume/ddtSchemes/EulerDdtScheme/EulerDdtScheme.C +534template&lt;class Type&gt;tmp&lt;typename EulerDdtScheme&lt;Type&gt;::fluxFieldType&gt;EulerDdtScheme&lt;Type&gt;::fvcDdtPhiCorr( const GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U, const fluxFieldType&amp; phi)&#123; dimensionedScalar rDeltaT = 1.0/mesh().time().deltaT(); //时间增量的倒数 fluxFieldType phiCorr ( phi.oldTime() - fvc::dotInterpolate(mesh().Sf(), U.oldTime()) ); return tmp&lt;fluxFieldType&gt; ( new fluxFieldType ( IOobject ( "ddtCorr(" + U.name() + ',' + phi.name() + ')', mesh().time().timeName(), mesh() ), this-&gt;fvcDdtPhiCoeff(U.oldTime(), phi.oldTime(), phiCorr) *rDeltaT*phiCorr ) );&#125;//涉及到fvcDdtPhiCoeff系数，继续查找，发现这个函数位于ddtScheme中。//src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.C +151template&lt;class Type&gt;tmp&lt;surfaceScalarField&gt; ddtScheme&lt;Type&gt;::fvcDdtPhiCoeff( const GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U, const fluxFieldType&amp; phi, const fluxFieldType&amp; phiCorr)&#123; tmp&lt;surfaceScalarField&gt; tddtCouplingCoeff = scalar(1) - min ( mag(phiCorr) /(mag(phi) + dimensionedScalar("small", phi.dimensions(), SMALL)), scalar(1) ); surfaceScalarField&amp; ddtCouplingCoeff = tddtCouplingCoeff.ref(); surfaceScalarField::Boundary&amp; ccbf = ddtCouplingCoeff.boundaryFieldRef(); forAll(U.boundaryField(), patchi) &#123; if ( U.boundaryField()[patchi].fixesValue() || isA&lt;cyclicAMIFvPatch&gt;(mesh().boundary()[patchi]) ) &#123; ccbf[patchi] = 0.0; &#125; &#125; if (debug &gt; 1) &#123; InfoInFunction &lt;&lt; "ddtCouplingCoeff mean max min = " &lt;&lt; gAverage(ddtCouplingCoeff.primitiveField()) &lt;&lt; " " &lt;&lt; gMax(ddtCouplingCoeff.primitiveField()) &lt;&lt; " " &lt;&lt; gMin(ddtCouplingCoeff.primitiveField()) &lt;&lt; endl; &#125; return tddtCouplingCoeff;&#125; 所以OpenFOAM的ddtCorr的算法如下： 首先用过去时间的通量$\phi^{n-1}$和速度$U^{n-1}$估算通量的修正$\phi^{c}$。 \phi^{c} = \phi^{n-1} - U_f(U^{n-1})\cdot \mathbf S_f 计算ddt耦合系数$K_c$： K_c = 1 - \min\left( \frac {|\phi^c|}{|\phi^{n-1}|+\epsilon}, 1\right)同时，应该注意到，ddt耦合系数$K_c$是一个大于0的无量纲界面张量场！它的边界条件也被特殊地处理了，对于固定速度边界或cyclicAMI边界，它的值是0. 输出修正量$\phi^k = K_c\phi^c/\Delta t$ 但是为什么这么计算耦合系数$K_c$和通量$\phi^c$，我也不知道！ cfd-online上一个叫eugene的id提到ddtCorr实质上是文献19中的所谓Choi Correction，对应的原始文献是20 ，但发帖者认为fvcDdtPhiCoeff = 1时是完整的Choi Correction，但此时OpenFOAM会不稳定，所以用了一个经验性的fvcDdtPhiCoeff()函数来限制这个Choi Correction。 Jasak的搞法Jasak似乎玩了另外的花样。在foam-extend 4.0中，Jasak的icoFoam和OpenFOAM.org以及OpenFOAMplus的icoFoam就不一样了。 Jasak的icoFoam把UEqn分成了HUEqn和ddtUEqn两部分： HUEqn： 对流和扩散项 ddtUEqn：非定常项； 动量预测步：HUEqn + ddtUEqn == -grad(p) PISO循环中：H从HUEqn.H()中产生！与时间步完全无关。 速度更新： 1234567//https://github.com/Unofficial-Extend-Project-Mirror/foam-extend-foam-extend-4.0/blob/master/applications/solvers/incompressible/icoFoam/icoFoam.C +113// Note: cannot call H(U) here because the velocity is not complete// HJ, 22/Jan/2016U = 1.0/(aU + ddtUEqn.A())*( U*aU - fvc::grad(p) + ddtUEqn.H()); Jasak 认为这使得代码更加清晰了（时间导数算子中完全去掉了ddtPhiCorr和ddtCorr）。而且完全消除了时间步和松弛因子对结果的影响。结果对比参考文献17 投影法另外一种选择是用投影法，参考文献21。 投影法在同位网格上可以避免Rhie-Chow插值，从而避免这个ddtCorr()的问题。 他们也做了数值试验来观察这个质量通量修正项（mass flux correction term）对PISO算法的效果。发现扔掉这一项，PISO算法的耗散大大降低。 OpenFOAMplus的搞法OpenFOAMplus在v1706中的ddtScheme加入了一个scalar ddtPhiCoeff_的定义。从而使ddtCorr()的实现更加复杂化。 代码如下： 1234567891011121314151617//https://develop.openfoam.com/Development/OpenFOAM-plus/blob/master/src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.Htemplate&lt;class Type&gt;class ddtScheme: public tmp&lt;ddtScheme&lt;Type&gt;&gt;::refCount&#123;protected: // Protected data const fvMesh&amp; mesh_; //- Input for fvcDdtPhiCoeff (-1 default) scalar ddtPhiCoeff_; //ebf654f2这个集成rhoPimpleAdiabaticFoam的提交中才出现的。//... 而此时更改为了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// https://develop.openfoam.com/Development/OpenFOAM-plus/blob/master/src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.C +151template&lt;class Type&gt;tmp&lt;surfaceScalarField&gt; ddtScheme&lt;Type&gt;::fvcDdtPhiCoeff( const GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U, const fluxFieldType&amp; phi, const fluxFieldType&amp; phiCorr)&#123; tmp&lt;surfaceScalarField&gt; tddtCouplingCoeff ( new surfaceScalarField ( IOobject ( "ddtCouplingCoeff", U.mesh().time().timeName(), U.mesh() ), U.mesh(), dimensionedScalar("one", dimless, 1.0) ) ); surfaceScalarField&amp; ddtCouplingCoeff = tddtCouplingCoeff.ref(); if (ddtPhiCoeff_ &lt; 0) &#123; ddtCouplingCoeff -= min ( mag(phiCorr) /(mag(phi) + dimensionedScalar("small", phi.dimensions(), SMALL)), scalar(1) ); &#125; else &#123; ddtCouplingCoeff = dimensionedScalar("ddtPhiCoeff", dimless, ddtPhiCoeff_); &#125; surfaceScalarField::Boundary&amp; ccbf = ddtCouplingCoeff.boundaryFieldRef(); forAll(U.boundaryField(), patchi) &#123; if ( U.boundaryField()[patchi].fixesValue() || isA&lt;cyclicAMIFvPatch&gt;(mesh().boundary()[patchi]) ) &#123; ccbf[patchi] = 0.0; &#125; &#125; if (debug &gt; 1) &#123; InfoInFunction &lt;&lt; "ddtCouplingCoeff mean max min = " &lt;&lt; gAverage(ddtCouplingCoeff.primitiveField()) &lt;&lt; " " &lt;&lt; gMax(ddtCouplingCoeff.primitiveField()) &lt;&lt; " " &lt;&lt; gMin(ddtCouplingCoeff.primitiveField()) &lt;&lt; endl; &#125; return tddtCouplingCoeff;&#125; 这样使得可以这个系数可以手工调整。 他们所引用的参考文献22 暂时没找到全文 关于p,pFinal的选择仔细的哥们儿会发现simpleFoam里用的是pEqn.solve()，到了icoFoam, pisoFoam和pimpleFoam里用的就是pEqn.solve(mesh.solver(p.select(piso/pimple.finalInnerIter())))。 这里的区别，还是看代码吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//src/finiteVolume/cfdTools/general/solutionControl/pimpleControl/pimpleControlI.H +92//最后一步内迭代，也就是最后一次用PISO求解压力且是非正交修正的最后一步时返回true，否则返回falseinline bool Foam::pimpleControl::finalInnerIter() const&#123; return corrPISO_ == nCorrPISO_ &amp;&amp; corrNonOrtho_ == nNonOrthCorr_ + 1;&#125;//src/OpenFOAM/fields/GeometricFields/GeometricField/GeometricField.C +985//true，也就是最后一次迭代时返回名字`pFinal`，否则返回名字`p`template&lt;class Type, template&lt;class&gt; class PatchField, class GeoMesh&gt;Foam::word Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;::select( bool final) const&#123; if (final) &#123; return this-&gt;name() + "Final"; &#125; else &#123; return this-&gt;name(); &#125;&#125;// src/OpenFOAM/matrices/solution/solution.C +353// 返回name对应的solver controls dictionaryconst Foam::dictionary&amp; Foam::solution::solver(const word&amp; name) const&#123; if (debug) &#123; Info&lt;&lt; "Lookup solver for " &lt;&lt; name &lt;&lt; endl; &#125; return solvers_.subDict(name);&#125;//src/finiteVolume/fvMatrices/fvMatrix/fvMatrixSolve.C +55//按这个solverControls来解template&lt;class Type&gt;Foam::SolverPerformance&lt;Type&gt; Foam::fvMatrix&lt;Type&gt;::solve( const dictionary&amp; solverControls) 结论：simpleFoam是稳态求解器，所以没有pFinal一说，所以用不着这套复杂的机制。 关于收敛判据和求解控制对于不可压缩流动而言， 收敛判据只取决于两个问题， 连续性方程是否得到满足，在多大程度上得到满足？ OpenFOAM里是用#include &quot;continuityErrs.H&quot;来计算、记录和输出这一项的。 程序开始时还需要用 include &quot;initContinuityErrs.H&quot; 初始化一下。 它用的是phi而不是U 它会记录累计误差cumulativeContErr，全场流量平衡误差globalContErr，以及局部误差的和sumLocalContErr（最后一项几乎等价于速度场散度的L1模：$|\nabla\cdot U|_{L1}$） 事实上这点比较简单，因为每次计算压力的时候都是力图使连续性方程得到满足的。 而且这一项与非定常项无关。 动量方程在多大程度上得到满足： 这点在OpenFOAM里是通过对动量方程的求解来满足的。 其实OpenFOAM并没有对其进行严格地度量（指L1, L2模这样的数学度量）。 对于稳态算法SIMPLE，看最终一步的动量方程的的初始残差； 对于非稳态算法（PISO, PIMPLE等）输出中的每个时间步最后一次外迭代时，动量方程的初始残差可以认为是一个度量，但是它并不完全一致和严格。 每个时间步 是因为非稳态算法一般是需要进行时间精确模拟的。如果这个时间步没有收敛，这个时间步就不对，并且会影响到下一个时间步。 最后一次 是因为前面的算是中间过程，最后并不保存下来； 外迭代是因为内迭代是解耦计算，有时候看上去残差很小，可能并没有卵用，一耦合残差又超级大。 对SIMPLE对应着simple.loop() 对PIMPLE对应着pimple.loop() 初始残差是因为OpenFOAM输出的残差都是线性求解器输出的，而其中线性求解器输出的只有初始残差是和非线性残差是一致的。 经过线性求解器的迭代，线性残差可能会很小，甚至到机器零； 但是这个解只有对初始解产生的矩阵系数是对的，如果把矩阵系数按照得到的解重新计算，得到的残差才算是非线性残差（严格说来也不完全一样，但是差不多啦）； 这个非线性残差小才算是收敛 ； 另外，即使非线性残差小不代表误差小； 时间步很大时，网格很粗时，即使残差为0，误差也可能很大； 实际得到的解因为是最后一次外迭代完成之后的解，一般来说其非线性残差可能会比输出中的初始残差更小一些。但是这个数据并没有被计算和输出。 参考OpenFOAM的残差定义 参考资料 1. MATHEMATICS, NUMERICS, DERIVATIONS AND OPENFOAM® &#8617; 2. Patankar, S. V. and Spalding, D.B. (1972), “A calculation procedure for heat, mass and momentum transfer in three-dimensional parabolic flows”, Int. J. of Heat and Mass Transfer, Volume 15, Issue 10, October 1972, Pages 1787-1806 &#8617; 3. Pressure Correction Scheme for Incompressible Fluid Flow &#8617; 4. S.V. Patankar. Numerical Heat Transfer and Fluid Flow. Hemisphere, 1980 &#8617; 5. Caretto L.S., Gosman A.D., Patankar S.V., Spalding D.B. (1973) Two calculation procedures for steady, three-dimensional flows with recirculation. In: Cabannes H., Temam R. (eds) Proceedings of the Third International Conference on Numerical Methods in Fluid Mechanics. Lecture Notes in Physics, vol 19. Springer, Berlin, Heidelberg &#8617; 6. http://thevisualroom.com/poisson_for_pressure.html &#8617; 7. Lee S L, Tzong R Y. Artificial pressure for pressure-linked equation[J]. International journal of heat and mass transfer, 1992, 35(10): 2705-2716. &#8617; 8. http://dyfluid.com/RhieChow.html &#8617; 9. Nonlinear Systems: Picard and Newton methods &#8617; 10. 林建忠，《流体力学》 &#8617; 11. DISCUSSION ON MOMENTUM INTERPOLATION METHOD FOR COLLOCATED GRIDS OF INCOMPRESSIBLE FLOW. Bo Yu, Wen-Quan Tao, Jin-Jia Wei, Yasuo Kawaguchi, Toshio Tagawa &amp; Hiroyuki Ozoe. Numerical Heat Transfer, Part B: Fundamentals Vol. 42 , Iss. 2,2002 &#8617; 12. CS205b/CME306 Lecture 16 &#8617; 13. Collocated grids &#8617; 14. Operator Splitting &#8617; 15. Issa, R. I. (1986). Solution of the implicitly discretised fluid flow equations by operator-splitting. Journal of computational physics, 62(1), 40-65. &#8617; 16. Van Doormaal, J. P., &amp; Raithby, G. D. (1984). Enhancements of the SIMPLE method for predicting incompressible fluid flows. Numerical heat transfer, 7(2), 147-163. &#8617; 17. Numerics Improvements and Validation Results: FOAM-Extend Update on Work-in-Progress &#8617; 18. Moukalled, F., Mangani, L., &amp; Darwish, M. (2016). The finite volume method in computational fluid dynamics. &#8617; 19. Yu, B., Tao, W. Q., Wei, J. J., Kawaguchi, Y., Tagawa, T., &amp; Ozoe, H. (2002). Discussion on momentum interpolation method for collocated grids of incompressible flow. Numerical Heat Transfer: Part B: Fundamentals, 42(2), 141-166. &#8617; 20. S. K. Choi, Note on the Use of Momentum Interpolation Method for Unsteady Flows, Numer. Heat Transfer A, vol. 36, pp. 545-550, 1999. &#8617; 21. Vuorinen, V., Keskinen, J. P., Duwig, C., &amp; Boersma, B. J. (2014). On the implementation of low-dissipative Runge–Kutta projection methods for time dependent flows using OpenFOAM®. Computers &amp; Fluids, 93, 153-163. &#8617; 22. Knacke, T. (2013). Potential effects of Rhie &amp; Chow type interpolations in airframe noise simulations. In: Schram, C., Dénos, R., Lecomte E. (ed): Accurate and efficient aeroacoustic prediction approaches for airframe noise, VKI LS 2013-03. &#8617;]]></content>
      <categories>
        <category>OpenFOAM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>OpenFOAM</tag>
        <tag>SIMPLE</tag>
        <tag>PISO</tag>
        <tag>PIMPLE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rhoCentralFoam解析]]></title>
    <url>%2F2018%2F01%2F05%2FrhoCentralFoam%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[rhoCentralFoam是OpenFOAM中一个基于密度的可压缩求解器，算超声速通常用它比较合适。但是网上缺乏对其程序的分析，本文结合开发者的原始文献对其进行简单分析。 rhoCentralFoam解析概念首先明确一些关键概念。 半隐式分离求解器首先从代码来看这是一个半隐式(semi-implicit)的分离(segregate)求解器： 半隐式的意思是代码中只有部分项是隐式的，而另一些项是显式的，参考文献Semi-Implicit Time Differencing认为半隐式格式的时间步长其实不太有较大优势，除非显式部分的能量占比很小。 这种半隐式体现在不同的项上，比如粘性项：$\mathbf \tau = \nabla\cdot(\mu \nabla \mathbf u )+\mathbf\tau_{MC}= \{ \nabla\cdot(\mu \nabla \mathbf u ) \}^{n+1} +\{ (\nabla\mathbf u)^T - \frac 2 3 (\nabla\cdot\mathbf u) \mathbf I\}^{n}$ 没有转置的第一项就可以隐式离散，但是后面的就不行，由于OpenFOAM实现方式的限制，暂时只能用显式离散。 这种半隐式还体现在非线性项上，主要是为了把非线性方程线性化：$\rho u u = [\rho u ]^{n} \times u^{n+1}$ 其实非线性方程线性化有两种方法：Newton方法和Picard方法。Newton方法是对增量进行求解，通常会用到Jacobian矩阵或者其近似矩阵，而Picard方法是直接对全量求解，从实现角度来看可能更简单，但是收敛会更慢，不过从实践来讲，通常计算物理和计算数学界的人偏好用Jacobian矩阵，而CFD界的人似乎因为传统更喜欢用Picard迭代。 分离的意思是它是先求解密度、再求解速度和能量方程的，而在求解密度的时候认为速度和能量是不变的，而求解速度的时候，密度已经更新过了，这会导致变量的一致性问题，比如文章中提到的温度T如果不做处理可能出现负值的问题。 界面数值通量的处理和实现可压缩流的关键问题在于界面数值通量的处理，rhoCentralFoam采用的是KT或KNP格式，在system/fvScheme中有一个fluxScheme关键字（程序中的type是word ），如果是Kurganov，那么就是KNP中心上风格式，如果是Tamdor，则是KT中心格式。tutorial中自带算例一般是Kurganov，即KNP中心上风格式。 在离散过程中，由于OpenFOAM本身没有提供同时取得界面两侧插值的功能，所以rhoCentralFoam是自己实现的。方法是利用辅助用途的表面张量场pos和neg来制定界面物理量的插值方向。pos和neg的源代码如下： 12345678910111213141516171819202122232425/*createFields.H*///line 64surfaceScalarField pos //表面张量场( IOobject ( "pos", runTime.timeName(), mesh ), mesh, dimensionedScalar("pos", dimless, 1.0) //无量纲);surfaceScalarField neg( IOobject ( "neg", runTime.timeName(), mesh ), mesh, dimensionedScalar("neg", dimless, -1.0)); 具体的获取某个界面(face)某个方向的插值操作是通过interpolate函数完成的，函数定义如下面的代码，当传入的faceFlux是正的（如pos），那么就用这个face的owner侧的插值，否则用face的neighbour侧的插值，具体的插值算法又由name参数指定，系统会从fvScheme配置文件中找指定的插值方法。 1234567891011/*src\finiteVolume\interpolation\surfaceInterpolation\surfaceInterpolation\surfaceInterpolation.H*///line 98 //- Interpolate field onto faces using scheme given by name in fvSchemes template&lt;class Type&gt; //函数模板 //static静态函数，tmp对象避免对象传递时析构构造的开销 static tmp&lt;GeometricField&lt;Type, fvsPatchField, surfaceMesh&gt;&gt; interpolate ( const GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; tvf, const surfaceScalarField&amp; faceFlux, const word&amp; name ); 权重以及文章中公式的错误文章和编程中有两个权重，一个是插值权重，也就是界面物理量和周围单元(owner和neighbour)物理量的关系：文章中公式11.5(公式11和12之间的未编号公式)如下： \mathbf{\Psi}_f=(1-g_{f+})\mathbf{\Psi}_P+g_{f+}\mathbf{\Psi}_N\\ g_{f+}=\beta(r)(1-w_f)\\ \beta(r)=\frac{r+|r|}{1+r},\text{ van Leer limiter}\\ w_f = \frac{|\mathbf{S}_f\cdot\mathbf{d}_{fN}|}{|\mathbf{S}_f\cdot\mathbf{d}_{}|} \text{ weighting coefficient}其中$\mathbf{\Psi}_f, \mathbf{\Psi}_P, \mathbf{\Psi}_N$ 分别代表界面，owner和neighbour网格中心的物理量。 $g_{f+}$表示插值权重。 $w_f$ 是权重因子。 $\beta(r)$是限制器，而参数$r$ 表示两侧的梯度和平均梯度的函数。 另一个是重构的权重，只涉及界面两侧的量，KT和KNP的区别只在于重构权重的选取方式不一样。在文章中的表示方式是： \sum_f{\phi_f\mathbf{\Psi}_f}= \sum_f{[\alpha\phi_{f+}\mathbf{\Psi}_{f+}+(1-\alpha)\phi_{f-}\mathbf{\Psi}_{f-}+ \omega_f(\mathbf{\Psi}_{f-}-\mathbf{\Psi}_{f+}) ]}其中$\omega_f$是起耗散作用的，只有在对流项中使用，因为用得比较频繁，所以代码实现和文中公式有一些不一致，代码实现如下： \sum_f{\phi_f\mathbf{\Psi}_f}= \sum_f{[(\alpha\phi_{f+}+\omega_f)\mathbf{\Psi}_{f+}+((1-\alpha)\phi_{f-}-\omega_f)\mathbf{\Psi}_{f-}]}此外，这个重构权重的公式有个错误就是扩散项的符号不对，扩散项中$\mathbf{\Psi}_{f\pm}$的权重和代码实现是相反的，个人认为代码实现应该是对的，文章中是错误的。 fvc::div和fvc::ddt的量纲问题还有一个问题是OF中的fvc::div($\phi,\alpha$)和数学$\nabla\cdot(\phi\alpha)$是不一样的，fvc::div除以了体积V： \text{fvc::div}(\phi,\alpha)=\frac{\sum_f{\phi_f\alpha_f}}{V}这点从代码可以看出：123/*src/finiteVolume/finiteVolume/fvc/fvcSurfaceIntegrate.H*///line:104 ssf.dimensions()/dimVol, 而fvc::ddt($\alpha$)和数学上一致，以Euler格式为例:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*src\finiteVolume\finiteVolume\ddtSchemes\EulerDdtScheme\EulerDdtScheme.C*///line: 102template&lt;class Type&gt;tmp&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&gt;EulerDdtScheme&lt;Type&gt;::fvcDdt( const GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; vf)&#123; dimensionedScalar rDeltaT = 1.0/mesh().time().deltaT(); IOobject ddtIOobject ( "ddt("+vf.name()+')', mesh().time().timeName(), mesh() ); if (mesh().moving()) &#123; return tmp&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&gt; ( new GeometricField&lt;Type, fvPatchField, volMesh&gt; ( ddtIOobject, rDeltaT* ( vf() - vf.oldTime()()*mesh().Vsc0()/mesh().Vsc() ), rDeltaT.value()* ( vf.boundaryField() - vf.oldTime().boundaryField() ) ) ); &#125; else &#123; return tmp&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&gt; ( new GeometricField&lt;Type, fvPatchField, volMesh&gt; ( ddtIOobject, rDeltaT*(vf - vf.oldTime()) //显然如果vf的量纲是D,那么ddt(vf)的量纲是D/T ) ); &#125;&#125; 翻译成公式是： \text{fvc::ddt}(\alpha)=\frac{1}{\Delta t}(\alpha^n-\alpha^{n-1})这样OpenFOAM的代码中的公式量纲才是正确的。 参考1 1. fvc::div的前后量纲关系到底是啥？ &#8617; 个人认为OpenFOAM很多时候的做法是为了减少计算量： 比如喜欢用界面通量，避免存面矢量场，用面标量场就够了； 有些内部实现是不带单位的数组，而不是带单位的dimensionedField 总体算法更多的细节参考文章中的算法，在文中第14页 while t&lt;$t_{end}​$ do t := t+ dt 利用van Leer限制器，从单元场$\rho,\mathbf{\hat u},T$中插值得 到 $\rho_{f \pm},\mathbf{\hat u}_{f\pm},T_{f\pm}$ 计算 $\mathbf{u}_{f\pm}=\mathbf{\hat u}_{f\pm}/\rho_{f\pm}$ $p_{f\pm}=\rho_{f\pm} RT_{f\pm}$ $\phi_{f\pm}=\mathbf{S}_f\cdot\mathbf{u}_{f\pm}$ $c_{f\pm}=\sqrt{\gamma R T_{f\pm} }$ 根据公式7-13计算对流导数和$\nabla p$ 更新$\mathbf{T}_{exp},\mu,k$ 根据方程1求解密度$\rho$ 根据方程18求解质量流率$\mathbf{\hat u}$(无粘动量预测步) 更新$\mathbf{u}=\mathbf{\hat u}/\rho​$ 根据方程19求解速度$\mathbf{u}​$(扩散速度修正步) 根据方程20求解能量流率$\hat{E}​$(无粘能量预测步) 根据$\hat{E},\mathbf u,\rho$更新温度$T$ 根据方程21求解温度$T$(扩散温度修正步) 更新压力$p=\rho R T​$ end while 但是文章是在OpenFOAM 1.5中实现的，在现在的OpenFOAM中的rhoCentralFoam实现有点儿不一样的地方，比如能量方程的求解不是求温度T了，而是直接求解内能e。 粘性应力项根据文章内容和公式4，rhoCentralFoam没有考虑体积粘性，文中的公式为： \mathbf T = -2\mu \times\text{dev}(\mathbf D) \\ = -2\mu \times\text{dev}(\frac 1 2 [\nabla \mathbf u+\nabla (\mathbf u)^T])\\ = -2\mu\times \{\frac 1 2 [\nabla \mathbf u+\nabla (\mathbf u)^T]-\frac 1 3 tr(\nabla \mathbf u+\nabla (\mathbf u)^T)\mathbf I\}\\ = -\mu[\nabla \mathbf u+\nabla (\mathbf u)^T]-\frac 2 3\mu(\nabla\cdot \mathbf u) \mathbf I\\ = -\mu\nabla \mathbf u-\mu[\nabla (\mathbf u)^T+\frac 2 3 (\nabla\cdot \mathbf u) \mathbf I]这个最终公式是有点奇怪的，一是它的符号和常规的推导是相反的，通常粘性应力是正的。二是它的形式和可压缩流的粘性应力有一定区别。 关于可压缩流粘性应力、第二粘性系数、体积粘性参考文献A note on Stokes’ hypothesis，总应力$\mathbf S$可以表示为： \mathbf S = -p_e \mathbf I + \mathbf T其中$p_e$表示热力学平衡压力，负号表示压力向内为正。 而$\mathbf T$表示粘性应力，是变形率的函数，变形率可以用速度的梯度$\nabla\mathbf u$来表征，而根据应力应和刚体旋转部分不想关的要求，在将速度梯度进行加法分解之后，$\nabla\mathbf u=\mathbf E+\mathbf \Omega = \frac 1 2 (\nabla\mathbf u+(\nabla\mathbf u)^T)+\frac 1 2 (\nabla\mathbf u-(\nabla\mathbf u)^T)$，再考虑到应力和应变率对称性的要求，应力的函数形式为： \mathbf T = \lambda (\nabla \cdot \mathbf u) \mathbf I + 2\mu \mathbf E =\lambda (\nabla \cdot \mathbf u) \mathbf I +\mu[\nabla\mathbf u+(\nabla\mathbf u)^T]其中$\mu$被称为动力粘性系数，也就是通常所说的粘性系数。$\lambda$就是第二粘性系数。 再进一步地将$\mathbf E$分解为各向同性部分和偏量部分： \mathbf E = \mathbf A+\mathbf D=\frac 1 3 (\nabla \cdot \mathbf u) \mathbf I +(\mathbf E-\mathbf A)则粘性力可以表示为： \mathbf T = (\lambda+\frac 2 3 \mu) (\nabla \cdot \mathbf u) \mathbf I + 2\mu \mathbf D =\kappa(\nabla \cdot \mathbf u) \mathbf I + 2\mu \mathbf D总应力可以表示为： \mathbf S = [-p_e+(\lambda+\frac 2 3 \mu) (\nabla \cdot \mathbf u)] \mathbf I + 2\mu \mathbf D= [-p_e+\kappa (\nabla \cdot \mathbf u)] \mathbf I + 2\mu \mathbf D其中$-p_e+(\lambda+\frac 2 3 \mu) (\nabla \cdot \mathbf u)$被称之为机械压力(mechanical pressure)。而$\kappa$被称为体积粘性系数，这就引入了Stokes假设 Stokes 假设明显可以看出，两种条件下机械压力和热力学平衡压力相同，那就是 不可压缩流动：$\nabla \cdot \mathbf u =0$ 满足Stokes 假设: $\kappa=\lambda+\frac 2 3 \mu=0$ 实际上 对于单原子分子气体，动理学理论(kinetic theory)认为体积粘性为0，Stokes假设成立，少量试验证据也证实了这一点，而且一些研究认为动理学理论隐含假设了体积粘性为0； 对于多原子分子气体，由于存在内部自由度，而体积粘性和达到局部平衡的延迟有关，所以不为0，试验结果也发现体积粘性不可忽略，对于N2和O2，$\kappa = O(1)\mu$，对于CO2，$\kappa = O(1000)\mu$ 对于许多液体而言，$\kappa &gt;&gt; \mu$ 体积粘性的影响可以用无量纲数$\frac{\kappa\nabla\cdot\mathbf u}{p_e}​$来表征，对于绝大多数情况这个影响是可以忽略的，但是存在例外情况。 CO2中的高超声速流动和激波（火星再入？）； 高频声波； 在rhoCentralFoam文章中，假设了体积粘性为0，那么是怎么实现的呢？ 粘性项的FVM编程实践在有限体积离散中，需要把尽可能多的项用采用Gauss公式用面积分的方式表达，上述式子中的$\mathbf D,\mathbf E$等量在物理上是好东西，但是在FVM实现中比较麻烦，尤其是难以表达成隐式方式，所以在FVM中还是尽量多地用$\nabla\cdot \mathbf u,\nabla \mathbf u$等表达方式。 因此，《The finite volume method in computational fluid dynamics: an advanced introduction to OpenFOAM and Matlab》中的公式3.37中，将粘性应力分为了两部分。 \frac \partial {\partial t}[\rho \mathbf u] +\frac \partial {\partial x}[\rho \mathbf u \mathbf u] = -\nabla p +\{ \nabla\cdot[\mu\nabla\mathbf u] \}_1 +\{ \nabla\cdot[\mu\nabla\mathbf u]^T +\nabla(\lambda\nabla\cdot\mathbf u) \}_2 +\mathbf f_b引入假设$\kappa=\lambda+\frac 2 3 \mu=0$，上式可化为： \frac \partial {\partial t}[\rho \mathbf u] +\frac \partial {\partial x}[\rho \mathbf u \mathbf u] = -\nabla p +\{ \nabla\cdot[\mu\nabla\mathbf u] \}_1 +\{ \nabla\cdot[\mu\nabla\mathbf u]^T -\frac 2 3 \nabla(\mu\nabla\cdot\mathbf u) \}_2 +\mathbf f_b其中第1部分是可以用fvm::laplacian(mu,U)实现隐式处理，剩下的第2部分采用deferred correction approach的方法代入源项中处理。在rhoCentralFoam的代码具体实现的时候也是分成两部分的:1234567891011// Line:198 if (!inviscid) &#123; solve ( fvm::ddt(rho, U) - fvc::ddt(rho, U) - fvm::laplacian(muEff, U)//隐式处理 - fvc::div(tauMC)//显式处理 ); rhoU = rho*U; &#125; 一部分是隐式的fvm::laplacian(muEff, U)，另一部分是 显式的fvc::div(tauMC)，其计算如下。1volTensorField tauMC("tauMC", muEff*dev2(Foam::T(fvc::grad(U)))); 但是其中没有用到dev，而是用到了dev2，这俩是OpenFOAM中tensor类型的一种函数，其定义如下：12345678910111213141516/*src\OpenFOAM\primitives\Tensor\TensorI.H*/// Line: 562//- Return the deviatoric part of a tensortemplate&lt;class Cmpt&gt;inline Tensor&lt;Cmpt&gt; dev(const Tensor&lt;Cmpt&gt;&amp; t)&#123; return t - SphericalTensor&lt;Cmpt&gt;::oneThirdI*tr(t);&#125;//- Return the deviatoric part of a tensortemplate&lt;class Cmpt&gt;inline Tensor&lt;Cmpt&gt; dev2(const Tensor&lt;Cmpt&gt;&amp; t)&#123; return t - SphericalTensor&lt;Cmpt&gt;::twoThirdsI*tr(t);&#125; 代码翻译成公式是： \tau_{MC} = \mu_{\text{eff}}\cdot \text{dev2}((\nabla\mathbf u)^T) =\mu_{\text{eff}}\cdot \{ (\nabla\mathbf u)^T - \frac 2 3 tr((\nabla\mathbf u)^T) \mathbf I \}\\ =\mu_{\text{eff}}\cdot \{ (\nabla\mathbf u)^T - \frac 2 3 (\nabla\cdot\mathbf u) \mathbf I \}所以可以看出，这个实现是和文章中的推导相符的，但是形式变化太大了。 变量名对照文章中的变量名和程序中很不一致。对照表如下： code variable line No. dimension 文章中的符号 equation No. comment rPsi 80 $L^2/T^2$ $\frac{dp}{d\rho}=RT$ 无 thermo模型中的变量psi的倒数 phiv_pos 93 $L^3/T$ $\phi_{f+}=\mathbf{u}_+\cdot \mathbf{S}_{f} $ 7 正向体积流量 phiv_neg 94 $L^3/T$ $\phi_{f-}=\mathbf{u}_-\cdot \mathbf{S}_{f} $ 7 反向体积流量 ap 108 $L^3/T$ $\psi_{f+}$ 8 正向体积流量权重 am 113 $L^3/T$ $-\psi_{f-}$ 8 负向体积流量权重的相反数 a_pos 119 $1$ $\alpha=\frac{\psi_{f+}}{\psi_{f+}+\psi_{f-}}$ 9-KNP KNP格式中的$\alpha$，在KT格式中为1/2 amaxSf 121 $L^3/T$ $\max(\psi_{f+},\psi_{f-})$ 无 编程需要构造出来的一个变量 aSf 123 $L^3/T$ $\omega_f= -\alpha\psi_{f-} \\ =-\frac{\psi_{f+}\psi_{f-}}{\psi_{f+}+\psi_{f-}}$ 10-KNP 公式10-KNP展开，扩散体积通量，对于物质导数中的对流项是必须的，可与公式13对照；在KT格式中有所不同 a_neg 131 $1$ $1-\alpha$ 7 phiv_pos 133 $L^3/T$ $\alpha\phi_{f+}$ 7 phiv_neg 134 $L^3/T$ $(1-\alpha)\phi_{f-}$ 7 aphiv_pos 136 $L^3/T$ $\alpha\phi_{f+}+\omega_f$ 7-变形 原文公式7中$\mathbf{\Psi}_{f+}$的系数，但是原文$\omega_f$符号有错误 aphiv_neg 137 $L^3/T$ $(1-\alpha)\phi_{f-}-\omega_f$ 7-变形 原文公式7中$\mathbf{\Psi}_{f-}$的系数，但是原文$\omega_f$符号有错误 amaxSf(第二次使用) 141 $L^3/T$ \max(\mid\alpha\phi_{f+}+ \omega_f\mid, \\ \mid(1-\alpha)\phi_{f-}-\omega_f\mid) 无 中心格式预测的幅值最大的数值单向通量 phi 159 $\frac M T$ $(\alpha\phi_{f+}+\omega_f)\rho_+ \\ + ((1-\alpha)\phi_{f-}-\omega_f)\rho_{-}$ 无 界面数值重构的质量通量 phiUp 167 $\frac M {LT^2}$ $(\alpha\phi_{f+}+\omega_f)[\rho\mathbf u]_+ \\ + ((1-\alpha)\phi_{f-}-\omega_f)[\rho\mathbf u]_- \\ +(\alpha p_++(1-\alpha)p_-)\mathbf S_f$ 无 界面数值重构的动量通量 tauMC 176 $\frac{M}{LT^2}$ $\mu_{eff}[(\nabla\mathbf u)^T - \frac 2 3 (\nabla\cdot\mathbf u) \mathbf I]$ 4 粘性应力的deferred correction显式部分 感悟程序和文献口心不一，把好好的NS方程改得面目全非。 参考 solver作者的原始文献Implementation of semi-discrete, non-staggered central schemes in a colocated, polyhedral, finite volume framework, for high-speed viscous flows DOI: 10.1002/fld.2069 《The finite volume method in computational fluid dynamics: an advanced introduction to OpenFOAM and Matlab》 A note on Stokes’ hypothesis Acta Mech 226, 3555–3559 (2015) DOI 10.1007/s00707-015-1380-9 source code 注释的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240/*rhoCentralFoam.C*/#include "fvCFD.H"#include "psiThermo.H" //热力学#include "turbulentFluidThermoModel.H"#include "fixedRhoFvPatchScalarField.H"#include "directionInterpolate.H"#include "localEulerDdtScheme.H"#include "fvcSmooth.H"// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //int main(int argc, char *argv[])&#123; #define NO_CONTROL #include "postProcess.H" #include "setRootCase.H" #include "createTime.H" #include "createMesh.H" #include "createFields.H" //pos,neg在此创建 #include "createFieldRefs.H" //热力学场psi=drho/dp的创建 #include "createTimeControls.H" turbulence-&gt;validate(); // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // //读取fluxScheme,如果是Kurganov，则为KNP格式，如果是Tamdor，则是KT格式 #include "readFluxScheme.H" dimensionedScalar v_zero("v_zero", dimVolume/dimTime, 0.0); // Courant numbers used to adjust the time-step scalar CoNum = 0.0; scalar meanCoNum = 0.0; Info&lt;&lt; "\nStarting time loop\n" &lt;&lt; endl; while (runTime.run()) &#123; // --- Directed interpolation of primitive fields onto faces surfaceScalarField rho_pos(interpolate(rho, pos)); surfaceScalarField rho_neg(interpolate(rho, neg)); //U.name()表示采用U对应的插值方法 surfaceVectorField rhoU_pos(interpolate(rhoU, pos, U.name())); surfaceVectorField rhoU_neg(interpolate(rhoU, neg, U.name())); //OpenFOAM喜欢采用rXxx表示xxx变量的倒数，不知道为什么。 //psi=drho/dp (==1/(RT) for perfect gas) //rPsi = dp/drho (==RT for perfect gas) volScalarField rPsi("rPsi", 1.0/psi); surfaceScalarField rPsi_pos(interpolate(rPsi, pos, T.name())); surfaceScalarField rPsi_neg(interpolate(rPsi, neg, T.name())); surfaceScalarField e_pos(interpolate(e, pos, T.name())); surfaceScalarField e_neg(interpolate(e, neg, T.name())); //不知为啥U_pos要这样计算而不是直接插值。 surfaceVectorField U_pos("U_pos", rhoU_pos/rho_pos); surfaceVectorField U_neg("U_neg", rhoU_neg/rho_neg); surfaceScalarField p_pos("p_pos", rho_pos*rPsi_pos); surfaceScalarField p_neg("p_neg", rho_neg*rPsi_neg); //phiv: volumetric flow across a face, [L^3/T] surfaceScalarField phiv_pos("phiv_pos", U_pos &amp; mesh.Sf());// &amp;表示矢量点积 surfaceScalarField phiv_neg("phiv_neg", U_neg &amp; mesh.Sf()); volScalarField c("c", sqrt(thermo.Cp()/thermo.Cv()*rPsi));// 声速 surfaceScalarField cSf_pos ( "cSf_pos", interpolate(c, pos, T.name())*mesh.magSf() ); surfaceScalarField cSf_neg ( "cSf_neg", interpolate(c, neg, T.name())*mesh.magSf() ); //文献公式8 surfaceScalarField ap ( "ap", max(max(phiv_pos + cSf_pos, phiv_neg + cSf_neg), v_zero) ); surfaceScalarField am ( "am", min(min(phiv_pos - cSf_pos, phiv_neg - cSf_neg), v_zero) ); surfaceScalarField a_pos("a_pos", ap/(ap - am)); surfaceScalarField amaxSf("amaxSf", max(mag(am), mag(ap))); surfaceScalarField aSf("aSf", am*a_pos); if (fluxScheme == "Tadmor") &#123; aSf = -0.5*amaxSf; a_pos = 0.5; &#125; surfaceScalarField a_neg("a_neg", 1.0 - a_pos); phiv_pos *= a_pos; phiv_neg *= a_neg; surfaceScalarField aphiv_pos("aphiv_pos", phiv_pos - aSf); surfaceScalarField aphiv_neg("aphiv_neg", phiv_neg + aSf); // Reuse amaxSf for the maximum positive and negative fluxes // estimated by the central scheme amaxSf = max(mag(aphiv_pos), mag(aphiv_neg)); #include "centralCourantNo.H" #include "readTimeControls.H" if (LTS) //local time stepping &#123; #include "setRDeltaT.H" &#125; else &#123; #include "setDeltaT.H" &#125; //上面是按原时刻计算的界面重构权重 runTime++; //下面计算出来的是新时刻的量 Info&lt;&lt; "Time = " &lt;&lt; runTime.timeName() &lt;&lt; nl &lt;&lt; endl; // 对流质量流量，含速度，用带扩散项的插值。 phi = aphiv_pos*rho_pos + aphiv_neg*rho_neg; // 对流动量流量部分用带扩散项的aphiv_pos插值 // 压力部分用a_pos插值 surfaceVectorField phiUp ( (aphiv_pos*rhoU_pos + aphiv_neg*rhoU_neg) + (a_pos*p_pos + a_neg*p_neg)*mesh.Sf() ); // 同上 surfaceScalarField phiEp ( "phiEp", aphiv_pos*(rho_pos*(e_pos + 0.5*magSqr(U_pos)) + p_pos) + aphiv_neg*(rho_neg*(e_neg + 0.5*magSqr(U_neg)) + p_neg) + aSf*p_pos - aSf*p_neg ); volScalarField muEff("muEff", turbulence-&gt;muEff()); volTensorField tauMC("tauMC", muEff*dev2(Foam::T(fvc::grad(U)))); // --- Solve density //fvc::div和数学divergence operator不完全一样，会除以体积，这样量纲才对。 solve(fvm::ddt(rho) + fvc::div(phi)); // --- Solve momentum solve(fvm::ddt(rhoU) + fvc::div(phiUp)); U.ref() = rhoU() /rho(); U.correctBoundaryConditions(); rhoU.boundaryFieldRef() == rho.boundaryField()*U.boundaryField(); if (!inviscid) &#123; solve ( fvm::ddt(rho, U) - fvc::ddt(rho, U)//注意一个是fvm::ddt，一个是fvc::ddt - fvm::laplacian(muEff, U) //隐式的部分，如果要显式实现，参考源代码206行中sigmaDotU的计算 - fvc::div(tauMC) //显式的部分 ); rhoU = rho*U; &#125; // --- Solve energy surfaceScalarField sigmaDotU//粘性力做功项 ( "sigmaDotU",//但是其实这部分不用分开成两部分计算也可以哈。 ( fvc::interpolate(muEff)*mesh.magSf()*fvc::snGrad(U)//粘性应力中Laplacian部分的计算 + fvc::dotInterpolate(mesh.Sf(), tauMC) ) &amp; (a_pos*U_pos + a_neg*U_neg) //为啥速度又要这么插值了？ ); solve ( fvm::ddt(rhoE) + fvc::div(phiEp) - fvc::div(sigmaDotU) ); e = rhoE/rho - 0.5*magSqr(U); e.correctBoundaryConditions(); thermo.correct(); rhoE.boundaryFieldRef() == rho.boundaryField()* ( e.boundaryField() + 0.5*magSqr(U.boundaryField()) ); if (!inviscid) &#123; solve ( fvm::ddt(rho, e) - fvc::ddt(rho, e) - fvm::laplacian(turbulence-&gt;alphaEff(), e) ); thermo.correct(); rhoE = rho*(e + 0.5*magSqr(U)); &#125; p.ref() = rho() /psi(); p.correctBoundaryConditions(); rho.boundaryFieldRef() == psi.boundaryField()*p.boundaryField(); turbulence-&gt;correct(); runTime.write(); Info&lt;&lt; "ExecutionTime = " &lt;&lt; runTime.elapsedCpuTime() &lt;&lt; " s" &lt;&lt; " ClockTime = " &lt;&lt; runTime.elapsedClockTime() &lt;&lt; " s" &lt;&lt; nl &lt;&lt; endl; &#125; Info&lt;&lt; "End\n" &lt;&lt; endl; return 0;&#125; 从rhoCentralFoam中得到的启示OpenFOAM没有自带实现计算界面数值通量的方法（foam_extend中有一部分），所以往往需要通过一些interpolate操作将界面左右量计算出来，再自主实现一个计算数值通量的方法，最后再进行积分。 但让人觉得疑惑的是，目前OpenFOAM的时间递进方面只有单步方法，没有线性多步法，如RK之类的。]]></content>
      <categories>
        <category>OpenFOAM</category>
        <category>rhoCentralFoam</category>
      </categories>
      <tags>
        <tag>OpenFOAM</tag>
        <tag>rhoCentralFoam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MASA的安装]]></title>
    <url>%2F2018%2F01%2F05%2FMASA%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[MASA (Manufactured Analytical Solution Abstraction) 的安装 MASA的安装MASA (Manufactured Analytical Solution Abstraction) 是一个经过验证的虚构解验证程序库，用C++写的，并提供C, python, Fortran90等其他语言的接口。可以用于对常见偏微分方程的模拟程序进行代码验证（Code Verification）。 它所包含的方程有： Heat Equation Laplace’s Equation Euler Equations (with and without thermal equilibrium chemistry) Navier-Stokes Equations Reynolds Averaged Navier Stokes with Various Turbulence Models MASA 网址: https://github.com/manufactured-solutions/MASA.git MASA 文档: http://manufactured-solutions.github.io/MASA/ 下载和编译cd git clone https://github.com/manufactured-solutions/MASA.git MASA_src cd MASA_src # check tools which gcc gfortran g++ 但是这个文件夹中没有常见的configure, CMakeLists.txt和Makefile，所以不知道怎么编译。 经过搜索，发现这个库应该用 GNU Build System 来编译。 GNU Build System的整个流程如下图所示： 所以需要的命令如下： 123456789101112131415161718# 切换到rootyum install libtool autoconf automake gcc-gfortran swig python-devel -y# 切换回来su ofusercdcd MASA_srcautoreconf -i./configure --prefix=$HOME/lib/MASA \--enable-python-interfaces \--enable-fortran-interfaces \--enable-static \--enable-warn-all \--enable-coverage \--enable-strict-tests \makemake check #FAIL: f_inshmake install 一些关于库使用的输出: ---------------------------------------------------------------------- Libraries have been installed in: /home/ofuser/lib/MASA/lib If you ever happen to want to link against installed libraries in a given directory, LIBDIR, you must either use libtool, and specify the full pathname of the library, or use the `-LLIBDIR&#39; flag during linking and do at least one of the following: - add LIBDIR to the `LD_LIBRARY_PATH&#39; environment variable during execution - add LIBDIR to the `LD_RUN_PATH&#39; environment variable during linking - use the `-Wl,-rpath -Wl,LIBDIR&#39; linker flag - have your system administrator add LIBDIR to `/etc/ld.so.conf&#39; See any operating system documentation about shared libraries for more information, such as the ld(1) and ld.so(8) manual pages. ---------------------------------------------------------------------- Libraries have been installed in: /home/ofuser/lib/MASA/lib64/python2.7/site-packages/masa If you ever happen to want to link against installed libraries in a given directory, LIBDIR, you must either use libtool, and specify the full pathname of the library, or use the `-LLIBDIR&#39; flag during linking and do at least one of the following: - add LIBDIR to the `LD_LIBRARY_PATH&#39; environment variable during execution - add LIBDIR to the `LD_RUN_PATH&#39; environment variable during linking - use the `-Wl,-rpath -Wl,LIBDIR&#39; linker flag - have your system administrator add LIBDIR to `/etc/ld.so.conf&#39; See any operating system documentation about shared libraries for more information, such as the ld(1) and ld.so(8) manual pages. ----------------------------------------------------------------------]]></content>
      <categories>
        <category>MMS</category>
      </categories>
      <tags>
        <tag>MMS</tag>
        <tag>MASA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenFOAM在docker中的使用]]></title>
    <url>%2F2018%2F01%2F05%2FOpenFOAM%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[利用docker在windows中使用OpenFOAM。利用共享文件夹功能在windows中进行前后处理。 OpenFOAM在docker中的使用操作系统：windows 10 Pro/Home docker版本：docker有两种，一种是社区版Community Edition，一种是商业版。我们采用免费的社区版，但是由于docker本质上是一个Linux程序，所以即使是社区版，在windows下使用时需要首先用虚拟机运行一个Linux平台（通常是Moby Linux），根据虚拟机平台的不同，也是有两种选择： docker for windows，这个版本是主推的版本，可以利用windows10的HyperV虚拟化平台。但是windows10需要Pro版或者旗舰版才能开启HyperV虚拟化。 docker toolbox，这个版本是比较老的，利用的是Oracle的VirtualBox进行虚拟化，但是可以在Windows10 Home版本下运行，或者在windows 7等老版本操作系统下运行。 两个版本我都会介绍到。 docker 安装下面分别介绍docker for windows和docker toolbox的安装 docker for windows对于可以开启HyperV虚拟化的windows 10 Pro或者旗舰版而言，docker for windows是最好的选择。 网址: https://www.docker.com/ 下载: Docker for Windows Installer.exe 版本: Docker version 17.09.0, 社区版中的最新稳定版。 安装指南: https://docs.docker.com/docker-for-windows/ 一路点击OK,next 安装完成后，运行Docker for Windows. 它会花费一些时间启动 docker engine. 等提示启动完成后，右键单击开始按钮，选择”Windows Powershell”。打开Powershell命令行。（用cmd也是可以的） 运行如下命令： 1234567891011121314151617181920212223242526272829303132333435docker --version## Docker version 17.09.0-ce, build afdb6d4docker-compose --version## docker-compose version 1.16.1, build 6d1ac219docker-machine --version## docker-machine.exe version 0.12.2, build 9371605docker run hello-world## ## Hello from Docker!## This message shows that your installation appears to be working correctly.## ## To generate this message, Docker took the following steps:## 1. The Docker client contacted the Docker daemon.## 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.## (amd64)## 3. The Docker daemon created a new container from that image which runs the## executable that produces the output you are currently reading.## 4. The Docker daemon streamed that output to the Docker client, which sent it## to your terminal.## ## To try something more ambitious, you can run an Ubuntu container with:## $ docker run -it ubuntu bash## ## Share images, automate workflows, and more with a free Docker ID:## https://cloud.docker.com/## ## For more examples and ideas, visit:## https://docs.docker.com/engine/userguide/docker ps -a## CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES## 32a621d46d34 hello-world "/hello" 24 seconds ago Exited (0) 23 seconds ago clever_agnesidocker rm 32a621d46d34 #change it to your container ID## 32a621d46d34 docker ps -a## CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES docker toolbox安装网址和安装指南：https://docs.docker.com/toolbox/toolbox_install_windows/ 下载：https://download.docker.com/win/stable/DockerToolbox.exe 这个docker toolbox也要求至少是64位的windows 操作系统，win 7 以上。并且在BIOS中开启了虚拟化（Virtualization，和HyperV不同） docker toolbox安装时会安装VirtualBox。 安装完成后会出现以下几个图标： 双击“Docker Quickestart”可以启动MSYS2 ，用如下命令进行测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243docker --version#Docker version 17.10.0-ce, build f4ffd25#docker-compose --version#docker-compose version 1.16.1, build 6d1ac219#docker-machine --version#docker-machine.exe version 0.13.0, build 9ba6da9#docker run hello-world##Hello from Docker!#This message shows that your installation appears to be working correctly.##To generate this message, Docker took the following steps:# 1. The Docker client contacted the Docker daemon.# 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.# (amd64)# 3. The Docker daemon created a new container from that image which runs the# executable that produces the output you are currently reading.# 4. The Docker daemon streamed that output to the Docker client, which sent it# to your terminal.##To try something more ambitious, you can run an Ubuntu container with:# $ docker run -it ubuntu bash##Share images, automate workflows, and more with a free Docker ID:# https://cloud.docker.com/##For more examples and ideas, visit:# https://docs.docker.com/engine/userguide/##docker ps -a#CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES#a8e15cba83b6 hello-world "/hello" 10 seconds ago Exited (0) 10 seconds ago musing_hamilton#docker rm a8e15cba83b6#a8e15cba83b6#docker ps -a#CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES# 至此，docker就安装好了。 下载OpenFOAM的 docker image很简单： 12345678docker pull openfoamplus/of_v1706_centos73 # OF+# or# docker pull openfoam/openfoam5-paraview54 # OF5# list imagesdocker image ls# REPOSITORY TAG IMAGE ID CREATED SIZE# hello-world latest f2a91732366c 6 weeks ago 1.85kB# openfoamplus/of_v1706_centos73 latest 9b81f0cd518b 6 months ago 1.76GB 映射共享文件夹并测试OpenFOAM共享文件夹是与docker交换数据最方便的工具。windows下的docker可以通过虚拟机的功能配合docker工具自带的映射功能，实现映射共享文件夹的功能。为了避免问题过于复杂化，本文的共享文件夹位于C:\Users\cheng目录之下，这样可以避免对虚拟机的大幅变动。如果需要共享位于其他位置的文件夹，使用docker toolbox的请参考How to use a directory outside C:\Users with Docker Toolbox on Windows，使用docker for windows的可以参考：Docker on Windows — Mounting Host Directories docker for windows: 采用powershell 12345678910111213141516171819202122232425cd c:\Users\chengmkdir OpenFOAMdocker run \-i -t \--name myOFplus_1706 \-v "/c/Users/cheng/OpenFOAM:/home/ofuser/OpenFOAM" \openfoamplus/of_v1706_centos73 \bash# 下面的代码在进入bash后输入su ofusercd mkdir -p $FOAM_RUNruncp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity ../Allrun# 想要临时退出，但不中断执行# 按Ctrl+p, Ctrl+q## 再次进入docker image的bashdocker attach myOFplus_1706 docker toolbox: 采用“Docker Quickestart”启动的仿bash界面。 123456789101112131415161718192021cd c:\Users\chengmkdir OpenFOAMdocker run \-i -t \--name myOFplus_1706 \-v "/c/Users/cheng/OpenFOAM:/home/ofuser/OpenFOAM" \openfoamplus/of_v1706_centos73 \bash# 下面的代码在进入bash后输入su ofusercd mkdir -p $FOAM_RUNruncp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity ../Allrun# 想要临时退出，但不中断执行# 按Ctrl+p, Ctrl+q docker 中的OpenFOAM环境以下命令在docker中可以查看出安装环境 1234567891011121314151617181920212223242526272829303132cd clearecho $WM_PROJECT_DIR #OpenFOAM安装位置#/opt/OpenFOAM/OpenFOAM-v1706echo $WM_THIRD_PARTY_DIR #第三方软件文件夹位置#/opt/OpenFOAM/ThirdParty-v1706echo $WM_PROJECT_VERSION#v1706echo $WM_PROJECT_USER_DIR #OpenFOAM用户文件夹位置#/home/ofuser/OpenFOAM/ofuser-v1706echo $WM_OPTIONS #编译配置#linux64GccDPInt32Opt #编译配置为# linux64:64位Linux版本# DP:双精度# Gcc: GCC编译器# Int32: 32位整型# Opt: 性能优化版本，没有调试信息。g++ --version #采用的编译器版本#g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-11)#Copyright (C) 2015 Free Software Foundation, Inc.#This is free software; see the source for copying conditions. There is NO#warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.#mpirun --version # 采用的mpi版本#mpirun (Open MPI) 1.10.4##Report bugs to http://www.open-mpi.org/community/help/ 后处理可以用paraview 进行后处理 paraview 安装 网址：https://www.paraview.org/ 下载地址：https://www.paraview.org/paraview-downloads/download.php?submit=Download&amp;version=v5.4&amp;type=binary&amp;os=Windows&amp;downloadFile=ParaView-5.4.1-Qt5-OpenGL2-Windows-64bit.exe 版本：最新稳定版：5.4.1 安装很容易。 由于windows版本的paraview没有编译安装OpenFOAM专用reader，所以需要在shell中，位于算例文件目录下用touch a.foam建立一个文件（一些教程中的touch a.OpenFOAM无效）。 后处理结果如下：]]></content>
      <categories>
        <category>OpenFOAM</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>OpenFOAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenFOAM输出完整矩阵]]></title>
    <url>%2F2018%2F01%2F04%2FOpenFOAM%E8%BE%93%E5%87%BA%E5%AE%8C%E6%95%B4%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[输出单CPU算例带耦合边界条件的fvScalarMatrix中的完整矩阵信息。 OpenFOAM输出完整矩阵背景OpenFOAM采用的特殊矩阵模式导致输出完整矩阵很困难。本文尝试解决的是输出单CPU算例带耦合边界条件的问题中的fvScalarMatrix的问题。 首先，需要限定是单CPU，否则可能存在CPU间的processorFvPatch耦合界面边界条件，fvScalarMatrix将无法包含所有的边界条件相关的源项。 其次耦合边界条件中仅支持cyclic类边界条件，jumpCyclic边界条件可能存在线性代数上的一致性问题，暂时不考虑。 再次，输出限于fvScalarMatrix，fvVectorMatrix的情况类似，但是涉及到更加复杂一些的操作。 最后，采用cnpy库输出为numpy支持的npy或npz格式，便于进一步分析，具体模式为COO模式，同时cnpy还提供了npy2mat, npz2mat, mat2npz等工具用于与matlab交换数据。 代码需要首先安装一个cnpy的小程序库，用于生成numpy和matlab可以直接读取的文件。 网址: https://github.com/rogersce/cnpy 命令行: 12345678910111213141516# 在root账户下yum install cmake git -y# `su ofuser`到ofuser账户， check toolscmake --versiong++ --versiongit --version# clone, configure, build and installgit clone https://github.com/rogersce/cnpy.git cnpy_srccd cnpy_srcmkdir buildcd buildcmake .. -DENABLE_STATIC=ON -DCMAKE_INSTALL_PREFIX=$HOME/lib/cnpymake make install 实际程序中#include如下代码：dumpFvScalarMatrix.H 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#pragma once#include "fvCFD.H"#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include"cyclicFvPatch.H"#include"cnpy.h"/**path: 想要储存的文件名Eqn: fvScalarMatrix 的常量引用*/void dumpFvScalarMatrix( const fvScalarMatrix&amp; Eqn,fileName filepath)&#123; if (filepath.hasExt() == false) &#123; filepath = filepath.ext("npz"); &#125; const label nCells = Eqn.diag().size(); const label nFaces = Eqn.lower().size(); const scalar* const __restrict__ diagPtr = Eqn.diag().begin(); const label* const __restrict__ uPtr = Eqn.lduAddr().upperAddr().begin(); const label* const __restrict__ lPtr = Eqn.lduAddr().lowerAddr().begin(); const scalar* const __restrict__ upperPtr = Eqn.upper().begin(); const scalar* const __restrict__ lowerPtr = Eqn.lower().begin(); std::vector&lt;scalar&gt; AA(nCells+2*nFaces); std::vector&lt;scalar&gt; S(nCells); std::vector&lt;scalar&gt; x0(nCells); std::vector&lt;label&gt; JR(nCells+2*nFaces); std::vector&lt;label&gt; JC(nCells+2*nFaces); auto psi=Eqn.psi(); auto s=Eqn.source(); // diag for(label cell=0;cell&lt;nCells;cell++) &#123; AA[cell]=diagPtr[cell]; JR[cell]=cell; JC[cell]=cell; S[cell]=s[cell]; x0[cell]=psi[cell]; &#125; //Upper for(label face=0;face&lt;nFaces;face++) &#123; AA[face+nCells]=upperPtr[face]; JR[face+nCells]=uPtr[face]; JC[face+nCells]=lPtr[face]; &#125; //Lower for(label face=0;face&lt;nFaces;face++) &#123; AA[face+nCells+nFaces]=lowerPtr[face]; JR[face+nCells+nFaces]=lPtr[face]; JC[face+nCells+nFaces]=uPtr[face]; &#125; //边界贡献 auto I = Eqn.internalCoeffs(); auto B = Eqn.boundaryCoeffs(); auto psib = psi.boundaryField(); forAll(psib,patchI) &#123; const fvPatch&amp; pp = psib[patchI].patch(); if(pp.coupled()) //耦合边界 &#123; if(isA&lt;cyclicFvPatch&gt;(pp)) //只处理循环边界 &#123; const cyclicFvPatch&amp; pnp= (refCast&lt;const cyclicFvPatch&gt;(pp)).neighbPatch(); forAll(pp,faceI) &#123; label cellI = pp.faceCells()[faceI]; label cellJ = pnp.faceCells()[faceI]; AA[cellI] += I[patchI][faceI]; AA.push_back(B[patchI][faceI]); JR.push_back(cellI); JC.push_back(cellJ); &#125; &#125; else //其他非循环边界的耦合边界，统统报错退出 &#123; SeriousError&lt;&lt;"Only support cyclic coupled BC!"&lt;&lt;endl; &#125; &#125; else //非耦合边界 &#123; forAll(pp,faceI) &#123; label cellI = pp.faceCells()[faceI]; AA[cellI] += I[patchI][faceI]; S[cellI] += B[patchI][faceI]; &#125; &#125; &#125; cnpy::npz_save(filepath,"AA",&amp;AA[0],&#123;AA.size()&#125;,"w"); cnpy::npz_save(filepath,"JR",&amp;JR[0],&#123;JR.size()&#125;,"a"); cnpy::npz_save(filepath,"JC",&amp;JC[0],&#123;JC.size()&#125;,"a"); cnpy::npz_save(filepath,"S",&amp;S[0],&#123;S.size()&#125;,"a"); cnpy::npz_save(filepath,"x0",&amp;x0[0],&#123;x0.size()&#125;,"a"); return;&#125; 测试基于 icoFoam的源代码建立myIcoFoam123456789101112131415161718192021runcd ..mkdir -p applications/solverscd applications/solvers# I put my solver here.pwd # /OF/OpenFOAM/-v1706/applications/solverscp $FOAM_SOLVERS/incompressible/icoFoam -r .mv icoFoam myIcoFoamcd myIcoFoammv icoFoam.C myIcoFoam.Csed -i s/icoFoam/myIcoFoam/g myIcoFoam.Csed -i s/icoFoam/myIcoFoam/g Make/filessed -i s/FOAM_APPBIN/FOAM_USER_APPBIN Make/files# 编译wmake# runruncd cavityfoamJob -screen myIcoFoam 修改myIcoFoam的代码，输出pEqn的矩阵12345678910111213141516171819//myIcoFoam.C#include "fvCFD.H"#include "pisoControl.H"//添加#include "dumpFvScalarMatrix.H"... if (piso.finalNonOrthogonalIter()) &#123; phi = phiHbyA - pEqn.flux(); &#125; //添加 if (runTime.timeIndex()==2) &#123; Info&lt;&lt; "TimeIndex = 2, output matrix pEqn"&lt;&lt;endl; dumpFvScalarMatrix(pEqn,"Eqn.npz"); &#125;... Make/options 文件： 123456789EXE_INC = \ -I$(LIB_SRC)/finiteVolume/lnInclude \ -I$(LIB_SRC)/meshTools/lnInclude \ -I$(HOME)/lib/cnpy/include EXE_LIBS = \ -lfiniteVolume \ -lmeshTools \ -Wl,-rpath -Wl,$(HOME)/lib/cnpy/lib -L$(HOME)/lib/cnpy/lib -lcnpy python后处理python需要安装scipy，在docker下比较简单的方法是到root账户下进行安装 1234567891011# 进root账户cdcurl "https://bootstrap.pypa.io/get-pip.py" -o "get-pip.py"python get-pip.pypip install scipy# 回到ofuser账户su ofusercdpython -c "import scipy as sp;print(sp.version.version)"# 1.0.0 python后处理代码： 12345678910import numpy as npimport scipy as spdata = np.load("Eqn.npz")AA,JR,JC,S,x0 = data['AA'],data['JR'],data['JC'],data['S'],data['x0']N = S.shape[0]from scipy.sparse import coo_matrixsm = coo_matrix((AA,(JR,JC)),shape=(N,N))m = sm.toarray()print m.shape 参考 OpenFOAM －空間の離散化と係数行列の取り扱い（Spatial Discretization and Coefficient Matrix）－byFumiya Nozaki中的第38页。]]></content>
      <categories>
        <category>OpenFOAM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenFOAM的残差定义]]></title>
    <url>%2F2018%2F01%2F04%2FOpenFOAM%E7%9A%84%E6%AE%8B%E5%B7%AE%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[关于OpenFOAM中残差定义的具体实现 关于normFactor根据代码，OpenFOAM求解器输出的标量残差initialResidual为量化的向量$L1$ 模。 定义为: Res = \frac{|r|_1}{normFactor}= \frac{|s-A\cdot x|_1}{|A\cdot x^0 - A\cdot W \cdot x^0|_1+|s - A\cdot W\cdot x^0|_1+\epsilon}其中$W$是有效权重矩阵 W= \frac 1 N \begin{bmatrix} 1 & 1 & \dots &1 &1 \\ 1 & \vdots & \ddots &\vdots & 1 \\ 1 & \dots & \dots & 1 & 1 \\ \end{bmatrix}_{N\times N} = \begin{bmatrix} 1 \\ 1 \\ \vdots \\ 1\\ 1 \end{bmatrix}_{N\times1} \times \begin{bmatrix} \frac 1 N & \frac 1 N & \dots &\frac 1 N &\frac 1 N \end{bmatrix} _{1\times N}\\ =S\cdot M$S$代表对矩阵行和算子，$M$ 代表对列向量的平均算子。 $\epsilon$是非常小量，OpenFOAM常定义为+1e-20。 向量$L1$模的定义为：$|x|_1= \sum_i{|x_i|}$ 但是要做MMS比较需要用到函数的L1模： |r|_{L1}=\frac{\int_{\Omega}{|r|dx}}{\int_{\Omega}{dx}} \approx \frac{\sum_i{V_i |r|}}{\sum_i V_i}与向量$L1$模相比，相差了一个单元体积的权重。 我想这部分解释了为何学术界的文章里残差收敛特别快，而OpenFOAM总是收敛到一定程度就收敛不下去了，因为OpenFOAM的残差采用的normFactor每次都在随$x^0​$变化，随着解的收敛，normFactor在减小，从而导致OpenFOAM输出的残差收敛速度降低。 1234567891011121314151617181920212223242526272829303132333435//PCG.C:107... // --- Calculate normalised residual norm solverPerf.initialResidual() = gSumMag(rA, matrix().mesh().comm()) //this is the vector L1 norm向量L1模 /normFactor;...//lduMatrixSolver.C:175Foam::scalar Foam::lduMatrix::solver::normFactor( const scalarField&amp; psi, const scalarField&amp; source, const scalarField&amp; Apsi, scalarField&amp; tmpField) const&#123; // --- Calculate A dot reference value of psi matrix_.sumA(tmpField, interfaceBouCoeffs_, interfaces_); //tmpField = A*S tmpField *= gAverage(psi, matrix_.lduMesh_.comm()); //tmpField = A*S*M*x0 // normFactor = |A*x0-A*S*M*x0|_1+|s-A*S*M*x0|_1+eps return gSum ( (mag(Apsi - tmpField) + mag(source - tmpField))(), matrix_.lduMesh_.comm() ) + solverPerformance::small_; // At convergence this simpler method is equivalent to the above // return 2*gSumMag(source) + solverPerformance::small_;&#125;]]></content>
      <categories>
        <category>OpenFOAM</category>
      </categories>
      <tags>
        <tag>OpenFOAM</tag>
        <tag>coupledBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenFOAM的耦合边界处理]]></title>
    <url>%2F2018%2F01%2F04%2FOpenFOAM%E7%9A%84%E8%80%A6%E5%90%88%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于OpenFOAM中耦合边界的具体实现 OpenFOAM的耦合边界处理摘要首先，在计算机里，大量的矩阵其实是稀疏矩阵，而矩阵的表示方式都是非零元素（non-zero elements）和索引（index，即元素所在行列号，本文按照c语言的约定，从0开始）分开的。这是稀疏矩阵算法的特殊性，所以指明OpenFOAM中的矩阵时，需要同时制定非零元素的存放之处和索引的存放之处。 而常见的稀疏矩阵的表示方式有： 序列对角模式：对于对角阵而言，如果是按照对角顺序储存非零元素，可以无需储存索引； 坐标对角模式：对于对角阵而言，如果没有按照对角顺序储存非零元素，需要一列坐标指定对角元素顺序； COO坐标模式：有三列数组，一列储存非零元素，一列储存行号，一列储存列号，是最广义可用的稀疏矩阵储存模式，但是往往有信息的冗余； CSR/CSC压缩行/列模式：一列储存非零元素（先从上到下行号递增，再从左到右列号递增），一列储存行号，一列储存压缩后的列号，这也是OpenFOAM的lduAddress类实际采用的储存格式； Banded，带状储存模式：对于带状结构，可以采用此种模式，对于一维问题，矩阵一般来说都是带状的，但是对于三维问题，很难是窄带结构的； 实际上，OpenFOAM采用的是一种极为特殊的分割储存的COO模式，常见教材称之为LDU分裂模式，常记为$A=L+D+U$，其中$L,D,U$分别代表矩阵$A$的下三角部分（行号大于列号），对角部分和上三角部分（行号小于列号）。但是其实它远比上述LDU分裂（或者称之为LDU加法分解，注意与矩阵的LU乘法分解的区别）要复杂得多。 记号首先引入以下记号和符号： $N_i$，第i个处理器中的单元数，$\sum_i {N_i} = N$为单元总数。由于OpenFOAM是cell-center based FVM，所以$N$就是求解的自由度数，也就是待求解变量集合$x$的维度； 同理，$x$也可以视为各个处理器上待求解变量$x_i$的垂直连接（vertical concatenation）$x=x_0||x_1||x_2||x_3||\dots||x_{N-1}$ x= \begin{bmatrix} x_0\\ x_1\\ \vdots\\ x_i\\ \vdots\\ x_{N-1} \end{bmatrix} $F_i$为第i个处理器中的总面数（一般等于网格中的owner数），$K_i$为内部面数（一般等于网格中的neighbour数），$P_i$为边界面数（$F_i=K_i+P_i$） 但是边界面分为两种，耦合边界（coupled BC, 在OpenFOAM中等价于interface，fvPatch::coupled()返回true）和非耦合边界（普通边界），第i个处理器中的第c号耦合边界的面数记为$ C_{i,c}$，第r号普通边界的面数记为$R_{i,r}$。 耦合边界和普通边界的相同点和区别在于，他们都有一些面，实现为patchField()，每个面的owner对应的内部单元internalField()，但是普通边界的面外侧没有单元，而耦合边界外侧是它所对应的另一个耦合边界，在实现的时候记为neighbPatch()， neighbPatch 是有内部单元的，这些neighbPatch的内部单元在原耦合边界中实现为patchNeighbourField() 有了internalField()和patchNeighbourField()，耦合边界的处理起来很多时候其实就和内部边界面差不多了。 网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。 简单的情况下（没有AMI, ACMI等复杂的边界条件时），整个问题总的面数为$F=\sum_i{F_i}-\sum_{i}\sum_c{C_{i,c}}$ 记总的矩阵为$A$，大小为$N\times N$，按处理器可以分裂为$A_i$和耦合系数矩阵$I^C_{i,c}$和$B^C_{i,c}$。排列如下： A= \begin{bmatrix} A_0 & 0\\ 0 &A_1 & 0 \\ 0 &0 & A_2 & 0\\ 0 &\vdots &\vdots &\vdots \\ 0 &\dots & \dots &\dots &A_i &0 \\ 0 &\dots &\dots &\dots &\dots &A_{N-1} \end{bmatrix} + O $A_i=L_i+D_i+U_i+I_i$，采用LDU分裂模式表示。 $O$表示Off diagonal部分，也就是不在LDU分裂模式表示范围内的，和处理器之间的耦合边界的系数 源项为$s$，同理也可以按处理器分裂为$s_i$。 总体的方程为$A\cdot x=s$，展开之后应该是$L+D+U$ 但是在每个处理器上为$A_i\cdot x_i = A’_i\cdot x-\sum_{j}\sum_c{B^C_{j,c}x^0_j}= s_i $ $A_i = A’_i+\sum I^N = L_i+D_i+U_i+I^N_{i,c}$ 网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。 各种情况下的矩阵组成单一处理器无耦合边界情况单一处理器，无耦合边界，仅有普通边界。 此时方程$A\cdot x= s$可分解为： $[L+(D+\sum_n{I^N_n})+U]\cdot x = s’ + \sum_n{ b^N_n}$ 其中$L,D,U$的非零元素为lduMatrix中储存的lower_, diag_, upper_，$D$采用序列对角模式进行索引，没有索引，$L,D$采用COO模式，其索引分别为[lduAddr().lowerAddr(), lduAddr().upperAddr()]和 [lduAddr().upperAddr(), lduAddr().lowerAddr()]； $I^N_n,b^N_n$的非零元素分别为fvMatrix&lt;T&gt;中储存的internalCoeffs_, boundaryCoeffs_，分为若干patch进行索引，其中$I^N_n$是矩阵，采用坐标对角索引模式，对于编号n的索引为：fvm.psi().lduAddr().patchAddr(n)。而$b^N_n$是向量，但并非顺序排列的，也具有索引，索引也是fvm.psi().lduAddr().patchAddr(n)。 $s’$是内部离散和物理源汇产生的源项； 单一处理器有耦合边界情况单一处理器的耦合边界通常为cyclic循环边界条件。 此时方程$A\cdot x= s$可分解为： $[L+(D+\sum_n{I^N_n}+\sum_c{I^C_c})+U]\cdot x = s’ + \sum_n{b^N_n}+\sum_c{ B^C_c} T_c(x^0)$ 其中增加的$I^C_c, B^C_c$的非零元素依然是储存为fvMatrix&lt;T&gt;中的internalCoeffs_, boundaryCoeffs_，分为若干patch进行索引，其中$I^C_c$和$I^N_n$没有本质差别，对于编号为n的patch的索引为fvm.psi().lduAddr().patchAddr(n)。 但 $B^C_c$和 $b^N_n$ 的差别较大，一个是矩阵，一个是向量，二者量纲也不相同！$B^C_c$的索引包括行列两个索引，其中行索引还是fvm.psi().lduAddr().patchAddr(n)，列索引则是neighbPatch().faceCells() 而$T_c$ 则是element wise的坐标变换矩算子，对于$x$为标量的情形，$T_c$的作用就是单位阵。 但是$T_c$的作用可以非常复杂，比如fixedJump条件就还涉及到$x^0$ 的平移。（但是此时存在一些问题，比如0场的Amul()作用之后非0。） $x^0$表示$x$ 的旧值。 多处理器存在耦合边界的情况多处理器的耦合边界通常为processor边界条件。 此时方程$A\cdot x= s$可分解在每个处理器i上： $[L_i+(D_i+\sum_n{I^N_{i,n}}+\sum_c{I^C_{i,c}})+U_i]\cdot x_i = s’_i + \sum_n{b^N_{i,n}}+\sum_c{ B^C_{i,c}} T_{ji,c}(x^0_j)$ 注意，下标中含$i​$的量才储存在processor i的内存中。$x^0_j,j\ne i​$的访问需要通信。 一些奇怪的情形lduMatrix中定义的Amul, Tmul和residual函数采用的约定和常规数学教科书不同。 理论上Amul应该定义了$A\cdot x = (L+D+U)\cdot x ​$操作。实际上它定义的是$[L+D+U]\cdot x - \sum_c{ B^C_c} T_c(x) ​$操作，我猜这样是便于和$s​$源项直接比较。实际上A的定义应该是$L+D+U- \sum_c{ B^C_c} T_c​$ 。 Tmul同理，不过把$B^C_c​$的非零元素换成了$I^C_c​$的非零元素。 residual的约定是$s-A\cdot x$，而不是反过来。 另外，fvMatrix和lduMatrix对方程组的定义是有差别的。lduMatrix::solve()求解时给定了$L,D,U$，并传入源项$s$和边界系数$B^C_c$，求解的是$[L+D+U]\cdot x = s+\sum_c{ B^C_c} T_c(x)$。 但fvMatrix::solveSegregated()求解时，会调用lduMatrix::solve()，但在调用之前，它修改了$D=D+\sum_n{I^N_n}+\sum_c{I^C_c}$和$s=s+ \sum_n{b^N_n}$ ，再传入新的源项和边界系数。 符号表 符号 非零元素 含义 索引 大小 $D_i$ fvm.diag() 非边界贡献的对角项 序列对角模式 $N_i$ $L_i$ fvm.lower() 非边界贡献的下三角阵 COO模式fvm.lduAddr().[lowerAddr(), upperAddr()] $K_i$ $U_i$ fvm.upper() 非边界贡献的上三角阵 COO模式 fvm.lduAddr().[upperAddr(), lowerAddr()] $K_i$ $s_i$ fvm.source() 非边界贡献的源项 序列对角模式 $N_i$ $I^N_{i,r}$ fvm.internalCoeffs()[r] 第r个普通边界的对角项贡献 坐标对角模式 fvm.psi().lduAddr(). patchAddr(r) $R_{i,r}$ $I^C_{i,r}$ fvm.internalCoeffs()[c] 耦合边界的对角项贡献 坐标对角模式 fvm.psi().lduAddr(). patchAddr(c) $C_{i,c}$ $b^N_{i,n}$ fvm.boundaryCoeffs()[r] 第r个普通边界的源项贡献 坐标模式向量 fvm.psi().lduAddr().patchAddr(r) $R_{i,r}$ $B^C_{i,c}T_{ji,c}(x^0_j)$ 计算得到 第c个耦合边界的显式耦合源项贡献 同上，且false==fvm.psi().boundaryField()[patchi].coupled() $C_{i,c}$ $B^C_{i,c}$ fvm.boundaryCoeffs()[c] 第c个耦合边界的显式耦合源项贡献的系数 全局行为类似COO模式，行坐标为fvm.psi().lduAddr().patchAddr(c) 列坐标对cyclic BC 为 neighbPatch().faceCells() 对于processor BC 为另一个processor上的fvm.psi().lduAddr().patchAddr(c) $C_{i,c}$ $x^0_{j}$ fvm.psi(). boundaryField(). scalarInterfaces()[c]. patchNeighbourField() 第c个耦合边界另一侧的初值 序列对角模式 $C_{i,c}$ $T_{ji,c}$ forwardT() 第c个耦合边界的坐标变换算子，通常可表示为一个张量 这是Element Wise的操作。 3*3 参考http://sssslide.com/www.slideshare.net/fumiyanozaki96/openfoam-32087641中的38页。 fvMatrix::solveSegregated()基本结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132// fvMatrix.H +397//- Solve segregated returning the solution statistics.// Use the given solver controlsSolverPerformance&lt;Type&gt; solveSegregated(const dictionary&amp;); //声明// fvMatrixSolve.C +102template&lt;class Type&gt;Foam::SolverPerformance&lt;Type&gt; Foam::fvMatrix&lt;Type&gt;::solveSegregated( const dictionary&amp; solverControls)&#123; if (debug) &#123; Info.masterStream(this-&gt;mesh().comm()) &lt;&lt; "fvMatrix&lt;Type&gt;::solveSegregated" "(const dictionary&amp; solverControls) : " "solving fvMatrix&lt;Type&gt;" &lt;&lt; endl; &#125; GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; psi = const_cast&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp;&gt;(psi_); SolverPerformance&lt;Type&gt; solverPerfVec ( "fvMatrix&lt;Type&gt;::solveSegregated", psi.name() ); scalarField saveDiag(diag());//复制原有的diag_，注意diag_是标量数组 Field&lt;Type&gt; source(source_);//复制原有的source_，注意source_是Field&lt;Type&gt;数组 // At this point include the boundary source from the coupled boundaries. // This is corrected for the implict part by updateMatrixInterfaces within // the component loop. //源项中加入非耦合边界项，以及耦合边界项 // s' = s + boundary source (including coupled BC's contribution) //注意这里是加！ addBoundarySource(source); typename Type::labelType validComponents ( psi.mesh().template validComponents&lt;Type&gt;() ); for (direction cmpt=0; cmpt&lt;Type::nComponents; cmpt++) &#123; if (validComponents[cmpt] == -1) continue; //有时候有的分量不用求解。比如对称张量，球张量等 // copy field and source scalarField psiCmpt(psi.primitiveField().component(cmpt));//复制cmpt分量 //加入对角项不区分耦合边界和非耦合边界 //D' = D + I(边界对对角项的贡献) addBoundaryDiag(diag(), cmpt); scalarField sourceCmpt(source.component(cmpt));//源项cmpt分量 FieldField&lt;Field, scalar&gt; bouCoeffsCmpt ( boundaryCoeffs_.component(cmpt) );//边界系数的cmpt分量：非耦合边界是源项，耦合边界是邻侧系数 FieldField&lt;Field, scalar&gt; intCoeffsCmpt ( internalCoeffs_.component(cmpt) );//边界对角系数的cmpt分量 lduInterfaceFieldPtrsList interfaces = psi.boundaryField().scalarInterfaces(); //对于非耦合求解器，采用的是scalarInterfaces() // Use the initMatrixInterfaces and updateMatrixInterfaces to correct // bouCoeffsCmpt for the explicit part of the coupled boundary // conditions //先接收耦合边界发来的消息，然后把耦合边界内侧的值发出去。 //根据几个实现来看，其实并不更改sourceCmpt initMatrixInterfaces ( bouCoeffsCmpt, //用边界系数去update interfaces, //用那些耦合边界 psiCmpt, //耦合时的初值 sourceCmpt, //结果加入sourceCmpt中 cmpt //指定cmpt分量 ); //更新sourceCmpt的值 //sourceCmpt -= bouCoeffsCmpt*scalarReceiveBuf_ // s'' = s' - 耦合边界的源项贡献 //注意这里是减去 //此时源项s''中只剩下非耦合边界的贡献了。 updateMatrixInterfaces ( bouCoeffsCmpt, //用边界系数去update interfaces, psiCmpt, sourceCmpt, //结果加入sourceCmpt中 cmpt ); solverPerformance solverPerf; // Solver call solverPerf = lduMatrix::solver::New ( psi.name() + pTraits&lt;Type&gt;::componentNames[cmpt], *this, bouCoeffsCmpt, intCoeffsCmpt, interfaces, solverControls )-&gt;solve(psiCmpt, sourceCmpt, cmpt); if (SolverPerformance&lt;Type&gt;::debug) &#123; solverPerf.print(Info.masterStream(this-&gt;mesh().comm())); &#125; solverPerfVec.replace(cmpt, solverPerf); solverPerfVec.solverName() = solverPerf.solverName(); psi.primitiveFieldRef().replace(cmpt, psiCmpt); diag() = saveDiag; &#125; psi.correctBoundaryConditions(); psi.mesh().setSolverPerformance(psi.name(), solverPerfVec); return solverPerfVec;&#125;]]></content>
      <categories>
        <category>OpenFOAM</category>
      </categories>
      <tags>
        <tag>OpenFOAM</tag>
        <tag>coupledBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello World! 对公式、代码和插入图片进行测试。 测试公式 行内公式: $e^{\pi i}+1=0$ 块公式: F=\frac{Gm_1m_2}{r^2} F=\frac{Gm_1m_2}{r^2} 关于$\rho$的连续性方程 \frac{\partial \rho}{\partial t}+\vec v\cdot\frac{\partial \rho}{\partial x}=0代码CFL3D主程序中的Setup子程序声明1234567891011121314151617181920212223242526272829303132333435 subroutine setup(lw,lw2,w,mgwk,wk,nwork,iwk,iwork,itest, . jtest,ktest,maxbl,mxbli,maxgr,maxseg,nsub1, . maxxe,intmax,iitot,ncycmax,lwdat,lig,lbg,iovrlp, . qb,nblock,iviscg,jdimg,kdimg,idimg,utrans, . vtrans,wtrans,omegax,omegay,omegaz,xorig, . yorig,zorig,dxmx,dymx,dzmx,dthxmx,dthymx, . dthzmx,thetax,thetay,thetaz,rfreqt,rfreqr, . xorig0,yorig0,zorig0,time2,thetaxl,thetayl, . thetazl,itrans,irotat,idefrm,bcvali,bcvalj, . bcvalk,nbci0,nbcidim,nbcj0,nbcjdim, . nbck0,nbckdim,ibcinfo,jbcinfo,kbcinfo,bcfilei, . bcfilej,bcfilek,ngrid,ncgg,nblg,iemg,inewgg, . rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,cmxw,cmyw, . cmzw,n_clcd,clcd,nblocks_clcd,blocks_clcd, . chdw,swetw,fmdotw,cfttotw,cftmomw,cftpw, . cftvw,rmstr,nneg,ntr,windex, . ninter,iindex,nblkpt,dthetxx,dthetyy,dthetzz, . iibg,kkbg,jjbg,ibcg,dxintg,dyintg,dzintg,iiig, . jjig,kkig,ibpntsg,iipntsg,mblk2nd,nou,bou,nbuf, . ibufdim,ireq_qb,igridg,bcfiles,mxbcfil, . utrnsae,vtrnsae,wtrnsae,omgxae,omgyae,omgzae, . xorgae,yorgae,zorgae,thtxae,thtyae,thtzae, . rfrqtae,rfrqrae,icsi,icsf,jcsi,jcsf, . kcsi,kcsf,freq,gmass,damp,x0,gf0,nmds,maxaes, . aesrfdat,perturb,islavept,nslave,iskip,jskip, . kskip,bmat,stm,stmi,gforcn,gforcnm,xxn, . nsegdfrm,idfrmseg,iaesurf,maxsegdg,nmaster, . aehist,timekeep,inpl3d,nplots,nplot3d,levelg, . iadvance,xs,gforcs,xorgae0,yorgae0,zorgae0, . icouple,lfgm,nblk,limblk,isva,nblelst, . iskmax,jskmax,kskmax,ue,irdrea,nbli,nummem)# ifdef CMPLX# else use module_kwstm, only:kws_init# endif 贴图欢迎访问本博客：冰水混合物]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>公式</tag>
        <tag>图形</tag>
        <tag>测试</tag>
      </tags>
  </entry>
</search>

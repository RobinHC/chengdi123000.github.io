<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="PAl6hcQ6eWgvhZYCbNCKQmSXqnFPWKb1obkjIMZ4jm0" />



  <meta name="msvalidate.01" content="36D5F61BC8AB6B5FF7E077EEA57549E2" />


















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css" />




  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=6.0.0">






  <meta name="keywords" content="Hexo, NexT" />




  


  <link rel="alternate" href="/atom.xml" title="冰水混合物" type="application/atom+xml" />






<meta name="keywords" content="OpenFOAM, CFD, HPC, combustion">
<meta property="og:type" content="website">
<meta property="og:title" content="冰水混合物">
<meta property="og:url" content="http://chengdi123000.github.io/404.html">
<meta property="og:site_name" content="冰水混合物">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-05T15:31:57.581Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="冰水混合物">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chengdi123000.github.io/404.html"/>





  <title>OpenFOAM的不可压缩流算法 | 冰水混合物</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-106616479-2', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ca4e0f4ba2a6e2e114ba4672f3d18c0a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冰水混合物</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">程迪的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            

            
              首页
            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            

            
              关于
            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            

            
              标签
            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            

            
              分类
            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            

            
              归档
            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            

            
              日程表
            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            

            
              站点地图
            

          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            

            
              公益404
            

          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chengdi123000.github.io/2018/01/05/OpenFOAM的不可压缩流算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="程迪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰水混合物">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OpenFOAM的不可压缩流算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-05T21:16:30-05:00">2018-01-06</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenFOAM/" itemprop="url" rel="index">
                    <span itemprop="name">OpenFOAM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenFOAM/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/05/OpenFOAM的不可压缩流算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/01/05/OpenFOAM的不可压缩流算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>对不可压缩流的几个经典算法及其在OpenFOAM中的实现进行了梳理。</p>
<p>主要针对OpenFOAM 5.x版本</p>
<a id="more"></a>
<h1 id="SIMPLE-PISO和PIMPLE算法"><a href="#SIMPLE-PISO和PIMPLE算法" class="headerlink" title="SIMPLE, PISO和PIMPLE算法"></a>SIMPLE, PISO和PIMPLE算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>均质-不可压缩-无体积力-常粘性</strong>的NS方程为：</p>
<script type="math/tex; mode=display">
{ {\partial \mathbf{u} } \over {\partial t} } + \mathbf{u} \cdot \nabla \mathbf{u} =
{-{1 \over \rho} \nabla p} + {\nu \nabla^2 \mathbf{u} }\\
\nabla\cdot \mathbf{u}=0</script><p>OpenFOAM和其他的CFD软件常用来解它的算法有：</p>
<ul>
<li>SIMPLE: Semi-Implicit Method of-Pressure Linked Equations，用于稳态计算</li>
<li>PISO:= Pressure Implicit Split Operator，用于瞬态计算，可以使用的Courant数往往小于1<sup><a href="#fn_1" id="reffn_1">1</a></sup></li>
<li>PIMPLE:= Merged PISO–SIMPLE，可以使用Courant数&gt;&gt;1</li>
</ul>
<p>但是找文献和教科书对的时候你会发现很多时候算法和OpenFOAM里的实现对不上。比如wiki和cfd-online上给的SIMPLE算法描述就是（<a href="https://en.wikipedia.org/wiki/SIMPLE_algorithm" target="_blank" rel="noopener">Wiki: SIMPLE Algorithm</a>）：</p>
<ol>
<li>修正边界条件；</li>
<li>计算速度和压力梯度；</li>
<li>求解离散动量方程（ discretized momentum equation），求得体心临时速度场；这一步是显式的</li>
<li>用体心临时速度场插值计算面心质量通量场；</li>
<li>计算压力修正方程（pressure correction equation），得到体心压力修正场；这一步是隐式的</li>
<li>对体心压力场进行亚松弛修正；</li>
<li>对压力场修正边界条件；</li>
<li>修正面心质量通量场；</li>
<li>修正体心速度场；</li>
<li>更新密度；</li>
</ol>
<p>但是明显OpenFOAM中的simpleFoam并没有求解过所谓的修正方程，而是自己玩了一个Picard迭代<sup><a href="#fn_9" id="reffn_9">9</a></sup>直接求的全量方程（你会发现OpenFOAM似乎从来就没求过修正量的Newton迭代，个人理解是因为OpenFOAM玩Newton迭代时边界条件不是很方便处理。）</p>
<p>于是我做了一点儿考古和分析。</p>
<h2 id="SIMPLE算法"><a href="#SIMPLE算法" class="headerlink" title="SIMPLE算法"></a>SIMPLE算法</h2><p>SIMPLE: Semi-Implicit Method of Pressure Linked Equations，这个方程的名字就满是问题，首先什么是半隐式方法（Semi-Implicit Method），什么又是压力联系方程（Pressure Linked Equations）？在原始文献<sup><a href="#fn_2" id="reffn_2">2</a></sup> 中是没有用SIMPLE这个名字的。搜索文献也很难找到压力联系方程的说法。我至今没有找到这个术语最开始的出处，查到最早的是他们自己1973年的文献<sup><a href="#fn_5" id="reffn_5">5</a></sup> 是叫SIMPLE了，但似乎大家都是以讹传讹地引用1972年的那篇文献。</p>
<p>根据一些参考文献<sup><a href="#fn_3" id="reffn_3">3</a></sup> 的分类法，SIMPLE, PISO都属于一类叫压力修正格式（Pressure Correction Schemes）的算法，其特征是构造一个压力场来满足不可压缩条件，再得到一个速度场，至于这个速度场能不能满足新得到的压力场，呵呵，要是能满足就不用再继续迭代了。由于求解的动量方程已经是线性化之后的了，所以你把这个速度对应的面心通量场再去线性化一次动量方程，如此往复才能最后得到稳态解。</p>
<h3 id="压力联系方程之到底是哪个方程"><a href="#压力联系方程之到底是哪个方程" class="headerlink" title="压力联系方程之到底是哪个方程"></a>压力联系方程之到底是哪个方程</h3><p>查来查去，发现不可压缩CFD解的主要是以下方程：</p>
<ul>
<li>压力修正方程（Pressure Correction Equation, PCE）<sup><a href="#fn_4" id="reffn_4">4</a></sup> : 两次迭代间压力需要的修正量的方程</li>
</ul>
<ol>
<li><script type="math/tex; mode=display">
\nabla^2 (p^{n+1}-p^n) =\frac 1 {\Delta t}\nabla\cdot U^*</script></li>
</ol>
<ul>
<li><p>压力泊松方程（Pressure Poisson Equation, PPE）<sup><a href="#fn_ 6" id="reffn_ 6"> 6</a></sup>: 动量方程求散度，消去速度散度项</p>
<p>稳定化的一阶欧拉时间离散时的形式。</p>
</li>
</ul>
<script type="math/tex; mode=display">
\nabla^2 p^{n+1} = \rho { {\nabla \cdot \mathbf{u}^n} \over {\Delta t} }-
\rho \nabla \cdot (\mathbf{u}^n \cdot \nabla \mathbf{u}^n)+
\mu \nabla^2 (\nabla \cdot \mathbf{u}^n)</script><p>​    速度场保持无散时的形式。</p>
<script type="math/tex; mode=display">
-\frac 1 \rho \nabla^2 p =  \nabla \cdot (\mathbf{u} \cdot \nabla \mathbf{u})</script><ul>
<li>压力联系方程（Pressure Linked Equation, PLE）：原始文献并没有说什么是PLE，参考另一篇文献<sup><a href="#fn_7" id="reffn_7">7</a></sup>的说法，压力联系方程的形式如下（符号定义参考文献）：</li>
</ul>
<script type="math/tex; mode=display">
\frac{\partial}{\partial x}\left( \gamma\frac{\partial p}{\partial x} \right) 
+\frac{\partial}{\partial y}\left( \gamma\frac{\partial p}{\partial y} \right) 
= \hat \epsilon
\\
\hat\epsilon = (\hat u_e- \hat u_w)/\Delta x +(\hat v_n - \hat v_s)/\Delta y</script><p>可见，所谓PLE非常诡异，它不是个微分方程，而是一个代数方程。对应到OpenFOAM里的simpleFoam则是<sup><a href="#fn_8" id="reffn_8">8</a></sup>：</p>
<script type="math/tex; mode=display">
\begin{equation}
\nabla \cdot (\mathbf{HbyA}^{n+1}) = \nabla \cdot(\frac{1}{A_{\mathrm{P},f} } \nabla p^{n+1})
\label{poss}
\end{equation}</script><p>同时，对比PLE和PPE，可以发现，二者都是把某种形式的动量方程带入了质量守恒方程得到的，但不同之处在于</p>
<ol>
<li>PLE是把<strong>线性化</strong>的<strong>离散</strong>动量方程中得到速度表达式带入了质量守恒方程，得到$\nabla\cdot(\frac 1 a \nabla p) = \dots $。<ol>
<li>大概是这么个过程：</li>
<li>线性化离散动量方程记为 $M\cdot u =  \nabla p $， $M$是一个矩阵。</li>
<li>先LDU加法分解： $M\cdot u = (D+L+U) \cdot u = \nabla p$</li>
<li>然后进行Jacobi迭代：$ D \cdot u = \nabla p - (L+U) \cdot u^0$</li>
<li>左边： $D$记为$A$ （实际上是对角系数除以单元体积，以保持量纲一致性）， 因为是对角阵，所以可以把$D^{-1}=A^{-1}$记为 $\frac 1 A$ ，OpenFOAM里实现为一个几何场而不是矩阵<code>fvMatrix</code>；</li>
<li>右边：$(L+U)\cdot u^0$记为 $H$ </li>
<li>这样$u = \frac 1 A \nabla p - \frac H A$ </li>
<li>然后再利用$\nabla \cdot u = 0 $</li>
<li>得到$\nabla\cdot(\frac 1 A \nabla p ) = \nabla \cdot \frac H A$ ，这就是PLE，也是实际OpenFOAM中求解的方程。</li>
<li>英语里$\frac H A$ 可以读作”H by A”</li>
<li>OpenFOAM里的$\frac 1 A$ 对应变量为<code>rUA</code> </li>
</ol>
</li>
<li>PPE是把动量方程直接求散度得到的，所以是$\nabla\cdot\nabla p=\dots$。</li>
</ol>
<h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ul>
<li>问：为啥要费劲心力去算$\mathbf{HbyA}$，再算PLE，直接离散PPE或者质量守恒方程不行么？</li>
<li><p>答：我也不知道</p>
<ul>
<li>但是玩FEM的家伙们就是这么干的（当然实际上他们也有很多流派，但是他们更多的是玩函数空间，LBB条件而不是玩方程系数，玩系数太low）</li>
<li>似乎只有玩FVM的人才玩PLE。</li>
<li><p>而且投影法<sup><a href="#fn_10" id="reffn_10">10</a></sup>那个流派的FVM也是玩的PPE，参考<a href="https://en.wikipedia.org/wiki/Projection_method_(fluid_dynamics" target="_blank" rel="noopener">Chorin’s_projection_method</a>#Chorin’s_projection_method)。</p>
</li>
<li><p>而且为了玩PLE，作为使用OpenFOAM的同位网格玩家，还必须引入Rhie-Chow插值这种大坑，虽然OpenFOAM似乎轻巧地避开了这个坑。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Semi-Implicit-Method半隐式方法"><a href="#Semi-Implicit-Method半隐式方法" class="headerlink" title="Semi-Implicit-Method半隐式方法"></a>Semi-Implicit-Method半隐式方法</h3><p>我认为之所以叫半隐式方法，是因为：</p>
<ul>
<li>求解过程中，求速度预测步的方程对于速度是隐式的，但对于压力是固定的显式离散，所以称之为半隐式。</li>
<li>求解压力方程时，压力是隐式离散的，但是此时的速度是固定不变的。</li>
<li>所以本质上这个半隐式等价于解耦算法。</li>
<li>文献<sup><a href="#fn_5" id="reffn_5">5</a></sup> 摘要中提到，SIMPLE的半隐式是和SIVA（SImultaneous Variable Adjustment）全隐算法相对的提法，其特点是每次迭代要同时更新周围的速度和压力。</li>
</ul>
<p>SIMPLE算法因此具有一些特性：</p>
<ul>
<li>解耦计算，内存占用小。</li>
</ul>
<ul>
<li>用于稳态计算，所以<code>timeStep</code>无意义，但通常设置<code>timeStep=1</code>，这样解算输出时间等于时间步数；</li>
<li>由于没有时间项来稳定化计算，需要加入松弛因子（在矩阵上加在和时间项几乎相同的位置），但是这个松弛因子在实现时搞不好会对最终稳态解产生影响。</li>
</ul>
<h3 id="关于consistent"><a href="#关于consistent" class="headerlink" title="关于consistent"></a>关于<code>consistent</code></h3><p>对于SIMPLE-C算法<sup><a href="#fn_16" id="reffn_16">16</a></sup>而言，比SIMPLE算法只多了一个步骤：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//applications/solvers/incompressible/pimpleFoam/pEqn.H +16</span></span><br><span class="line"><span class="keyword">if</span> (pimple.consistent())</span><br><span class="line">&#123;</span><br><span class="line">    rAtU = <span class="number">1.0</span>/max(<span class="number">1.0</span>/rAU - UEqn.H1(), <span class="number">0.1</span>/rAU); <span class="comment">//有max!</span></span><br><span class="line">    phiHbyA +=</span><br><span class="line">        fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf();</span><br><span class="line">    HbyA -= (rAU - rAtU())*fvc::grad(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/simpleFoam/pEqn.H +10</span></span><br><span class="line"><span class="keyword">if</span> (simple.consistent())</span><br><span class="line">&#123;</span><br><span class="line">  rAtU = <span class="number">1.0</span>/(<span class="number">1.0</span>/rAU - UEqn.H1()); <span class="comment">//没有max!</span></span><br><span class="line">  phiHbyA +=</span><br><span class="line">    fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf();</span><br><span class="line">  HbyA -= (rAU - rAtU())*fvc::grad(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，pimpleFoam和simpleFoam的<code>consistent</code>选项对<code>rAtU</code>的计算公式是有区别的！</p>
<p>其中修改了的变量有：</p>
<ul>
<li><p><code>rAtU</code></p>
<ul>
<li><code>1.0/rAU - UEqn.H1()</code>的实际含义应该是$[1/(\frac{1}{D})-(-(L+U)\cdot \mathbf{1})] = (L+D+U)\cdot \mathbf{1}$，也就是矩阵系数的行和，中间最多差一个网格体积的因子。</li>
<li><code>0.1/rAU</code>的含义应该是$\frac{1}{10} D$</li>
<li>由于系数矩阵元素的大小往往是对角项为负，非对角项为正，其行和为略小的负数（对于laplace方程，某些行和可能为0，但是对于动量方程，应该不为零）。所以为了避免除以0，<code>pimpleFoam</code>采用了<code>max</code>函数的技巧。</li>
<li>而对于<code>simpleFoam</code>，只取了第一项的倒数。</li>
</ul>
</li>
<li><p><code>phiHbyA</code></p>
<ul>
<li><p>按照<code>rAtU-rAU</code>的差值，和<code>grad(p)</code>对界面流量进行更新</p>
</li>
<li><p>把这项代入到pEqn的表达式中，可以发现和原来是一样的</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来的方程，如pisoFoam, icoFoam就采用了这个方程</span></span><br><span class="line">fvScalarMatrix pEqn</span><br><span class="line">(</span><br><span class="line">	fvm::laplacian(rAU, p) == fvc::div(phiHbyA)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//simpleFoam, pimpleFoam采用的方程，将phiHbyA改记为phiHbyA2</span></span><br><span class="line">fvScalarMatrix pEqn</span><br><span class="line">(</span><br><span class="line">	fvm::laplacian(rAtU(), p) == fvc::div(phiHbyA2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两者相减</span></span><br><span class="line">fvScalarMatrix pEqn</span><br><span class="line">(</span><br><span class="line">	fvm::laplacian(rAtU()-rAU, p) </span><br><span class="line">  == fvc::div(fvc::interpolate(rAtU() - rAU)*fvc::snGrad(p)*mesh.magSf())</span><br><span class="line">);</span><br><span class="line"><span class="comment">//可见二者是一致的。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>HbyA</code></p>
<ul>
<li>同上，按照<code>rAtU-rAU</code>的差值，对临时体心速度进行更新。</li>
<li>便于后面用<code>U = HbyA - rAtU()*fvc::grad(p);</code>去更新真正的体心速度！</li>
</ul>
</li>
<li><p>至此，正确性没有问题，但是为啥<code>rAtU</code>要这么改？！。 </p>
<ul>
<li><p>对于pimpleFoam中的<code>rAtU</code>，<code>max()</code>函数在分母，应该是取了较为稳定的一组系数，并避免了除以0。</p>
</li>
<li><p>对于simpleFoam而言，<code>rAU</code>是矩阵系数中的对角部分，而<code>rAtU</code>则是取了矩阵每一行系数的和。</p>
<ul>
<li><p>参考原始文献<sup><a href="#fn_16" id="reffn_16">16</a></sup> ，作者就是这么干的！</p>
</li>
<li><p>本质上你可以任意的分解：</p>
</li>
<li><script type="math/tex; mode=display">
M=L+D+U \\

M\cdot u = (L+D+U)\cdot u = (D_s+(M-D_s) )\cdot u = - \nabla p  \\</script></li>
<li><p>所以对于<code>consistent=false</code>的情形：</p>
</li>
<li><script type="math/tex; mode=display">
A=\frac 1 D \\
H=-(L+U)\cdot u^0</script></li>
<li><p>对于consistent=true的情形：</p>
</li>
<li><script type="math/tex; mode=display">
H_1 =- (L+U)\cdot \mathbf{1} \\
A'=D-H_1 = M\cdot \mathbf{1}</script></li>
<li><p>根据wiki上的说明，如果压力-速度耦合是解收敛的主要问题，SIMPLE-C算法可以加速收敛，SIMPLE-C比SIMPLE要快大概是120%-130%左右。</p>
</li>
<li><p>如果压力-速度耦合不是收敛的主要障碍，SIMPLE-C效率与SIMPLE差不多。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="关于H1和H的区别"><a href="#关于H1和H的区别" class="headerlink" title="关于H1和H的区别"></a>关于H1和H的区别</h4><ul>
<li>意义不一样：假设$M=(L+D+U)$，初值为$x^0$<ul>
<li>则$H_1 = H(x^0=\mathbf1)$</li>
<li>$H(x^0)=-(L+D)\cdot x^0$</li>
<li>$\mathbf 1$表示全是1的向量。</li>
</ul>
</li>
<li>都是定义在lduMatrix中的，但是<code>H1</code>是不带参数的，而<code>H</code>是带参数的。</li>
<li>实现的地方也不一样，一个在<code>lduMatrixATmul.C</code>，另一个在<code>lduMatrixTemplates.C</code>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//H1()</span></span><br><span class="line"><span class="comment">//src/OpenFOAM/matrices/lduMatrix/lduMatrix/lduMatrixATmul.C +298</span></span><br><span class="line">Foam::tmp&lt;Foam::scalarField &gt; Foam::lduMatrix::H1() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;scalarField &gt; tH1</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> scalarField(lduAddr().size(), <span class="number">0.0</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lowerPtr_ || upperPtr_)</span><br><span class="line">    &#123;</span><br><span class="line">        scalarField&amp; H1_ = tH1.ref();</span><br><span class="line"></span><br><span class="line">        scalar* __restrict__ H1Ptr = H1_.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ uPtr = lduAddr().upperAddr().begin();</span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ lPtr = lduAddr().lowerAddr().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ lowerPtr = lower().begin();</span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ upperPtr = upper().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label nFaces = upper().size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (label face=<span class="number">0</span>; face&lt;nFaces; face++)</span><br><span class="line">        &#123;</span><br><span class="line">            H1Ptr[uPtr[face]] -= lowerPtr[face];</span><br><span class="line">            H1Ptr[lPtr[face]] -= upperPtr[face];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tH1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//H(psi)</span></span><br><span class="line"><span class="comment">//src/OpenFOAM/matrices/lduMatrix/lduMatrix/lduMatrixTemplates.C +34</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:tmp&lt;Foam::Field&lt;Type&gt;&gt; Foam::lduMatrix::H(<span class="keyword">const</span> Field&lt;Type&gt;&amp; psi) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;Field&lt;Type&gt;&gt; tHpsi</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> Field&lt;Type&gt;(lduAddr().size(), Zero)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lowerPtr_ || upperPtr_)</span><br><span class="line">    &#123;</span><br><span class="line">        Field&lt;Type&gt; &amp; Hpsi = tHpsi.ref();</span><br><span class="line"></span><br><span class="line">        Type* __restrict__ HpsiPtr = Hpsi.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Type* __restrict__ psiPtr = psi.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ uPtr = lduAddr().upperAddr().begin();</span><br><span class="line">        <span class="keyword">const</span> label* __restrict__ lPtr = lduAddr().lowerAddr().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ lowerPtr = lower().begin();</span><br><span class="line">        <span class="keyword">const</span> scalar* __restrict__ upperPtr = upper().begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> label nFaces = upper().size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (label face=<span class="number">0</span>; face&lt;nFaces; face++)</span><br><span class="line">        &#123;</span><br><span class="line">            HpsiPtr[uPtr[face]] -= lowerPtr[face]*psiPtr[lPtr[face]];</span><br><span class="line">            HpsiPtr[lPtr[face]] -= upperPtr[face]*psiPtr[uPtr[face]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tHpsi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:tmp&lt;Foam::Field&lt;Type&gt;&gt;</span><br><span class="line">Foam::lduMatrix::H(<span class="keyword">const</span> tmp&lt;Field&lt;Type&gt;&gt;&amp; tpsi) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;Field&lt;Type&gt;&gt; tHpsi(H(tpsi()));</span><br><span class="line">    tpsi.clear();</span><br><span class="line">    <span class="keyword">return</span> tHpsi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>wiki和cfd-online上的SIMPLE算法是和simpleFoam不一致的。正确的描述可以参考openfoamwiki上的描述：<a href="http://openfoamwiki.net/index.php/OpenFOAM_guide/The_SIMPLE_algorithm_in_OpenFOAM#The_SIMPLE_algorithm" target="_blank" rel="noopener">the SIMPLE Algorithm</a></p>
<p>simple算法在OpenFOAM中的实现也是和版本相关的，比如foam-extend 4.0的simpleFoam里Jasak就采用了一种新的算法来避免时间步和松弛因子对解的影响。OpenFOAM.org和OpenFOAM.com的似乎还没变化。</p>
<p>此外，SIMPLE算法还有一些衍生算法：</p>
<ul>
<li>SIMPLEC: SIMPLE-Consistent</li>
<li>SIMPLER: SIMPLE-Revised</li>
</ul>
<h2 id="Rhie-Chow插值"><a href="#Rhie-Chow插值" class="headerlink" title="Rhie-Chow插值"></a>Rhie-Chow插值</h2><p>Rhie-Chow插值，有人又叫压力加权插值方法(pressure-weighted interpolation method, PWIM)，但是其实这个插值并不是用压力来加权的。</p>
<p>刚开始我以为这个插值的作用是来插值计算面心压力的，后来发现其实它是用来计算面心速度的插值方法。</p>
<p>本质上它等效于引入了4阶耗散项进入压力修正方程中，有利于计算的稳定化：</p>
<p>按照Rhie-Chow插值，均匀一维网格的面心速度表达式会含有P的三次导数成分。</p>
<script type="math/tex; mode=display">
U_e = \frac 1 2 (U_E+U_P)+\frac{\delta V}{4a_P\Delta x}[P_{EE}-3P_E+3P_P-P_W]</script><p>带入连续性方程之后，就会含有四次导数成分，成为稳定化压力方程的高阶耗散项，从而可以平抑压力波动：</p>
<script type="math/tex; mode=display">
\int_e^w{\frac {dU }{dx} dx} =U_e - U_w =  \frac 1 2 (U_E - U_W)+\frac{\delta V}{4a_P\Delta x}[P_EE-4P_E+6P_{P}-4P_W+P_{WW}]</script><p>详细的说明可以看参考文献<sup><a href="#fn_13" id="reffn_13">13</a></sup></p>
<p>而且玩高阶导数的人都应该知道，压力梯度都特别大的时候，高阶项会更大，所以有时候Rhie-Chow插值也会出问题。</p>
<h3 id="面心速度的作用"><a href="#面心速度的作用" class="headerlink" title="面心速度的作用"></a>面心速度的作用</h3><p>（注：面心速度（$\mathbf{u}_f$）和界面通量（程序里常用<code>phi</code>表示 ）仅相差一个面积，所以实际上差不多是同一回事儿。）</p>
<p>根据文献<sup><a href="#fn_11" id="reffn_11">11</a></sup> ，面心速度有三个作用：</p>
<ol>
<li>格式系数作用：构成关于体心速度的矩阵方程<code>UEqn</code>时，界面通量是系数的重要组成部分，系数不同，方程就不同，解就不同；</li>
<li>耦合作用：耦合速度和压力，在simple算法构造关于体心压力的矩阵方程时，需要用到界面通量；</li>
<li>质量守恒作用：界面通量应满足质量守恒。</li>
</ol>
<p>按照我的理解，在OpenFOAM中，这些作用在程序中分别由不同的变量承担了，并不是同一个面心速度了。</p>
<ol>
<li>格式系数作用：由于采用的是Picard迭代，所以OpenFOAM组成速度方程<code>UEqn</code>的矩阵系数是采用直接按<code>fvScheme</code>指定格式插值得到的界面通量<code>phi</code>在<code>fvm::div(phi,U)</code>生成的（准确地说在simpleFoam中第一次迭代用的插值phi，后面用的<code>pEqn.flux()</code>和<code>phiHbyA</code>构造的<code>phi</code>）。在<code>simpleFoam</code>中如以下代码所示。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UEqn.H</span></span><br><span class="line">tmp&lt;fvVectorMatrix&gt; tUEqn</span><br><span class="line">    (</span><br><span class="line">        fvm::div(phi, U) <span class="comment">//这里用的界面通量是phi</span></span><br><span class="line">      + MRF.DDt(U)</span><br><span class="line">      + turbulence-&gt;divDevReff(U)</span><br><span class="line">     ==</span><br><span class="line">        fvOptions(U)</span><br><span class="line">    );</span><br><span class="line">    fvVectorMatrix&amp; UEqn = tUEqn.ref();</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/cfdTools/incompressible/createPhi.H</span></span><br><span class="line">surfaceScalarField phi</span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"phi"</span>,</span><br><span class="line">        runTime.timeName(),</span><br><span class="line">        mesh,</span><br><span class="line">        IOobject::READ_IF_PRESENT,</span><br><span class="line">        IOobject::AUTO_WRITE</span><br><span class="line">    ),</span><br><span class="line">    fvc::flux(U) <span class="comment">//调用的是fvc::flux()</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/fvc/fvcFlux.C</span></span><br><span class="line"> Foam::tmp&lt;Foam::surfaceScalarField&gt; Foam::fvc::flux</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> volVectorField&amp; vvf</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> scheme&lt;<span class="built_in">vector</span>&gt; <span class="comment">// scheme&lt;vector&gt;(mesh,name) 返回 tmp&lt;surfaceInterpolationScheme&gt;对象</span></span><br><span class="line">    (</span><br><span class="line">        vvf.mesh(),</span><br><span class="line">        <span class="string">"flux("</span> + vvf.name() + <span class="string">')'</span></span><br><span class="line">    )().dotInterpolate(vvf.mesh().Sf(), vvf); <span class="comment">//插值并点乘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pEqn.H</span></span><br><span class="line">    <span class="keyword">while</span> (simple.correctNonOrthogonal()) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (simple.finalNonOrthogonalIter())</span><br><span class="line">        &#123;</span><br><span class="line">            phi = phiHbyA - pEqn.flux(); <span class="comment">//更新phi</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>而耦合作用反映在<code>phiHbyA</code>这个界面通量中，它最终构成了<code>pEqn</code>中的源项部分，在OpenFOAM的simpleFoam求解器中，<code>phiHbyA</code>是用<code>fvc::flux(HbyA)</code> 构造的。<ol>
<li>但是值得注意的是，simpleFoam只构造出了不含压力梯度贡献的临时速度$u^*$ = <code>HbyA</code>，并且没有直接使用它，而是用它构造了<code>phiHbyA</code>。</li>
<li>simpleFoam没有在<code>pEqn</code>求解之前构造含有压力梯度贡献的<code>U</code>，这是在求解完压力方程后，用<code>U = HbyA - rAtU()*fvc::grad(p)</code> 构造的。</li>
<li>所以dyfluid上说<code>在OpenFOAM中，并没有直接采用Rhie-Chow插值的原始步骤。相反的，其通过对拉普拉斯项的离散巧妙的获得一种近似Rhie-Chow插值的原理。</code></li>
<li>因为原始步骤是通过$\nabla\cdot U=0$构造<code>pEqn</code>，而实际上因为<code>pEqn</code>是通过<code>phiHbyA</code> 和<code>rUA</code>构造的，所以跳过了原始的Rhie-Chow插值。</li>
<li>而因为<code>fvm::laplacian(rUA,p)</code>的实现已经是利用了周围相邻单元的压力，并没有原始构造方式中压力的奇偶失耦（odd-even decoupling）情况，所以认为是实现了Rhie-Chow插值的效果。</li>
<li>按照参考文献<sup><a href="#fn_18" id="reffn_18">18</a></sup> 的搞法（Listing 15.18），Rhie-Chow插值似乎是用于产生<code>phiHbyA</code>的，但是由于那本书严格地遵守了解PCE的思路，所以还不能完全相互比较。</li>
</ol>
</li>
<li>质量守恒作用其实是靠<code>pEqn</code>实现的PLE完成的，simpleFoam除了在<code>continuityErrs.H</code>之外不直接检查质量守恒，检查时也是用的<code>fvc::div(phi)</code>而不是速度<code>U</code>。 </li>
</ol>
<h2 id="PISO算法"><a href="#PISO算法" class="headerlink" title="PISO算法"></a>PISO算法</h2><p>PISO = Pressure Implicit Split Operator。同样的问题，什么是压力隐式(pressure implicit)，什么是算子分裂(split operator)。就icoFoam来看，我的理解是：</p>
<ul>
<li><p>压力隐式(pressure implicit)：求解的压力方程是隐式的（废话）；</p>
</li>
<li><p>算子分裂(split operator)：把$\frac {dx}{dt}|_t^{t+\Delta t}=O(x) = (O_1+O_2)(x)  $ 近似成$ \frac{dx}{dt}|_t^{t+\Delta t} = O_1(x’), \frac{dx’}{dt}|_t^{t+\Delta t}=O_2(x)$来求解</p>
<ul>
<li><p>原始文献<sup><a href="#fn_15" id="reffn_15">15</a></sup>中其实也就是解耦速度和压力的意思：</p>
</li>
<li><blockquote>
<p>The principle is here extended to apply to the coupling between variables, namely, the pressure and velocity, whereby operations involving different variables are split into a series of predictor-corrector steps.</p>
</blockquote>
</li>
<li><p>算子分裂的一个问题在于，它有时候<strong>不能保证到达稳态解的正确性</strong>！详见参考文献<sup><a href="#fn_14" id="reffn_14">14</a></sup> 。</p>
</li>
</ul>
</li>
</ul>
<p>算法的具体描述请参考<a href="http://openfoamwiki.net/index.php/OpenFOAM_guide/The_PISO_algorithm_in_OpenFOAM" target="_blank" rel="noopener">OpenFOAMwiki的PISO Algorithm</a> （这里的描述所用的版本有点老，和最新版OpenFOAM中使用的变量名有所不同）：</p>
<ol>
<li>Set the boundary conditions 施加边界条件.</li>
<li>Solve the discretized momentum equation to compute an intermediate velocity field. 解离散动量方程得到中间阶段的速度场$U^*$<ol>
<li>但是其实这一步可以设置<code>momentumPredictor=false</code>来跳过去。</li>
<li>因为最重要的其实是压力方程，这个速度场方程UEqn主要用来提取$A$和$H$，以构造后面压力方程要用的<code>phi</code></li>
<li>因为有非定常项，所以这里是没有松弛的！有松弛就不对了。</li>
</ol>
</li>
<li>Compute the mass fluxes at the cells faces，构造<code>phiHbyA</code>.<ol>
<li>与simple不同，这里的<code>phiHbyA</code>加入了<code>fvc::ddtCorr</code>项</li>
<li><code>fvc::ddtCorr</code>项的定义参考<a href="https://zh.scribd.com/doc/48195039/ddtPhiCorr" target="_blank" rel="noopener">这里</a>。</li>
</ol>
</li>
<li>Solve the pressure equation.解压力方程，其实应该是解的PLE</li>
<li>Correct the mass fluxes at the cell faces.更新<code>phi</code></li>
<li>Correct the velocities on the basis of the new pressure field. 更新<code>U</code></li>
<li>Update the boundary conditions.更新<code>U</code>的边界条件</li>
<li>Repeat from 3 for the prescribed number of times. 重复piso循环，<ol>
<li>这个是由<code>piso.correct()</code>控制的，而<code>piso.correct()</code>是由变量<code>label corrPISO_</code>控制的。</li>
<li>重复的时候，UEqn所引用的<code>U</code>是有更新的。所以用UEqn构造的<code>UEqn.A(), UEqn.H()</code>也可能会有所更新。</li>
</ol>
</li>
<li>Increase the time step and repeat from 1. 下一个时间步，这里是由<code>runTime.loop()</code>控制的。</li>
</ol>
<p>OpenFOAM中的PISO求解器其实有两个，最简单的是icoFoam，用的是PISO算法解层流。复杂一点的是pisoFoam，带有湍流模型。</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h4 id="solutionControl及其子类的继承关系"><a href="#solutionControl及其子类的继承关系" class="headerlink" title="solutionControl及其子类的继承关系"></a>solutionControl及其子类的继承关系</h4><ul>
<li>pisoControl是pimpleControl的子类！</li>
<li>pimpleContrl是solutionControl的子类</li>
<li>simpleControl是solutionControl的子类。</li>
</ul>
<h4 id="松弛"><a href="#松弛" class="headerlink" title="松弛"></a>松弛</h4><p>从代码中可以发现，pisoFoam和icoFoam对于压力和动量方程是没有进行松弛的。这是因为它要进行的是<strong>时间精确</strong>的模拟。</p>
<p>但是如果你用的ddt格式本来就不是时间精确的话，额，还是不要用PISO了，改用PIMPLE吧。加点松弛因子可能还稳定些。</p>
<h2 id="PIMPLE算法"><a href="#PIMPLE算法" class="headerlink" title="PIMPLE算法"></a>PIMPLE算法</h2><p>PIMPLE算法是SIMPLE和PISO的结合。因为PISO只有一个预测步，所以PISO的稳定性限制了它只能用于瞬态计算并且时间步不能取得太大，而SIMPLE没有时间项只能用于稳态计算（或者采用伪时间步方法用于瞬态计算）。PIMPLE算法的核心是把UEqn<strong>重新生成</strong>并解了很多次！</p>
<ul>
<li>pimpleFoam中的<code>#include &quot;UEqn.H&quot;</code> 语句是被包在<code>pimple.loop()</code>循环内的。</li>
<li>pisoFoam中的<code>#include &quot;UEqn.H&quot;</code>语句没有被包裹，每次<code>runTime.loop()</code>只运行一次。</li>
<li>pisoFoam中没有使用<code>consistent</code>关键字，所以没有SIMPLE-C修正。</li>
<li>pimpleFoam中使用了<code>consistent</code>关键字，所以和simpleFoam一样，对phiHbyA进行了SIMPLE-C处理。</li>
<li>simpleFoam中使用的<code>simple.loop()</code>而不是<code>runTime.loop()</code>，但是它调用了<code>runTime.loop()</code></li>
</ul>
<h3 id="PIMPLE里的三层循环"><a href="#PIMPLE里的三层循环" class="headerlink" title="PIMPLE里的三层循环"></a>PIMPLE里的三层循环</h3><p>总结起来，PIMPLE算法每个时间步（由<code>runTime.loop()</code>控制）有三层循环：</p>
<ul>
<li>外层<code>pimple.loop()</code>类似SIMPLE循环<ul>
<li>利用当前的<code>U</code>，生成并求解<code>UEqn</code></li>
<li>中层<code>pimple.correct()</code>，几乎就是PISO循环，负责压力求解<ul>
<li>利用<code>UEqn</code> 构造<code>rAU</code>, <code>HbyA</code></li>
<li><code>HbyA</code> 生成<code>phiHbyA</code>，加入<code>fvc::ddtCorr(U,phi)</code>修正。</li>
<li><code>adjustPhi()</code></li>
<li>利用<code>consistent</code>关键字对<code>phiHbyA</code>进行SIMPLE-C一致性修正</li>
<li><code>constrainPressure()</code></li>
<li>内层<code>pimple.correctNonOrthogonal()</code>非正交修正循环<ul>
<li>构造压力联系方程<code>pEqn</code></li>
<li><code>pEqn.setReference()</code></li>
<li>用新的<code>p</code>作为初始值求解<code>pEqn</code>，进行非正交修正。</li>
</ul>
</li>
<li>更新<code>U</code>和<code>phi</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>而SIMPLE算法没有中层循环，PISO算法没有外层循环。所以PIMPLE算法可以简化为PISO算法，但是由于SIMPLE算法中没有包含非定常项，所以PIMPLE算法要等同于SIMPLE算法需要使<code>ddt</code>项的格式需要指定为<code>steadyState</code>。</p>
<h2 id="一些编程细节"><a href="#一些编程细节" class="headerlink" title="一些编程细节"></a>一些编程细节</h2><p>此外在程序代码中还有好多稀奇古怪的乱七八糟玩意儿。</p>
<h3 id="solutionControl及其子类的变量命名规范"><a href="#solutionControl及其子类的变量命名规范" class="headerlink" title="solutionControl及其子类的变量命名规范"></a><code>solutionControl</code>及其子类的变量命名规范</h3><p>OpenFOAM里的求解控制类是<code>solutionControl</code> 及其子类<code>simpleControl</code>, <code>pisoControl</code>和<code>pimpleControl</code>。其中定义了很多变量，其命名规范是：</p>
<ul>
<li><code>label xxx_</code>表示迭代变量，比如<code>corr_,</code> <code>corrNonOrtho_</code>,pimpleControl中的 <code>corrPISO_</code>等。</li>
<li><code>label nXxx_</code>表示<strong>迭代上限次数</strong>，比如<code>nCorrNonOrtho_</code>（实际迭代次数是<code>nCorrNonOrtho_+1</code>，因为第一次求解不算所谓修正），pimpleControl中的<code>nCorrPIMPLE_</code>, <code>nCorrPISO_</code></li>
<li><code>bool yyy_</code>表示标志量，比如<code>transonic_</code>, <code>consistent_</code>, <code>momentumPredictor_</code></li>
<li><code>residualControl_</code> 残差控制。</li>
</ul>
<ul>
<li>以pimpleControl为例，其迭代循环变量和控制变量标志如下表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>含义</th>
<th>迭代量的变量名</th>
<th>迭代上限的变量名</th>
<th>配置文件中的关键字</th>
<th>默认值</th>
<th>判断是否执行的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>外部迭代，又叫PIMPLE迭代</td>
<td><code>label corr_</code></td>
<td><code>nCorrPIMPLE_</code></td>
<td><code>nOuterCorrectors</code></td>
<td>1</td>
<td><code>loop()</code></td>
</tr>
<tr>
<td>PISO压力修正循环</td>
<td><code>label corrPISO_</code></td>
<td><code>nCorrPISO_</code></td>
<td><code>nCorrectors</code></td>
<td>1</td>
<td><code>correct()</code></td>
</tr>
<tr>
<td>非正交修正</td>
<td><code>label corrNonOrtho_</code></td>
<td><code>nCorrNonOrtho_</code> <strong>这是实际迭代次数上限减1</strong></td>
<td><code>nNonOrthogonalCorrectors</code></td>
<td>0</td>
<td><code>correctNonOrthogonal()</code></td>
</tr>
<tr>
<td>是否执行动量预测步</td>
<td><code>bool momentumPredictor_</code></td>
<td></td>
<td><code>momentumPredictor</code></td>
<td>true</td>
<td><code>momentumPredictor()</code></td>
</tr>
<tr>
<td>一致性</td>
<td><code>bool consistent_</code></td>
<td></td>
<td><code>consistent</code></td>
<td>false</td>
<td><code>consistent()</code></td>
</tr>
<tr>
<td>跨声速</td>
<td><code>bool transonic</code></td>
<td></td>
<td><code>transonic</code></td>
<td>false</td>
<td><code>transonic()</code></td>
</tr>
<tr>
<td>是否在PISO循环外更新密度</td>
<td><code>bool SIMPLErho_</code></td>
<td></td>
<td><code>SIMPLErho</code></td>
<td>false</td>
<td><code>SIMPLErho()</code></td>
</tr>
<tr>
<td>仅在最后迭代启用湍流</td>
<td><code>bool turbOnFinalIterOnly_</code></td>
<td></td>
<td><code>turbOnFinalIterOnly</code></td>
<td>true</td>
<td><code>momentumPredictor()</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="simpleFoam中phi变量的更新。"><a href="#simpleFoam中phi变量的更新。" class="headerlink" title="simpleFoam中phi变量的更新。"></a>simpleFoam中<code>phi</code>变量的更新。</h3><p>如果仔细的人应该会发现，<code>phi</code>这个变量在simpleFoam中是由<code>createFields.H</code>调用<code>createPhi.H</code>创建的，然后在<code>UEqn.H</code>中被<code>fvm::div(phi,U)</code>使用，那么在下一次迭代之前它是如何更新的呢？</p>
<p>我们发现它是在<code>pEqn.H</code>中更新的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pEqn.H</span></span><br><span class="line">	<span class="keyword">if</span> (simple.finalNonOrthogonalIter())</span><br><span class="line">        &#123;</span><br><span class="line">            phi = phiHbyA - pEqn.flux();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于adjustPhi-和-setReference"><a href="#关于adjustPhi-和-setReference" class="headerlink" title="关于adjustPhi, 和 setReference"></a>关于adjustPhi, 和 setReference</h3><p>adjustPhi和pRef针对的是压力方程为全Neuman边界的情况<sup><a href="#fn_12" id="reffn_12">12</a></sup>，这时解的存在唯一性可能会有两个问题:</p>
<ul>
<li>唯一性：方程系数矩阵M 列秩不满时，解有无穷多（例如$x_1+x_2=1,2x_1+2x_2=2$），互之间相差一组常数（或者一组常函数，或零空间元素），所以需要setReference</li>
<li>存在性：方程的增广矩阵秩和M的秩不一样时（例如$x_1+x_2=1,-x_1-x_2=-2$），存在相容性问题，需要<code>adjustPhi</code></li>
</ul>
<p>关于线性代数知识可以参考<sup><a href="#fn_23" id="reffn_23">23</a></sup></p>
<blockquote id="fn_23">
<sup>23</sup>. <a href="http://math.fudan.edu.cn/gdsx/JIAOAN/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84.pdf" target="_blank" rel="noopener">教案： 线性方程组</a><a href="#reffn_23" title="Jump back to footnote [23] in the text."> &#8617;</a>
</blockquote>
<h4 id="方程多解问题：setReference"><a href="#方程多解问题：setReference" class="headerlink" title="方程多解问题：setReference"></a>方程多解问题：setReference</h4><p>当方程为：</p>
<script type="math/tex; mode=display">
\Delta p = f \text{ on }\Omega \\


\nabla p \cdot \mathbf n = g \text{ on }\partial \Omega</script><p>首先，如果$p_1$是一个解，那么$p_2=p_1+const$也是方程的解，方程解不唯一，所以离散方程会有奇异性，无法求解。<br>解决方法是固定一个点的压力为给定值，就是设置<code>setReference</code>。</p>
<h4 id="方程相容性问题：adjustPhi"><a href="#方程相容性问题：adjustPhi" class="headerlink" title="方程相容性问题：adjustPhi"></a>方程相容性问题：adjustPhi</h4><p>p变量前面是直接加了微分的，所以需要对于全Neumann条件的情形还需要满足<strong>相容性条件</strong>：</p>
<script type="math/tex; mode=display">
\int_{\Omega}{f dV} =\int_{\Omega}{\Delta p dV} = \int_{ \partial\Omega}{\nabla p \cdot\mathbf n dS}

= \int_{ \partial\Omega}{g dS}</script><p>这就是adjustPhi去强制满足这个条件。<br>带入f和g的表达式</p>
<script type="math/tex; mode=display">
f= \nabla\cdot\mathbf u^*\\

g=0</script><p>可得：</p>
<script type="math/tex; mode=display">
\int_{\Omega}{\nabla \cdot \mathbf u^* dV} =\int_{\partial \Omega}{\mathbf u^*dS}= 0</script><p>你再看看adjustPhi出现的位置，是在pEqn.H中，对phiHbyA进行的调整。其实也就是这里的$\mathbf u^*$项。必须使其满足以上相容性条件。</p>
<h3 id="关于constrainPressure和constrainHbyA"><a href="#关于constrainPressure和constrainHbyA" class="headerlink" title="关于constrainPressure和constrainHbyA"></a>关于<code>constrainPressure</code>和<code>constrainHbyA</code></h3><p>从OpenFOAM的4.0版本开始，引入了<code>fixedFluxPressure,fixedFluxExtraoplatedPressure</code>边界条件，从而使入口的压力可以浮动，且边界压力梯度还可以根据计算情况进行调整，于是引入了<code>constrainPressure()</code>和<code>constrainHbyA()</code>函数。 </p>
<p>其说明可以参考<a href="http://caefn.com/" target="_blank" rel="noopener">Fumiya Nozaki’s CFD Blog</a>的这篇blog：<a href="http://caefn.com/openfoam/solvers-recent-changes" target="_blank" rel="noopener">Recent changes in the basics of the OpenFOAM solvers</a>和 <a href="http://caefn.com/openfoam/ja-bc-fixedfluxpressure" target="_blank" rel="noopener">fixedFluxPressure 境界条件</a>。 </p>
<h4 id="constrainPressure用于调整压力p的边界"><a href="#constrainPressure用于调整压力p的边界" class="headerlink" title="constrainPressure用于调整压力p的边界"></a><code>constrainPressure</code>用于调整压力p的边界</h4><p>可压缩流中边界速度$U_f$在离散生成<code>UEqn</code>之后可以表示为：</p>
<script type="math/tex; mode=display">
\begin{equation} 
\rho \boldsymbol{U}_f \cdot \boldsymbol{S}_f = \left(\frac{\rho \boldsymbol{H} }{A_p}\right)_f \cdot \boldsymbol{S}_f\;-\;\left(\frac{\rho}{A_p}\right)_f (\nabla p)_f \cdot \boldsymbol{S}_f. \tag{1} \label{eq:1} 
\end{equation}</script><p>所以界面法向压力梯度可以表示为：</p>
<script type="math/tex; mode=display">
\begin{equation} 
(\nabla p)_f \cdot \boldsymbol{n}_f = \frac{1}{|\boldsymbol{S}_f|\left(\frac{\rho}{A_p}\right)_f} \left(\left(\frac{\rho \boldsymbol{H} }{A_p}\right)_f \cdot \boldsymbol{S}_f\;-\;\rho \boldsymbol{U}_f \cdot \boldsymbol{S}_f \right). \tag{2} \label{eq:2} 
\end{equation}</script><p>将上述关系运用于压力边界条件，就是<code>constrainPressure</code>要干的事儿。</p>
<ul>
<li><code>void constrainPressure(p,rho=1,U,phiHbyA,rhorAU,MRF=NULLMRF)</code><ul>
<li>输出调整的其实是p</li>
<li>必要的输入有<code>U,phiHbyA,rhorAU</code></li>
</ul>
</li>
</ul>
<ul>
<li>p边界条件继承于<code>fixedFluxPressureFvPatchScalarField</code>的才会调整。</li>
</ul>
<h4 id="constrainHbyA-tHbyA-U-p-用于返回调整后的tHbyANew变量"><a href="#constrainHbyA-tHbyA-U-p-用于返回调整后的tHbyANew变量" class="headerlink" title="constrainHbyA(tHbyA,U,p)用于返回调整后的tHbyANew变量"></a><code>constrainHbyA(tHbyA,U,p)</code>用于返回调整后的<code>tHbyANew</code>变量</h4><ul>
<li>循环每个边界</li>
<li>当<code>U</code>的在这个边界的边界条件是<code>assignable()==false</code></li>
<li>且<code>p</code>的在这个边界是继承自<code>fixedFluxExtrapolatedPressureFvPatchScalarField</code></li>
<li><code>tHbyANew</code>的这个 这边界设置为和<code>U</code>的这个边界相同的值。</li>
<li>返回<code>tHbyANew</code></li>
<li>为什么要这么做：我也不知道。可能这样做了之后<code>constrainPressure()</code>得到的压力和<code>HbyA</code>在固定速度的边界与前述PLE方程就是一致的了，毕竟前面的<code>constrainPressure()</code>是利用了<code>HbyA</code>生成的<code>phiHbyA</code>的。</li>
<li>如果没有用到<code>fixedFluxExtrapolatedPressure</code>和 <code>fixedFluxPressure</code>边界条件，这两个函数其实相当于没有作用。</li>
</ul>
<h3 id="关于fvc-ddtCorr-和fvc-ddtPhiCorr"><a href="#关于fvc-ddtCorr-和fvc-ddtPhiCorr" class="headerlink" title="关于fvc::ddtCorr()和fvc::ddtPhiCorr()"></a>关于fvc::ddtCorr()和fvc::ddtPhiCorr()</h3><p>对于非稳态的求解器，如pimpleFoam, pisoFoam和icoFoam中，<code>phiHbyA</code>在构造时除了用到<code>HbyA</code> 向的插值，还会用到<code>fvc::ddtCorr()</code>，这一项主要是为了修正非定常和松弛因子对解的影响。而且这一项还是和OpenFOAM版本历史相关的！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OpenFOAM 5.x, 4.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +77</span></span><br><span class="line">            surfaceScalarField phiHbyA</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"phiHbyA"</span>,</span><br><span class="line">                fvc::flux(HbyA) <span class="comment">//这里用了fvc::flux函数，而不是原来的interpolate 和 &amp; 算符</span></span><br><span class="line">              + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi) <span class="comment">//用的是ddtCorr!</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"><span class="comment">//OpenFOAM 2.3.x, 2.4.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C  +73</span></span><br><span class="line">            surfaceScalarField phiHbyA</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"phiHbyA"</span>,</span><br><span class="line">                (fvc::interpolate(HbyA) &amp; mesh.Sf())</span><br><span class="line">              + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi) <span class="comment">//用的是ddtCorr</span></span><br><span class="line">            );</span><br><span class="line"><span class="comment">//OpenFOAM 2.2.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +73</span></span><br><span class="line">            surfaceScalarField phiHbyA<span class="comment">//用了新的变量名!</span></span><br><span class="line">            (</span><br><span class="line">                <span class="string">"phiHbyA"</span>,</span><br><span class="line">                (fvc::interpolate(HbyA) &amp; mesh.Sf()) </span><br><span class="line">              + fvc::ddtPhiCorr(rAU, U, phi) <span class="comment">//用的是ddtPhiCorr!</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//OpenFOAM 2.1.x</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +72</span></span><br><span class="line">            phi = (fvc::interpolate(U) &amp; mesh.Sf())</span><br><span class="line">                + fvc::ddtPhiCorr(rAU, U, phi);</span><br><span class="line"></span><br><span class="line"><span class="comment">//foam-extend 4.0</span></span><br><span class="line"><span class="comment">//applications/solvers/incompressible/icoFoam/icoFoam.C +86</span></span><br><span class="line">            U = HUEqn.H()/aU; <span class="comment">//注意这里的HUEqn不包含非定常项</span></span><br><span class="line">            phi = (fvc::interpolate(U) &amp; mesh.Sf()); <span class="comment">//所以这里也不包含。</span></span><br></pre></td></tr></table></figure>
<p>太老的就不管了，因为根据OpenFOAM.org官网的<a href="https://openfoam.org/release/2-3-0/numerics/" target="_blank" rel="noopener">更新说明</a>，2.3.0版本时已经把<code>ddtPhiCorr</code>换成了<code>ddtCorr</code>。</p>
<p>首先找OpenFOAM 5.x的代码，看看<code>ddtCorr()</code>到底是干啥的 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/fvc/fvcDdt.C +183</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;GeometricField&lt;typename flux&lt;Type&gt;::type, fvsPatchField, surfaceMesh&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">ddtCorr</span></span></span><br><span class="line"><span class="class">(</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">GeometricField</span>&lt;Type, fvPatchField, volMesh&gt;&amp; <span class="title">U</span>,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">GeometricField</span></span></span><br><span class="line"><span class="class">    &lt;</span></span><br><span class="line"><span class="class">        typename flux&lt;Type&gt;::type,</span></span><br><span class="line"><span class="class">        fvsPatchField,</span></span><br><span class="line"><span class="class">        surfaceMesh</span></span><br><span class="line"><span class="class">    &gt;&amp; <span class="title">phi</span></span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> fv::ddtScheme&lt;Type&gt;::New <span class="comment">//根据变量名返回tmp&lt;ddtScheme&lt;Type&gt;&gt;的临时对象</span></span><br><span class="line">    (</span><br><span class="line">        U.mesh(),</span><br><span class="line">        U.mesh().ddtScheme(<span class="string">"ddt("</span> + U.name() + <span class="string">')'</span>)</span><br><span class="line">    ).ref().fvcDdtPhiCorr(U, phi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里涉及到RTS机制，</span></span><br><span class="line"><span class="comment">//为了简化，参考steadyState和经典的Euler格式是怎么做的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/ddtSchemes/steadyStateDdtScheme/steadyStateDdtScheme.C +305</span></span><br><span class="line"><span class="comment">//steadyState返回的是0，无修正，这很正常。</span></span><br><span class="line"><span class="comment">//返回值的量纲是：phi.dimensions()/dimTime</span></span><br><span class="line"><span class="comment">//对于不可压缩流应该是L^3/T^2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;typename steadyStateDdtScheme&lt;Type&gt;::fluxFieldType&gt;</span></span><br><span class="line"><span class="class"><span class="title">steadyStateDdtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCorr</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;fluxFieldType&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> fluxFieldType</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"ddtCorr("</span> + U.name() + <span class="string">','</span> + phi.name() + <span class="string">')'</span>,</span><br><span class="line">                mesh().time().timeName(),</span><br><span class="line">                mesh()</span><br><span class="line">            ),</span><br><span class="line">            mesh(),</span><br><span class="line">            dimensioned&lt;<span class="keyword">typename</span> flux&lt;Type&gt;::type&gt;</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"0"</span>,</span><br><span class="line">                phi.dimensions()/dimTime,</span><br><span class="line">                Zero</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Euler格式的修正</span></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/ddtSchemes/EulerDdtScheme/EulerDdtScheme.C +534</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;typename EulerDdtScheme&lt;Type&gt;::fluxFieldType&gt;</span></span><br><span class="line"><span class="class"><span class="title">EulerDdtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCorr</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    dimensionedScalar rDeltaT = <span class="number">1.0</span>/mesh().time().deltaT(); <span class="comment">//时间增量的倒数</span></span><br><span class="line"></span><br><span class="line">    fluxFieldType phiCorr</span><br><span class="line">    (</span><br><span class="line">        phi.oldTime() - fvc::dotInterpolate(mesh().Sf(), U.oldTime())</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp&lt;fluxFieldType&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> fluxFieldType</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"ddtCorr("</span> + U.name() + <span class="string">','</span> + phi.name() + <span class="string">')'</span>,</span><br><span class="line">                mesh().time().timeName(),</span><br><span class="line">                mesh()</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">this</span>-&gt;fvcDdtPhiCoeff(U.oldTime(), phi.oldTime(), phiCorr)</span><br><span class="line">           *rDeltaT*phiCorr</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//涉及到fvcDdtPhiCoeff系数，继续查找，发现这个函数位于ddtScheme中。</span></span><br><span class="line"><span class="comment">//src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.C +151</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;surfaceScalarField&gt; <span class="title">ddtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCoeff</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phiCorr</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;surfaceScalarField&gt; tddtCouplingCoeff = scalar(<span class="number">1</span>)</span><br><span class="line">      - min</span><br><span class="line">        (</span><br><span class="line">            mag(phiCorr)</span><br><span class="line">           /(mag(phi) + dimensionedScalar(<span class="string">"small"</span>, phi.dimensions(), SMALL)),</span><br><span class="line">            scalar(<span class="number">1</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    surfaceScalarField&amp; ddtCouplingCoeff = tddtCouplingCoeff.ref();</span><br><span class="line"></span><br><span class="line">    surfaceScalarField::Boundary&amp; ccbf =</span><br><span class="line">        ddtCouplingCoeff.boundaryFieldRef();</span><br><span class="line"></span><br><span class="line">    forAll(U.boundaryField(), patchi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">        (</span><br><span class="line">            U.boundaryField()[patchi].fixesValue()</span><br><span class="line">         || isA&lt;cyclicAMIFvPatch&gt;(mesh().boundary()[patchi])</span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            ccbf[patchi] = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InfoInFunction</span><br><span class="line">            &lt;&lt; <span class="string">"ddtCouplingCoeff mean max min = "</span></span><br><span class="line">            &lt;&lt; gAverage(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMax(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMin(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tddtCouplingCoeff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以OpenFOAM的<code>ddtCorr</code>的算法如下：</p>
<ol>
<li>首先用过去时间的通量$\phi^{n-1}$和速度$U^{n-1}$估算通量的修正$\phi^{c}$。</li>
</ol>
<ol>
<li><script type="math/tex; mode=display">
\phi^{c} = \phi^{n-1} - U_f(U^{n-1})\cdot \mathbf S_f</script></li>
<li><p>计算ddt耦合系数$K_c$：</p>
<script type="math/tex; mode=display">
K_c = 1 - \min\left( \frac {|\phi^c|}{|\phi^{n-1}|+\epsilon}, 1\right)</script><p>同时，应该注意到，ddt耦合系数$K_c$是一个大于0的无量纲界面张量场！它的边界条件也被特殊地处理了，对于固定速度边界或cyclicAMI边界，它的值是0.</p>
</li>
<li><p>输出修正量$\phi^k = K_c\phi^c/\Delta t$</p>
</li>
</ol>
<p>但是为什么这么计算耦合系数$K_c$和通量$\phi^c$，我也不知道！ </p>
<ul>
<li><a href="https://www.cfd-online.com/Forums/openfoam-solving/60096-ddtphicorr.html#post516511" target="_blank" rel="noopener">cfd-online上一个叫eugene的id提到</a><code>ddtCorr</code>实质上是文献<sup><a href="#fn_19" id="reffn_19">19</a></sup>中的所谓Choi Correction，对应的原始文献是<sup><a href="#fn_20" id="reffn_20">20</a></sup> ，但发帖者认为<code>fvcDdtPhiCoeff = 1</code>时是完整的Choi Correction，但此时OpenFOAM会不稳定，所以用了一个经验性的<code>fvcDdtPhiCoeff()</code>函数来限制这个Choi Correction。</li>
</ul>
<h4 id="Jasak的搞法"><a href="#Jasak的搞法" class="headerlink" title="Jasak的搞法"></a>Jasak的搞法</h4><p>Jasak似乎玩了另外的花样。在foam-extend 4.0中，Jasak的icoFoam和OpenFOAM.org以及OpenFOAMplus的icoFoam就不一样了。</p>
<ul>
<li><p>Jasak的icoFoam把<code>UEqn</code>分成了<code>HUEqn</code>和<code>ddtUEqn</code>两部分：</p>
</li>
<li><ul>
<li><code>HUEqn</code>： 对流和扩散项</li>
<li><code>ddtUEqn</code>：非定常项；</li>
</ul>
</li>
<li><p>动量预测步：<code>HUEqn + ddtUEqn == -grad(p)</code></p>
</li>
<li><p>PISO循环中：<code>H</code>从<code>HUEqn.H()</code>中产生！与时间步完全无关。</p>
</li>
<li><p>速度更新：</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://github.com/Unofficial-Extend-Project-Mirror/foam-extend-foam-extend-4.0/blob/master/applications/solvers/incompressible/icoFoam/icoFoam.C +113</span></span><br><span class="line"><span class="comment">// Note: cannot call H(U) here because the velocity is not complete</span></span><br><span class="line"><span class="comment">// HJ, 22/Jan/2016</span></span><br><span class="line">U = <span class="number">1.0</span>/(aU + ddtUEqn.A())*</span><br><span class="line">(</span><br><span class="line">    U*aU - fvc::grad(p) + ddtUEqn.H()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Jasak 认为这使得代码更加清晰了（时间导数算子中完全去掉了<code>ddtPhiCorr</code>和<code>ddtCorr</code>）。而且<strong>完全消除了时间步和松弛因子对结果的影响</strong>。结果对比参考文献<sup><a href="#fn_17" id="reffn_17">17</a></sup></p>
<h4 id="投影法"><a href="#投影法" class="headerlink" title="投影法"></a>投影法</h4><p>另外一种选择是用投影法，参考文献<sup><a href="#fn_21" id="reffn_21">21</a></sup>。 投影法在同位网格上可以避免Rhie-Chow插值，从而避免这个<code>ddtCorr()</code>的问题。 他们也做了数值试验来观察这个质量通量修正项（mass flux correction term）对PISO算法的效果。发现扔掉这一项，PISO算法的耗散大大降低。</p>
<h4 id="OpenFOAMplus的搞法"><a href="#OpenFOAMplus的搞法" class="headerlink" title="OpenFOAMplus的搞法"></a>OpenFOAMplus的搞法</h4><p>OpenFOAMplus在v1706中的<code>ddtScheme</code>加入了一个<code>scalar ddtPhiCoeff_</code>的定义。从而使<code>ddtCorr()</code>的实现更加复杂化。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://develop.openfoam.com/Development/OpenFOAM-plus/blob/master/src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.H</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ddtScheme</span></span></span><br><span class="line"><span class="class">:</span></span><br><span class="line">    <span class="keyword">public</span> tmp&lt;ddtScheme&lt;Type&gt;&gt;::refCount</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protected data</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> fvMesh&amp; mesh_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- Input for fvcDdtPhiCoeff (-1 default)</span></span><br><span class="line">        scalar ddtPhiCoeff_; <span class="comment">//ebf654f2这个集成rhoPimpleAdiabaticFoam的提交中才出现的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>而此时更改为了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://develop.openfoam.com/Development/OpenFOAM-plus/blob/master/src/finiteVolume/finiteVolume/ddtSchemes/ddtScheme/ddtScheme.C +151</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">tmp</span>&lt;surfaceScalarField&gt; <span class="title">ddtScheme</span>&lt;Type&gt;:</span>:fvcDdtPhiCoeff</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; U,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phi,</span><br><span class="line">    <span class="keyword">const</span> fluxFieldType&amp; phiCorr</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    tmp&lt;surfaceScalarField&gt; tddtCouplingCoeff</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> surfaceScalarField</span><br><span class="line">        (</span><br><span class="line">            IOobject</span><br><span class="line">            (</span><br><span class="line">                <span class="string">"ddtCouplingCoeff"</span>,</span><br><span class="line">                U.mesh().time().timeName(),</span><br><span class="line">                U.mesh()</span><br><span class="line">            ),</span><br><span class="line">            U.mesh(),</span><br><span class="line">            dimensionedScalar(<span class="string">"one"</span>, dimless, <span class="number">1.0</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    surfaceScalarField&amp; ddtCouplingCoeff = tddtCouplingCoeff.ref();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ddtPhiCoeff_ &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ddtCouplingCoeff -= min</span><br><span class="line">        (</span><br><span class="line">            mag(phiCorr)</span><br><span class="line">           /(mag(phi) + dimensionedScalar(<span class="string">"small"</span>, phi.dimensions(), SMALL)),</span><br><span class="line">            scalar(<span class="number">1</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ddtCouplingCoeff =</span><br><span class="line">            dimensionedScalar(<span class="string">"ddtPhiCoeff"</span>, dimless, ddtPhiCoeff_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    surfaceScalarField::Boundary&amp; ccbf = ddtCouplingCoeff.boundaryFieldRef();</span><br><span class="line"></span><br><span class="line">    forAll(U.boundaryField(), patchi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">        (</span><br><span class="line">            U.boundaryField()[patchi].fixesValue()</span><br><span class="line">         || isA&lt;cyclicAMIFvPatch&gt;(mesh().boundary()[patchi])</span><br><span class="line">        )</span><br><span class="line">        &#123;</span><br><span class="line">            ccbf[patchi] = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InfoInFunction</span><br><span class="line">            &lt;&lt; <span class="string">"ddtCouplingCoeff mean max min = "</span></span><br><span class="line">            &lt;&lt; gAverage(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMax(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="string">" "</span> &lt;&lt; gMin(ddtCouplingCoeff.primitiveField())</span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tddtCouplingCoeff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样使得可以这个系数可以手工调整。</p>
<p>他们所引用的参考文献<sup><a href="#fn_22" id="reffn_22">22</a></sup> 暂时没找到全文</p>
<h3 id="关于p-pFinal的选择"><a href="#关于p-pFinal的选择" class="headerlink" title="关于p,pFinal的选择"></a>关于<code>p,pFinal</code>的选择</h3><p>仔细的哥们儿会发现simpleFoam里用的是<code>pEqn.solve()</code>，到了icoFoam, pisoFoam和pimpleFoam里用的就是<code>pEqn.solve(mesh.solver(p.select(piso/pimple.finalInnerIter())))</code>。</p>
<p>这里的区别，还是看代码吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/finiteVolume/cfdTools/general/solutionControl/pimpleControl/pimpleControlI.H +92</span></span><br><span class="line"><span class="comment">//最后一步内迭代，也就是最后一次用PISO求解压力且是非正交修正的最后一步时返回true，否则返回false</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Foam::pimpleControl::finalInnerIter() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">       corrPISO_ == nCorrPISO_</span><br><span class="line">    &amp;&amp; corrNonOrtho_ == nNonOrthCorr_ + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/OpenFOAM/fields/GeometricFields/GeometricField/GeometricField.C +985</span></span><br><span class="line"><span class="comment">//true，也就是最后一次迭代时返回名字`pFinal`，否则返回名字`p`</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>, <span class="title">template</span>&lt;class&gt; <span class="title">class</span> <span class="title">PatchField</span>, <span class="title">class</span> <span class="title">GeoMesh</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:word Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;::select</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">bool</span> final</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (final)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name() + <span class="string">"Final"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/OpenFOAM/matrices/solution/solution.C +353</span></span><br><span class="line"><span class="comment">// 返回name对应的solver controls dictionary</span></span><br><span class="line"><span class="keyword">const</span> Foam::dictionary&amp; Foam::solution::solver(<span class="keyword">const</span> word&amp; name) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info&lt;&lt; <span class="string">"Lookup solver for "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solvers_.subDict(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//src/finiteVolume/fvMatrices/fvMatrix/fvMatrixSolve.C +55</span></span><br><span class="line"><span class="comment">//按这个solverControls来解</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:SolverPerformance&lt;Type&gt; Foam::fvMatrix&lt;Type&gt;::solve</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; solverControls</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>结论：simpleFoam是稳态求解器，所以没有pFinal一说，所以用不着这套复杂的机制。</p>
<h3 id="关于收敛判据和求解控制"><a href="#关于收敛判据和求解控制" class="headerlink" title="关于收敛判据和求解控制"></a>关于收敛判据和求解控制</h3><p>对于不可压缩流动而言， 收敛判据只取决于两个问题，</p>
<ol>
<li>连续性方程是否得到满足，在多大程度上得到满足？<ol>
<li>OpenFOAM里是用<code>#include &quot;continuityErrs.H&quot;</code>来计算、记录和输出这一项的。<ol>
<li>程序开始时还需要用 <code>include &quot;initContinuityErrs.H&quot;</code> 初始化一下。</li>
<li>它用的是<code>phi</code>而不是<code>U</code></li>
<li>它会记录累计误差<code>cumulativeContErr</code>，全场流量平衡误差<code>globalContErr</code>，以及局部误差的和<code>sumLocalContErr</code>（最后一项几乎等价于速度场散度的L1模：$|\nabla\cdot U|_{L1}$）</li>
</ol>
</li>
<li>事实上这点比较简单，因为每次计算压力的时候都是力图使连续性方程得到满足的。</li>
<li>而且这一项与非定常项无关。</li>
</ol>
</li>
<li>动量方程在多大程度上得到满足：<ol>
<li>这点在OpenFOAM里是通过对动量方程的求解来满足的。</li>
<li>其实OpenFOAM并没有对其进行严格地度量（指L1, L2模这样的数学度量）。</li>
<li>对于稳态算法SIMPLE，看<strong>最终一步</strong>的动量方程的的<strong>初始残差</strong>；</li>
<li>对于非稳态算法（PISO, PIMPLE等）<strong>输出</strong>中的<strong>每个时间步最后一次外迭代</strong>时，动量方程的<strong>初始残差</strong>可以认为是一个度量，但是它并不完全一致和严格。<ol>
<li><strong>每个时间步</strong> 是因为非稳态算法一般是需要进行时间精确模拟的。如果这个时间步没有收敛，这个时间步就不对，并且会影响到下一个时间步。</li>
<li><strong>最后一次</strong> 是因为前面的算是中间过程，最后并不保存下来；</li>
<li><strong>外迭代</strong>是因为内迭代是解耦计算，有时候看上去残差很小，可能并没有卵用，一耦合残差又超级大。<ol>
<li>对SIMPLE对应着<code>simple.loop()</code></li>
<li>对PIMPLE对应着<code>pimple.loop()</code></li>
</ol>
</li>
<li><strong>初始残差</strong>是因为OpenFOAM输出的残差都是线性求解器输出的，而其中线性求解器输出的只有初始残差是和非线性残差是一致的。<ol>
<li>经过线性求解器的迭代，线性残差可能会很小，甚至到机器零；</li>
<li>但是这个解只有对初始解产生的矩阵系数是对的，如果把矩阵系数按照得到的解重新计算，得到的残差才算是非线性残差（严格说来也不完全一样，但是差不多啦）；</li>
<li>这个非线性残差小才算是收敛 ；</li>
<li>另外，即使非线性残差小不代表误差小；</li>
<li>时间步很大时，网格很粗时，即使残差为0，<strong>误差</strong>也可能很大；</li>
</ol>
</li>
<li>实际得到的解因为是最后一次外迭代完成之后的解，一般来说其非线性残差可能会比输出中的初始残差更小一些。但是这个数据并没有被计算和输出。</li>
</ol>
</li>
<li>参考<a href="https://chengdi123000.github.io/2018/01/04/OpenFOAM%E7%9A%84%E6%AE%8B%E5%B7%AE%E5%AE%9A%E4%B9%89/">OpenFOAM的残差定义</a></li>
</ol>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_1">
<sup>1</sup>. <a href="https://holzmann-cfd.de/publications/mathematics-numerics-derivations-and-openfoam" target="_blank" rel="noopener">MATHEMATICS, NUMERICS, DERIVATIONS AND OPENFOAM®</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. <strong>Patankar, S. V. and Spalding, D.B. (1972)</strong>, “A calculation procedure for heat, mass and momentum transfer in three-dimensional parabolic flows”, Int. J. of Heat and Mass Transfer, Volume 15, Issue 10, October 1972, Pages 1787-1806<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. <a href="https://mycourses.aalto.fi/pluginfile.php/458332/mod_folder/content/0/CHEM-E7160%20Pressure%20Correction%20Scheme.pdf?forcedownload=1" target="_blank" rel="noopener">Pressure Correction Scheme for Incompressible Fluid Flow </a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. S.V. Patankar. Numerical Heat Transfer and Fluid Flow. Hemisphere, 1980<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_5">
<sup>5</sup>. Caretto L.S., Gosman A.D., Patankar S.V., Spalding D.B. (1973) Two calculation procedures for steady, three-dimensional flows with recirculation. In: Cabannes H., Temam R. (eds) Proceedings of the Third International Conference on Numerical Methods in Fluid Mechanics. Lecture Notes in Physics, vol 19. Springer, Berlin, Heidelberg<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_6">
<sup>6</sup>. <a href="http://thevisualroom.com/poisson_for_pressure.html" target="_blank" rel="noopener">http://thevisualroom.com/poisson_for_pressure.html</a><a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_7">
<sup>7</sup>. Lee S L, Tzong R Y. Artificial pressure for pressure-linked equation[J]. International journal of heat and mass transfer, 1992, 35(10): 2705-2716.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_8">
<sup>8</sup>. <a href="http://dyfluid.com/RhieChow.html" target="_blank" rel="noopener">http://dyfluid.com/RhieChow.html</a><a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_9">
<sup>9</sup>. <a href="http://www4.ncsu.edu/eos/users/w/white/www/white/ma587/lec24.pdf" target="_blank" rel="noopener">Nonlinear Systems: Picard and Newton methods</a> <a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_10">
<sup>10</sup>. <a href="https://books.google.com/books?id=fvX_umNtz_cC&amp;lpg=PA514&amp;ots=qdoBREZy6u&amp;dq=%E6%8A%95%E5%BD%B1%E7%AE%97%E6%B3%95%20sIMPLE&amp;pg=PA514#v=onepage&amp;q=%E6%8A%95%E5%BD%B1%E7%AE%97%E6%B3%95%20sIMPLE&amp;f=false" target="_blank" rel="noopener">林建忠，《流体力学》</a><a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_11">
<sup>11</sup>. DISCUSSION ON MOMENTUM INTERPOLATION METHOD FOR COLLOCATED GRIDS OF INCOMPRESSIBLE FLOW. Bo Yu, Wen-Quan Tao, Jin-Jia Wei, Yasuo Kawaguchi, Toshio Tagawa &amp; Hiroyuki Ozoe. Numerical Heat Transfer, Part B: Fundamentals Vol. 42 , Iss. 2,2002<a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_12">
<sup>12</sup>. <a href="http://web.stanford.edu/class/cs205b/lectures/lecture16.pdf" target="_blank" rel="noopener">CS205b/CME306 Lecture 16</a><a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_13">
<sup>13</sup>. <a href="http://www.fem.unicamp.br/~im450/palestras&amp;artigos/CFD of Turbulence_Chalmers_Un/chapter_6-1.pdf" target="_blank" rel="noopener">Collocated grids </a><a href="#reffn_13" title="Jump back to footnote [13] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_14">
<sup>14</sup>. <a href="http://www.math.ucla.edu/~wotaoyin/splittingbook/ch3-macnamara-strang.pdf" target="_blank" rel="noopener">Operator Splitting</a><a href="#reffn_14" title="Jump back to footnote [14] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_15">
<sup>15</sup>. Issa, R. I. (1986). Solution of the implicitly discretised fluid flow equations by operator-splitting. <em>Journal of computational physics</em>, <em>62</em>(1), 40-65.<a href="#reffn_15" title="Jump back to footnote [15] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_16">
<sup>16</sup>. Van Doormaal, J. P., &amp; Raithby, G. D. (1984). Enhancements of the SIMPLE method for predicting incompressible fluid flows. <em>Numerical heat transfer</em>, <em>7</em>(2), 147-163.<a href="#reffn_16" title="Jump back to footnote [16] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_17">
<sup>17</sup>. <a href="http://foam-u.fr/wp-content/uploads/2017/02/Invited_1stOFDayFrance_Jasak.pdf" target="_blank" rel="noopener">Numerics Improvements and Validation Results: FOAM-Extend Update on Work-in-Progress</a><a href="#reffn_17" title="Jump back to footnote [17] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_18">
<sup>18</sup>. Moukalled, F., Mangani, L., &amp; Darwish, M. (2016). The finite volume method in computational fluid dynamics.<a href="#reffn_18" title="Jump back to footnote [18] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_19">
<sup>19</sup>. <a href="http://nht.xjtu.edu.cn/paper/en/2002206.pdf" target="_blank" rel="noopener">Yu, B., Tao, W. Q., Wei, J. J., Kawaguchi, Y., Tagawa, T., &amp; Ozoe, H. (2002). Discussion on momentum interpolation method for collocated grids of incompressible flow. <em>Numerical Heat Transfer: Part B: Fundamentals</em>, <em>42</em>(2), 141-166.</a><a href="#reffn_19" title="Jump back to footnote [19] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_20">
<sup>20</sup>. S. K. Choi, Note on the Use of Momentum Interpolation Method for Unsteady Flows, Numer. Heat Transfer A, vol. 36, pp. 545-550, 1999.<a href="#reffn_20" title="Jump back to footnote [20] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_21">
<sup>21</sup>. Vuorinen, V., Keskinen, J. P., Duwig, C., &amp; Boersma, B. J. (2014). On the implementation of low-dissipative Runge–Kutta projection methods for time dependent flows using OpenFOAM®. <em>Computers &amp; Fluids</em>, <em>93</em>, 153-163.<a href="#reffn_21" title="Jump back to footnote [21] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_22">
<sup>22</sup>. Knacke, T. (2013). Potential effects of Rhie &amp; Chow type interpolations in airframe noise simulations. In: Schram, C., Dénos, R., Lecomte E. (ed):   Accurate and efficient aeroacoustic prediction approaches for  airframe noise, VKI LS 2013-03.<a href="#reffn_22" title="Jump back to footnote [22] in the text."> &#8617;</a>
</blockquote>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>如果觉得此文不错，欢迎大爷/姐姐打赏</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="程迪 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="程迪 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    程迪
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://chengdi123000.github.io/2018/01/05/OpenFOAM的不可压缩流算法/" title="OpenFOAM的不可压缩流算法">http://chengdi123000.github.io/2018/01/05/OpenFOAM的不可压缩流算法/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OpenFOAM/" rel="tag"># OpenFOAM</a>
          
            <a href="/tags/SIMPLE/" rel="tag"># SIMPLE</a>
          
            <a href="/tags/PISO/" rel="tag"># PISO</a>
          
            <a href="/tags/PIMPLE/" rel="tag"># PIMPLE</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/05/MASA的安装/" rel="next" title="MASA的安装">
                <i class="fa fa-chevron-left"></i> MASA的安装
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/05/rhoCentralFoam解析/" rel="prev" title="rhoCentralFoam解析">
                rhoCentralFoam解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.JPG"
                alt="程迪" />
            
              <p class="site-author-name" itemprop="name">程迪</p>
              <p class="site-description motion-element" itemprop="description">生活科研感悟</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chengdi123000" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:chengdi123000@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.linkedin.com/in/di-cheng-b7a20713" target="_blank" title="Linkedin">
                      
                        <i class="fa fa-fw fa-linkedin"></i>Linkedin</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/116932714936350117488" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/catdog_ustc" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/di.cheng.73" target="_blank" title="FB Page">
                      
                        <i class="fa fa-fw fa-facebook"></i>FB Page</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://stackoverflow.com/users/4592964/catdog" target="_blank" title="StackOverflow">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.youtube.com/channel/UC7Ae0mBH6gYSBoc2vPPUYVQ" target="_blank" title="YouTube">
                      
                        <i class="fa fa-fw fa-youtube"></i>YouTube</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/chengdi123000/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://cfl3d.cn" title="CFL3D研究" target="_blank">CFL3D研究</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://cfl3d.larc.nasa.gov" title="CFL3D" target="_blank">CFL3D</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.easycae.cn" title="EasyCAE" target="_blank">EasyCAE</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SIMPLE-PISO和PIMPLE算法"><span class="nav-text">SIMPLE, PISO和PIMPLE算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SIMPLE算法"><span class="nav-text">SIMPLE算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#压力联系方程之到底是哪个方程"><span class="nav-text">压力联系方程之到底是哪个方程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FAQ"><span class="nav-text">FAQ</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semi-Implicit-Method半隐式方法"><span class="nav-text">Semi-Implicit-Method半隐式方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于consistent"><span class="nav-text">关于consistent</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关于H1和H的区别"><span class="nav-text">关于H1和H的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rhie-Chow插值"><span class="nav-text">Rhie-Chow插值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面心速度的作用"><span class="nav-text">面心速度的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PISO算法"><span class="nav-text">PISO算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#其他-1"><span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#solutionControl及其子类的继承关系"><span class="nav-text">solutionControl及其子类的继承关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#松弛"><span class="nav-text">松弛</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PIMPLE算法"><span class="nav-text">PIMPLE算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PIMPLE里的三层循环"><span class="nav-text">PIMPLE里的三层循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些编程细节"><span class="nav-text">一些编程细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#solutionControl及其子类的变量命名规范"><span class="nav-text">solutionControl及其子类的变量命名规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#simpleFoam中phi变量的更新。"><span class="nav-text">simpleFoam中phi变量的更新。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于adjustPhi-和-setReference"><span class="nav-text">关于adjustPhi, 和 setReference</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方程多解问题：setReference"><span class="nav-text">方程多解问题：setReference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方程相容性问题：adjustPhi"><span class="nav-text">方程相容性问题：adjustPhi</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于constrainPressure和constrainHbyA"><span class="nav-text">关于constrainPressure和constrainHbyA</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#constrainPressure用于调整压力p的边界"><span class="nav-text">constrainPressure用于调整压力p的边界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constrainHbyA-tHbyA-U-p-用于返回调整后的tHbyANew变量"><span class="nav-text">constrainHbyA(tHbyA,U,p)用于返回调整后的tHbyANew变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于fvc-ddtCorr-和fvc-ddtPhiCorr"><span class="nav-text">关于fvc::ddtCorr()和fvc::ddtPhiCorr()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Jasak的搞法"><span class="nav-text">Jasak的搞法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#投影法"><span class="nav-text">投影法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OpenFOAMplus的搞法"><span class="nav-text">OpenFOAMplus的搞法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于p-pFinal的选择"><span class="nav-text">关于p,pFinal的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于收敛判据和求解控制"><span class="nav-text">关于收敛判据和求解控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">程迪</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://chengdis-blog.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://chengdi123000.github.io/2018/01/05/OpenFOAM的不可压缩流算法/';
          this.page.identifier = '2018/01/05/OpenFOAM的不可压缩流算法/';
          this.page.title = 'OpenFOAM的不可压缩流算法';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://chengdis-blog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>

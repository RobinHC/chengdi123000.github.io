<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冰水混合物</title>
  
  <subtitle>程迪的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chengdi123000.github.io/"/>
  <updated>2018-01-06T00:50:07.188Z</updated>
  <id>http://chengdi123000.github.io/</id>
  
  <author>
    <name>程迪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenFOAM在docker中的使用</title>
    <link href="http://chengdi123000.github.io/2018/01/05/OpenFOAM%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://chengdi123000.github.io/2018/01/05/OpenFOAM在docker中的使用/</id>
    <published>2018-01-05T08:16:30.000Z</published>
    <updated>2018-01-06T00:50:07.188Z</updated>
    
    <content type="html"><![CDATA[<p>利用docker在windows中使用OpenFOAM。利用共享文件夹功能在windows中进行前后处理。<br><a id="more"></a></p><h1 id="OpenFOAM在docker中的使用"><a href="#OpenFOAM在docker中的使用" class="headerlink" title="OpenFOAM在docker中的使用"></a>OpenFOAM在docker中的使用</h1><p>操作系统：windows 10 Pro/Home</p><p>docker版本：docker有两种，一种是社区版Community Edition，一种是商业版。我们采用免费的社区版，但是由于docker本质上是一个Linux程序，所以即使是社区版，在windows下使用时需要首先用虚拟机运行一个Linux平台（通常是Moby Linux），根据虚拟机平台的不同，也是有两种选择：</p><ul><li>docker for windows，这个版本是主推的版本，可以利用windows10的HyperV虚拟化平台。但是windows10需要Pro版或者旗舰版才能开启HyperV虚拟化。</li><li>docker toolbox，这个版本是比较老的，利用的是Oracle的VirtualBox进行虚拟化，但是可以在Windows10 Home版本下运行，或者在windows 7等老版本操作系统下运行。</li></ul><p>两个版本我都会介绍到。</p><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>下面分别介绍docker for windows和docker toolbox的安装</p><h3 id="docker-for-windows"><a href="#docker-for-windows" class="headerlink" title="docker for windows"></a>docker for windows</h3><p>对于可以开启HyperV虚拟化的windows 10 Pro或者旗舰版而言，docker for windows是最好的选择。</p><p>网址: <a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p><p>下载: <a href="https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe" target="_blank" rel="noopener">Docker for Windows Installer.exe</a></p><p>版本: Docker version 17.09.0, 社区版中的最新稳定版。</p><p>安装指南: <a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/</a></p><p>一路点击OK,next 安装完成后，运行<code>Docker for Windows</code>. 它会花费一些时间启动 <code>docker engine</code>. 等提示启动完成后，右键单击<code>开始</code>按钮，选择”Windows Powershell”。打开Powershell命令行。（用cmd也是可以的）</p><p>运行如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"><span class="comment">## Docker version 17.09.0-ce, build afdb6d4</span></span><br><span class="line">docker-compose --version</span><br><span class="line"><span class="comment">## docker-compose version 1.16.1, build 6d1ac219</span></span><br><span class="line">docker-machine --version</span><br><span class="line"><span class="comment">## docker-machine.exe version 0.12.2, build 9371605</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## Hello from Docker!</span></span><br><span class="line"><span class="comment">## This message shows that your installation appears to be working correctly.</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## To generate this message, Docker took the following steps:</span></span><br><span class="line"><span class="comment">##  1. The Docker client contacted the Docker daemon.</span></span><br><span class="line"><span class="comment">##  2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span></span><br><span class="line"><span class="comment">##     (amd64)</span></span><br><span class="line"><span class="comment">##  3. The Docker daemon created a new container from that image which runs the</span></span><br><span class="line"><span class="comment">##     executable that produces the output you are currently reading.</span></span><br><span class="line"><span class="comment">##  4. The Docker daemon streamed that output to the Docker client, which sent it</span></span><br><span class="line"><span class="comment">##     to your terminal.</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## To try something more ambitious, you can run an Ubuntu container with:</span></span><br><span class="line"><span class="comment">##  $ docker run -it ubuntu bash</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## Share images, automate workflows, and more with a free Docker ID:</span></span><br><span class="line"><span class="comment">##  https://cloud.docker.com/</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## For more examples and ideas, visit:</span></span><br><span class="line"><span class="comment">##  https://docs.docker.com/engine/userguide/</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment">## CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span></span><br><span class="line"><span class="comment">## 32a621d46d34        hello-world         "/hello"            24 seconds ago      Exited (0) 23 seconds ago                       clever_agnesi</span></span><br><span class="line">docker rm <span class="number">32</span>a621d46d34 <span class="comment">#change it to your container ID</span></span><br><span class="line"><span class="comment">## 32a621d46d34 </span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment">## CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span></span><br></pre></td></tr></table></figure><h3 id="docker-toolbox安装"><a href="#docker-toolbox安装" class="headerlink" title="docker toolbox安装"></a>docker toolbox安装</h3><p>网址和安装指南：<a href="https://docs.docker.com/toolbox/toolbox_install_windows/" target="_blank" rel="noopener">https://docs.docker.com/toolbox/toolbox_install_windows/</a></p><p>下载：<a href="https://download.docker.com/win/stable/DockerToolbox.exe" target="_blank" rel="noopener">https://download.docker.com/win/stable/DockerToolbox.exe</a></p><p>这个docker toolbox也要求至少是64位的windows 操作系统，win 7 以上。并且在BIOS中开启了虚拟化（Virtualization，和HyperV不同）</p><p>docker toolbox安装时会安装VirtualBox。</p><p>安装完成后会出现以下几个图标：</p><p><img src="https://docs.docker.com/toolbox/images/icon-set.png" alt=""></p><p>双击“Docker Quickestart”可以启动MSYS2 ，用如下命令进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"><span class="meta">#</span>Docker version 17.10.0-ce, build f4ffd25</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker-compose --version</span><br><span class="line"><span class="meta">#</span>docker-compose version 1.16.1, build 6d1ac219</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker-machine --version</span><br><span class="line"><span class="meta">#</span>docker-machine.exe version 0.13.0, build 9ba6da9</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Hello from Docker!</span><br><span class="line"><span class="meta">#</span>This message shows that your installation appears to be working correctly.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>To generate this message, Docker took the following steps:</span><br><span class="line"><span class="meta">#</span> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"><span class="meta">#</span> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span><br><span class="line"><span class="meta">#</span>    (amd64)</span><br><span class="line"><span class="meta">#</span> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line"><span class="meta">#</span>    executable that produces the output you are currently reading.</span><br><span class="line"><span class="meta">#</span> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line"><span class="meta">#</span>    to your terminal.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta">#</span> $ docker run -it ubuntu bash</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"><span class="meta">#</span> https://cloud.docker.com/</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>For more examples and ideas, visit:</span><br><span class="line"><span class="meta">#</span> https://docs.docker.com/engine/userguide/</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta">#</span>CONTAINER ID        IMAGE                                   COMMAND             CREATED             STATUS                         PORTS               NAMES</span><br><span class="line"><span class="meta">#</span>a8e15cba83b6        hello-world                             "/hello"            10 seconds ago      Exited (0) 10 seconds ago                          musing_hamilton</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker rm a8e15cba83b6</span><br><span class="line"><span class="meta">#</span>a8e15cba83b6</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta">#</span>CONTAINER ID        IMAGE                                   COMMAND             CREATED             STATUS                         PORTS               NAMES</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p>至此，docker就安装好了。</p><h2 id="下载OpenFOAM的-docker-image"><a href="#下载OpenFOAM的-docker-image" class="headerlink" title="下载OpenFOAM的 docker image"></a>下载OpenFOAM的 docker image</h2><p>很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker pull openfoamplus/of_v1706_centos73 # OF+</span><br><span class="line"><span class="meta">#</span> or</span><br><span class="line"><span class="meta">#</span> docker pull openfoam/openfoam5-paraview54 # OF5</span><br><span class="line"><span class="meta">#</span> list images</span><br><span class="line">docker image ls</span><br><span class="line"><span class="meta">#</span> REPOSITORY                       TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line"><span class="meta">#</span> hello-world                      latest              f2a91732366c        6 weeks ago         1.85kB</span><br><span class="line"><span class="meta">#</span> openfoamplus/of_v1706_centos73   latest              9b81f0cd518b        6 months ago        1.76GB</span><br></pre></td></tr></table></figure><h2 id="映射共享文件夹并测试OpenFOAM"><a href="#映射共享文件夹并测试OpenFOAM" class="headerlink" title="映射共享文件夹并测试OpenFOAM"></a>映射共享文件夹并测试OpenFOAM</h2><p>共享文件夹是与docker交换数据最方便的工具。windows下的docker可以通过虚拟机的功能配合docker工具自带的映射功能，实现映射共享文件夹的功能。为了避免问题过于复杂化，本文的共享文件夹位于<code>C:\Users\cheng</code>目录之下，这样可以避免对虚拟机的大幅变动。如果需要共享位于其他位置的文件夹，使用docker toolbox的请参考<a href="http://support.divio.com/local-development/docker/how-to-use-a-directory-outside-cusers-with-docker-toolbox-on-windows" target="_blank" rel="noopener">How to use a directory outside C:\Users with Docker Toolbox on Windows</a>，使用docker for windows的可以参考：<a href="https://rominirani.com/docker-on-windows-mounting-host-directories-d96f3f056a2c" target="_blank" rel="noopener">Docker on Windows — Mounting Host Directories</a></p><ul><li>docker for windows: 采用powershell</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cd c:\Users\cheng</span><br><span class="line"></span><br><span class="line">mkdir OpenFOAM</span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-i -t \</span><br><span class="line">--name myOFplus_1706 \</span><br><span class="line">-v <span class="string">"/c/Users/cheng/OpenFOAM:/home/ofuser/OpenFOAM"</span> \</span><br><span class="line">openfoamplus/of_v1706_centos73 \</span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的代码在进入bash后输入</span></span><br><span class="line">su ofuser</span><br><span class="line">cd </span><br><span class="line">mkdir -p <span class="variable">$FOAM_RUN</span></span><br><span class="line">run</span><br><span class="line">cp -r <span class="variable">$FOAM_TUTORIALS</span>/incompressible/icoFoam/cavity .</span><br><span class="line">./Allrun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要临时退出，但不中断执行</span></span><br><span class="line"><span class="comment"># 按Ctrl+p, Ctrl+q</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 再次进入docker image的bash</span></span><br><span class="line">docker attach myOFplus_1706</span><br></pre></td></tr></table></figure><ul><li>docker toolbox: 采用“Docker Quickestart”启动的仿bash界面。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cd c:\Users\cheng</span><br><span class="line"></span><br><span class="line">mkdir OpenFOAM</span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-i -t \</span><br><span class="line">--name myOFplus_1706 \</span><br><span class="line">-v "/c/Users/cheng/OpenFOAM:/home/ofuser/OpenFOAM" \</span><br><span class="line">openfoamplus/of_v1706_centos73 \</span><br><span class="line">bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 下面的代码在进入bash后输入</span><br><span class="line">su ofuser</span><br><span class="line">cd </span><br><span class="line">mkdir -p $FOAM_RUN</span><br><span class="line">run</span><br><span class="line">cp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity .</span><br><span class="line">./Allrun</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 想要临时退出，但不中断执行</span><br><span class="line"><span class="meta">#</span> 按Ctrl+p, Ctrl+q</span><br></pre></td></tr></table></figure><h2 id="docker-中的OpenFOAM环境"><a href="#docker-中的OpenFOAM环境" class="headerlink" title="docker 中的OpenFOAM环境"></a>docker 中的OpenFOAM环境</h2><p>以下命令在docker中可以查看出安装环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cd </span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">echo $WM_PROJECT_DIR #OpenFOAM安装位置</span><br><span class="line"><span class="meta">#</span>/opt/OpenFOAM/OpenFOAM-v1706</span><br><span class="line">echo $WM_THIRD_PARTY_DIR #第三方软件文件夹位置</span><br><span class="line"><span class="meta">#</span>/opt/OpenFOAM/ThirdParty-v1706</span><br><span class="line">echo $WM_PROJECT_VERSION</span><br><span class="line"><span class="meta">#</span>v1706</span><br><span class="line">echo $WM_PROJECT_USER_DIR #OpenFOAM用户文件夹位置</span><br><span class="line"><span class="meta">#</span>/home/ofuser/OpenFOAM/ofuser-v1706</span><br><span class="line"></span><br><span class="line">echo $WM_OPTIONS #编译配置</span><br><span class="line"><span class="meta">#</span>linux64GccDPInt32Opt </span><br><span class="line"><span class="meta">#</span>编译配置为</span><br><span class="line"><span class="meta">#</span> linux64:64位Linux版本</span><br><span class="line"><span class="meta">#</span> DP:双精度</span><br><span class="line"><span class="meta">#</span> Gcc: GCC编译器</span><br><span class="line"><span class="meta">#</span> Int32: 32位整型</span><br><span class="line"><span class="meta">#</span> Opt: 性能优化版本，没有调试信息。</span><br><span class="line"></span><br><span class="line">g++ --version #采用的编译器版本</span><br><span class="line"><span class="meta">#</span>g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-11)</span><br><span class="line"><span class="meta">#</span>Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line"><span class="meta">#</span>This is free software; see the source for copying conditions.  There is NO</span><br><span class="line"><span class="meta">#</span>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line">mpirun --version # 采用的mpi版本</span><br><span class="line"><span class="meta">#</span>mpirun (Open MPI) 1.10.4</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Report bugs to http://www.open-mpi.org/community/help/</span><br></pre></td></tr></table></figure><h1 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h1><p>可以用paraview 进行后处理</p><h2 id="paraview-安装"><a href="#paraview-安装" class="headerlink" title="paraview 安装"></a>paraview 安装</h2><ul><li>网址：<a href="https://www.paraview.org/" target="_blank" rel="noopener">https://www.paraview.org/</a></li><li>下载地址：<a href="https://www.paraview.org/paraview-downloads/download.php?submit=Download&amp;version=v5.4&amp;type=binary&amp;os=Windows&amp;downloadFile=ParaView-5.4.1-Qt5-OpenGL2-Windows-64bit.exe" target="_blank" rel="noopener">https://www.paraview.org/paraview-downloads/download.php?submit=Download&amp;version=v5.4&amp;type=binary&amp;os=Windows&amp;downloadFile=ParaView-5.4.1-Qt5-OpenGL2-Windows-64bit.exe</a></li><li>版本：最新稳定版：5.4.1</li></ul><p>安装很容易。</p><p>由于windows版本的paraview没有编译安装OpenFOAM专用reader，所以需要在shell中，位于算例文件目录下用<code>touch a.foam</code>建立一个文件（一些教程中的<code>touch a.OpenFOAM</code>无效）。</p><p>后处理结果如下：</p><p><img src="/images/U_mag_comparison.png" alt="U_mag_comparison"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用docker在windows中使用OpenFOAM。利用共享文件夹功能在windows中进行前后处理。&lt;br&gt;
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://chengdi123000.github.io/categories/OpenFOAM/"/>
    
    
      <category term="OpenFOAM" scheme="http://chengdi123000.github.io/tags/OpenFOAM/"/>
    
      <category term="docker" scheme="http://chengdi123000.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>OpenFOAM输出完整矩阵</title>
    <link href="http://chengdi123000.github.io/2018/01/04/OpenFOAM%E8%BE%93%E5%87%BA%E5%AE%8C%E6%95%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://chengdi123000.github.io/2018/01/04/OpenFOAM输出完整矩阵/</id>
    <published>2018-01-05T03:16:30.000Z</published>
    <updated>2018-01-06T01:14:11.248Z</updated>
    
    <content type="html"><![CDATA[<p>输出单CPU算例带耦合边界条件的fvScalarMatrix中的完整矩阵信息。<br><a id="more"></a></p><h1 id="OpenFOAM输出完整矩阵"><a href="#OpenFOAM输出完整矩阵" class="headerlink" title="OpenFOAM输出完整矩阵"></a>OpenFOAM输出完整矩阵</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>OpenFOAM采用的特殊矩阵模式导致输出完整矩阵很困难。本文尝试解决的是输出单CPU算例带耦合边界条件的问题中的fvScalarMatrix的问题。</p><p>首先，需要限定是单CPU，否则可能存在CPU间的processorFvPatch耦合界面边界条件，fvScalarMatrix将无法包含所有的边界条件相关的源项。</p><p>其次耦合边界条件中仅支持cyclic类边界条件，jumpCyclic边界条件可能存在线性代数上的一致性问题，暂时不考虑。</p><p>再次，输出限于fvScalarMatrix，fvVectorMatrix的情况类似，但是涉及到更加复杂一些的操作。</p><p>最后，采用<code>cnpy</code>库输出为numpy支持的npy或npz格式，便于进一步分析，具体模式为COO模式，同时<code>cnpy</code>还提供了npy2mat, npz2mat, mat2npz等工具用于与matlab交换数据。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>需要首先安装一个<code>cnpy</code>的小程序库，用于生成numpy和matlab可以直接读取的文件。</p><ul><li>网址: <a href="https://github.com/rogersce/cnpy" target="_blank" rel="noopener">https://github.com/rogersce/cnpy</a></li><li>命令行:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在root账户下</span></span><br><span class="line">yum install cmake git -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># `su ofuser`到ofuser账户， check tools</span></span><br><span class="line">cmake --version</span><br><span class="line">g++ --version</span><br><span class="line">git --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># clone, configure, build and install</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/rogersce/cnpy.git cnpy_src</span><br><span class="line"><span class="built_in">cd</span> cnpy_src</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DENABLE_STATIC=ON -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/lib/cnpy</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>实际程序中<code>#include</code>如下代码：<code>dumpFvScalarMatrix.H</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fvCFD.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cyclicFvPatch.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cnpy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">path: 想要储存的文件名</span></span><br><span class="line"><span class="comment">Eqn: fvScalarMatrix 的常量引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpFvScalarMatrix</span><span class="params">( <span class="keyword">const</span> fvScalarMatrix&amp; Eqn,fileName filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (filepath.hasExt() == <span class="literal">false</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      filepath = filepath.ext(<span class="string">"npz"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> label nCells = Eqn.diag().size();</span><br><span class="line"><span class="keyword">const</span> label nFaces = Eqn.lower().size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scalar* <span class="keyword">const</span> __restrict__ diagPtr = Eqn.diag().begin();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> label* <span class="keyword">const</span> __restrict__ uPtr = Eqn.lduAddr().upperAddr().begin();</span><br><span class="line"><span class="keyword">const</span> label* <span class="keyword">const</span> __restrict__ lPtr = Eqn.lduAddr().lowerAddr().begin();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scalar* <span class="keyword">const</span> __restrict__ upperPtr = Eqn.upper().begin();</span><br><span class="line"><span class="keyword">const</span> scalar* <span class="keyword">const</span> __restrict__ lowerPtr = Eqn.lower().begin();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;scalar&gt; AA(nCells+<span class="number">2</span>*nFaces);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;scalar&gt; S(nCells);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;scalar&gt; x0(nCells);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;label&gt; JR(nCells+<span class="number">2</span>*nFaces);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;label&gt; JC(nCells+<span class="number">2</span>*nFaces);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> psi=Eqn.psi();</span><br><span class="line">    <span class="keyword">auto</span> s=Eqn.source();</span><br><span class="line"></span><br><span class="line"><span class="comment">// diag</span></span><br><span class="line"><span class="keyword">for</span>(label cell=<span class="number">0</span>;cell&lt;nCells;cell++)</span><br><span class="line">&#123;</span><br><span class="line">AA[cell]=diagPtr[cell];</span><br><span class="line">JR[cell]=cell;</span><br><span class="line">JC[cell]=cell;</span><br><span class="line">         S[cell]=s[cell];</span><br><span class="line">         x0[cell]=psi[cell];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Upper</span></span><br><span class="line"><span class="keyword">for</span>(label face=<span class="number">0</span>;face&lt;nFaces;face++)</span><br><span class="line">&#123;</span><br><span class="line">AA[face+nCells]=upperPtr[face];</span><br><span class="line">JR[face+nCells]=uPtr[face];</span><br><span class="line">JC[face+nCells]=lPtr[face];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Lower</span></span><br><span class="line"><span class="keyword">for</span>(label face=<span class="number">0</span>;face&lt;nFaces;face++)</span><br><span class="line">&#123;</span><br><span class="line">AA[face+nCells+nFaces]=lowerPtr[face];</span><br><span class="line">JR[face+nCells+nFaces]=lPtr[face];</span><br><span class="line">JC[face+nCells+nFaces]=uPtr[face];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//边界贡献</span></span><br><span class="line">    <span class="keyword">auto</span> I = Eqn.internalCoeffs();</span><br><span class="line">    <span class="keyword">auto</span> B = Eqn.boundaryCoeffs();</span><br><span class="line">    <span class="keyword">auto</span> psib = psi.boundaryField();</span><br><span class="line">    forAll(psib,patchI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> fvPatch&amp; pp = psib[patchI].patch();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pp.coupled()) <span class="comment">//耦合边界</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(isA&lt;cyclicFvPatch&gt;(pp)) <span class="comment">//只处理循环边界</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">const</span> cyclicFvPatch&amp; pnp= (refCast&lt;<span class="keyword">const</span> cyclicFvPatch&gt;(pp)).neighbPatch();</span><br><span class="line">              forAll(pp,faceI)</span><br><span class="line">            &#123;</span><br><span class="line">                label cellI = pp.faceCells()[faceI];</span><br><span class="line">                label cellJ = pnp.faceCells()[faceI];</span><br><span class="line">                AA[cellI] += I[patchI][faceI];</span><br><span class="line">                AA.push_back(B[patchI][faceI]);</span><br><span class="line">                JR.push_back(cellI);</span><br><span class="line">                JC.push_back(cellJ);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//其他非循环边界的耦合边界，统统报错退出</span></span><br><span class="line">            &#123;</span><br><span class="line">              SeriousError&lt;&lt;<span class="string">"Only support cyclic coupled BC!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//非耦合边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            forAll(pp,faceI)</span><br><span class="line">            &#123;</span><br><span class="line">                label cellI = pp.faceCells()[faceI];</span><br><span class="line">                AA[cellI] += I[patchI][faceI];</span><br><span class="line">                S[cellI] += B[patchI][faceI];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cnpy::npz_save(filepath,<span class="string">"AA"</span>,&amp;AA[<span class="number">0</span>],&#123;AA.size()&#125;,<span class="string">"w"</span>);</span><br><span class="line">cnpy::npz_save(filepath,<span class="string">"JR"</span>,&amp;JR[<span class="number">0</span>],&#123;JR.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line">cnpy::npz_save(filepath,<span class="string">"JC"</span>,&amp;JC[<span class="number">0</span>],&#123;JC.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line">cnpy::npz_save(filepath,<span class="string">"S"</span>,&amp;S[<span class="number">0</span>],&#123;S.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line">cnpy::npz_save(filepath,<span class="string">"x0"</span>,&amp;x0[<span class="number">0</span>],&#123;x0.size()&#125;,<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="基于-icoFoam的源代码建立myIcoFoam"><a href="#基于-icoFoam的源代码建立myIcoFoam" class="headerlink" title="基于 icoFoam的源代码建立myIcoFoam"></a>基于 icoFoam的源代码建立myIcoFoam</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">run</span><br><span class="line">cd ..</span><br><span class="line">mkdir -p applications/solvers</span><br><span class="line">cd applications/solvers</span><br><span class="line"><span class="meta">#</span><span class="bash"> I put my solver here.</span></span><br><span class="line">pwd # /OF/OpenFOAM/-v1706/applications/solvers</span><br><span class="line">cp $FOAM_SOLVERS/incompressible/icoFoam -r .</span><br><span class="line">mv icoFoam myIcoFoam</span><br><span class="line">cd myIcoFoam</span><br><span class="line">mv icoFoam.C myIcoFoam.C</span><br><span class="line">sed -i s/icoFoam/myIcoFoam/g myIcoFoam.C</span><br><span class="line">sed -i s/icoFoam/myIcoFoam/g Make/files</span><br><span class="line">sed -i s/FOAM_APPBIN/FOAM_USER_APPBIN Make/files</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line">wmake</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> run</span></span><br><span class="line">run</span><br><span class="line">cd cavity</span><br><span class="line">foamJob -screen myIcoFoam</span><br></pre></td></tr></table></figure><h3 id="修改myIcoFoam的代码，输出pEqn的矩阵"><a href="#修改myIcoFoam的代码，输出pEqn的矩阵" class="headerlink" title="修改myIcoFoam的代码，输出pEqn的矩阵"></a>修改myIcoFoam的代码，输出pEqn的矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myIcoFoam.C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fvCFD.H"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pisoControl.H"</span></span></span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dumpFvScalarMatrix.H"</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">                  <span class="keyword">if</span> (piso.finalNonOrthogonalIter())</span><br><span class="line">                &#123;</span><br><span class="line">                    phi = phiHbyA - pEqn.flux();</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">//添加</span></span><br><span class="line"><span class="keyword">if</span> (runTime.timeIndex()==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">Info&lt;&lt; <span class="string">"TimeIndex = 2, output matrix pEqn"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">dumpFvScalarMatrix(pEqn,<span class="string">"Eqn.npz"</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Make/options 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -I$(LIB_SRC)/finiteVolume/lnInclude \</span><br><span class="line">    -I$(LIB_SRC)/meshTools/lnInclude \</span><br><span class="line">    -I$(HOME)/lib/cnpy/include </span><br><span class="line"></span><br><span class="line">EXE_LIBS = \</span><br><span class="line">    -lfiniteVolume \</span><br><span class="line">    -lmeshTools \</span><br><span class="line">    -Wl,-rpath -Wl,$(HOME)/lib/cnpy/lib -L$(HOME)/lib/cnpy/lib -lcnpy</span><br></pre></td></tr></table></figure><h3 id="python后处理"><a href="#python后处理" class="headerlink" title="python后处理"></a>python后处理</h3><p>python需要安装scipy，在docker下比较简单的方法是到root账户下进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进root账户</span></span><br><span class="line">cd</span><br><span class="line">curl "https://bootstrap.pypa.io/get-pip.py" -o "get-pip.py"</span><br><span class="line">python get-pip.py</span><br><span class="line">pip install scipy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回到ofuser账户</span></span><br><span class="line">su ofuser</span><br><span class="line">cd</span><br><span class="line">python -c "import scipy as sp;print(sp.version.version)"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.0.0</span></span><br></pre></td></tr></table></figure><p>python后处理代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br><span class="line">data = np.load(<span class="string">"Eqn.npz"</span>)</span><br><span class="line"></span><br><span class="line">AA,JR,JC,S,x0 = data[<span class="string">'AA'</span>],data[<span class="string">'JR'</span>],data[<span class="string">'JC'</span>],data[<span class="string">'S'</span>],data[<span class="string">'x0'</span>]</span><br><span class="line">N = S.shape[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> coo_matrix</span><br><span class="line">sm = coo_matrix((AA,(JR,JC)),shape=(N,N))</span><br><span class="line">m = sm.toarray()</span><br><span class="line"><span class="keyword">print</span> m.shape</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://sssslide.com/www.slideshare.net/fumiyanozaki96/openfoam-32087641" target="_blank" rel="noopener">OpenFOAM －空間の離散化と係数行列の取り扱い（Spatial Discretization and Coefficient Matrix）－byFumiya Nozaki</a>中的第38页。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输出单CPU算例带耦合边界条件的fvScalarMatrix中的完整矩阵信息。&lt;br&gt;
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://chengdi123000.github.io/categories/OpenFOAM/"/>
    
    
  </entry>
  
  <entry>
    <title>OpenFOAM的耦合边界处理</title>
    <link href="http://chengdi123000.github.io/2018/01/04/OpenFOAM%E7%9A%84%E8%80%A6%E5%90%88%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86/"/>
    <id>http://chengdi123000.github.io/2018/01/04/OpenFOAM的耦合边界处理/</id>
    <published>2018-01-05T00:19:44.000Z</published>
    <updated>2018-01-05T15:37:45.779Z</updated>
    
    <content type="html"><![CDATA[<p>关于OpenFOAM中耦合边界的具体实现</p><a id="more"></a><h1 id="OpenFOAM的耦合边界处理"><a href="#OpenFOAM的耦合边界处理" class="headerlink" title="OpenFOAM的耦合边界处理"></a>OpenFOAM的耦合边界处理</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>首先，在计算机里，大量的矩阵其实是稀疏矩阵，而矩阵的表示方式都是非零元素（non-zero elements）和索引（index，即元素所在行列号，本文按照c语言的约定，从0开始）分开的。这是稀疏矩阵算法的特殊性，所以指明OpenFOAM中的矩阵时，需要同时制定非零元素的存放之处和索引的存放之处。</p><p>而常见的稀疏矩阵的表示方式有：</p><ol><li><p>序列对角模式：对于对角阵而言，如果是按照对角顺序储存非零元素，可以无需储存索引；</p></li><li><p>坐标对角模式：对于对角阵而言，如果没有按照对角顺序储存非零元素，需要一列坐标指定对角元素顺序；</p></li><li><p>COO坐标模式：有三列数组，一列储存非零元素，一列储存行号，一列储存列号，是最广义可用的稀疏矩阵储存模式，但是往往有信息的冗余；</p></li><li><p>CSR/CSC压缩行/列模式：一列储存非零元素（先从上到下行号递增，再从左到右列号递增），一列储存行号，一列储存压缩后的列号，这也是OpenFOAM的<code>lduAddress</code>类实际采用的储存格式；</p></li><li><p>Banded，带状储存模式：对于带状结构，可以采用此种模式，对于一维问题，矩阵一般来说都是带状的，但是对于三维问题，很难是窄带结构的；</p></li></ol><p>实际上，OpenFOAM采用的是一种极为特殊的分割储存的COO模式，常见教材称之为LDU分裂模式，常记为$A=L+D+U$，其中$L,D,U$分别代表矩阵$A$的下三角部分（行号大于列号），对角部分和上三角部分（行号小于列号）。但是其实它远比上述LDU分裂（或者称之为LDU加法分解，注意与矩阵的LU乘法分解的区别）要复杂得多。</p><h2 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h2><p>首先引入以下记号和符号：</p><ul><li><p>$N_i$，第i个处理器中的单元数，$\sum_i {N_i} = N$为单元总数。由于OpenFOAM是cell-center based FVM，所以$N$就是求解的自由度数，也就是待求解变量集合$x$的维度；</p><ul><li><p>同理，$x$也可以视为各个处理器上待求解变量$x<em>i$的垂直连接（vertical concatenation）$x=x_0||x_1||x_2||x_3||\dots||x</em>{N-1}$</p></li><li><script type="math/tex; mode=display">x= \begin{bmatrix}     x_0\\    x_1\\    \vdots\\    x_i\\    \vdots\\    x_{N-1}     \end{bmatrix}</script></li></ul></li><li><p>$F_i$为第i个处理器中的总面数（一般等于网格中的owner数），$K_i$为内部面数（一般等于网格中的neighbour数），$P_i$为边界面数（$F_i=K_i+P_i$）</p><ul><li>但是边界面分为两种，耦合边界（coupled BC, 在OpenFOAM中等价于interface，<code>fvPatch::coupled()</code>返回<code>true</code>）和非耦合边界（普通边界），第i个处理器中的第c号耦合边界的面数记为$ C<em>{i,c}$，第r号普通边界的面数记为$R</em>{i,r}$。</li><li>耦合边界和普通边界的相同点和区别在于，他们都有一些面，实现为<code>patchField()</code>，每个面的owner对应的内部单元<code>internalField()</code>，但是普通边界的面外侧没有单元，而耦合边界外侧是它所对应的另一个耦合边界，在实现的时候记为<code>neighbPatch()</code>， <code>neighbPatch</code> 是有内部单元的，这些<code>neighbPatch</code>的内部单元在原耦合边界中实现为<code>patchNeighbourField()</code></li><li>有了<code>internalField()</code>和<code>patchNeighbourField()</code>，耦合边界的处理起来很多时候其实就和内部边界面差不多了。</li><li>网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。</li><li>简单的情况下（没有AMI, ACMI等复杂的边界条件时），整个问题总的面数为$F=\sum<em>i{F_i}-\sum</em>{i}\sum<em>c{C</em>{i,c}}$</li></ul></li><li><p>记总的矩阵为$A$，大小为$N\times N$，按处理器可以分裂为$A<em>i$和耦合系数矩阵$I^C</em>{i,c}$和$B^C_{i,c}$。排列如下：</p></li><li><script type="math/tex; mode=display">A= \begin{bmatrix}     A_0 & 0\\   0 &A_1 & 0 \\ 0 &0 & A_2 & 0\\   0 &\vdots &\vdots &\vdots  \\   0 &\dots & \dots &\dots &A_i &0 \\   0 &\dots &\dots &\dots &\dots &A_{N-1}     \end{bmatrix} + O</script><ul><li>$A_i=L_i+D_i+U_i+I_i$，采用LDU分裂模式表示。</li><li>$O$表示Off diagonal部分，也就是不在LDU分裂模式表示范围内的，和处理器之间的耦合边界的系数</li></ul></li><li><p>源项为$s$，同理也可以按处理器分裂为$s_i$。</p></li><li><p>总体的方程为$A\cdot x=s$，展开之后应该是$L+D+U$</p></li><li><p>但是在每个处理器上为$A<em>i\cdot x_i  = A’_i\cdot x-\sum</em>{j}\sum<em>c{B^C</em>{j,c}x^0_j}= s_i $</p><ul><li>$A<em>i = A’_i+\sum I^N = L_i+D_i+U_i+I^N</em>{i,c}$</li><li>网格中每个Patch中的边界面的编号连续排列的，这样可以减少边界面索引的储存量。</li></ul></li></ul><h2 id="各种情况下的矩阵组成"><a href="#各种情况下的矩阵组成" class="headerlink" title="各种情况下的矩阵组成"></a>各种情况下的矩阵组成</h2><h3 id="单一处理器无耦合边界情况"><a href="#单一处理器无耦合边界情况" class="headerlink" title="单一处理器无耦合边界情况"></a>单一处理器无耦合边界情况</h3><p>单一处理器，无耦合边界，仅有普通边界。</p><p>此时方程$A\cdot x= s$可分解为：</p><p>$[L+(D+\sum_n{I^N_n})+U]\cdot x = s’ + \sum_n{ b^N_n}$</p><p>其中$L,D,U$的非零元素为<code>lduMatrix</code>中储存的<code>lower_, diag_, upper_</code>，$D$采用序列对角模式进行索引，没有索引，$L,D$采用COO模式，其索引分别为<code>[lduAddr().lowerAddr(), lduAddr().upperAddr()]</code>和 <code>[lduAddr().upperAddr(), lduAddr().lowerAddr()]</code>；</p><p>$I^N<em>n,b^N_n$的非零元素分别为<code>fvMatrix&lt;T&gt;</code>中储存的`internalCoeffs</em>, boundaryCoeffs_<code>，分为若干patch进行索引，其中$I^N_n$是矩阵，采用坐标对角索引模式，对于编号</code>n<code>的索引为：</code>fvm.psi().lduAddr().patchAddr(n)<code>。而$b^N_n$是向量，但并非顺序排列的，也具有索引，索引也是</code>fvm.psi().lduAddr().patchAddr(n)`。</p><p>$s’$是内部离散和物理源汇产生的源项；</p><h3 id="单一处理器有耦合边界情况"><a href="#单一处理器有耦合边界情况" class="headerlink" title="单一处理器有耦合边界情况"></a>单一处理器有耦合边界情况</h3><p>单一处理器的耦合边界通常为cyclic循环边界条件。</p><p>此时方程$A\cdot x= s$可分解为：</p><p>$[L+(D+\sum_n{I^N_n}+\sum_c{I^C_c})+U]\cdot x = s’ + \sum_n{b^N_n}+\sum_c{ B^C_c} T_c(x^0)$</p><p>其中增加的$I^C<em>c, B^C_c$的非零元素依然是储存为<code>fvMatrix&lt;T&gt;</code>中的`internalCoeffs</em>, boundaryCoeffs_<code>，分为若干patch进行索引，其中$I^C_c$和$I^N_n$没有本质差别，对于编号为n的patch的索引为</code>fvm.psi().lduAddr().patchAddr(n)`。</p><p>但 $B^C_c$和 $b^N_n$ 的差别较大，一个是矩阵，一个是向量，二者量纲也不相同！$B^C_c$的索引包括行列两个索引，其中行索引还是<code>fvm.psi().lduAddr().patchAddr(n)</code>，列索引则是<code>neighbPatch().faceCells()</code></p><p>而$T_c$ 则是element wise的坐标变换矩算子，对于$x$为标量的情形，$T_c$的作用就是单位阵。</p><p>但是$T_c$的作用可以非常复杂，比如fixedJump条件就还涉及到$x^0$ 的平移。（但是此时存在一些问题，比如0场的Amul()作用之后非0。）</p><p>$x^0$表示$x$ 的旧值。</p><h3 id="多处理器存在耦合边界的情况"><a href="#多处理器存在耦合边界的情况" class="headerlink" title="多处理器存在耦合边界的情况"></a>多处理器存在耦合边界的情况</h3><p>多处理器的耦合边界通常为processor边界条件。</p><p>此时方程$A\cdot x= s$可分解在每个处理器i上：</p><p>$[L<em>i+(D_i+\sum_n{I^N</em>{i,n}}+\sum<em>c{I^C</em>{i,c}})+U<em>i]\cdot x_i = s’_i + \sum_n{b^N</em>{i,n}}+\sum<em>c{ B^C</em>{i,c}} T_{ji,c}(x^0_j)$</p><p>注意，下标中含$i​$的量才储存在processor i的内存中。$x^0_j,j\ne i​$的访问需要通信。</p><h2 id="一些奇怪的情形"><a href="#一些奇怪的情形" class="headerlink" title="一些奇怪的情形"></a>一些奇怪的情形</h2><p><code>lduMatrix</code>中定义的<code>Amul</code>, <code>Tmul</code>和<code>residual</code>函数采用的约定和常规数学教科书不同。</p><ul><li>理论上<code>Amul</code>应该定义了$A\cdot x = (L+D+U)\cdot x ​$操作。实际上它定义的是$[L+D+U]\cdot x - \sum_c{ B^C_c} T_c(x) ​$操作，我猜这样是便于和$s​$源项直接比较。实际上A的定义应该是$L+D+U-  \sum_c{ B^C_c} T_c​$ 。</li><li><code>Tmul</code>同理，不过把$B^C_c​$的非零元素换成了$I^C_c​$的非零元素。</li><li><code>residual</code>的约定是$s-A\cdot x$，而不是反过来。 </li></ul><p>另外，<code>fvMatrix</code>和<code>lduMatrix</code>对方程组的定义是有差别的。<code>lduMatrix::solve()</code>求解时给定了$L,D,U$，并传入源项$s$和边界系数$B^C_c$，求解的是$[L+D+U]\cdot x = s+\sum_c{ B^C_c} T_c(x)$。</p><p>但<code>fvMatrix::solveSegregated()</code>求解时，会调用<code>lduMatrix::solve()</code>，但在调用之前，它修改了$D=D+\sum_n{I^N_n}+\sum_c{I^C_c}$和$s=s+ \sum_n{b^N_n}$ ，再传入新的源项和边界系数。</p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><div class="table-container"><table><thead><tr><th>符号</th><th>非零元素</th><th>含义</th><th>索引</th><th>大小</th></tr></thead><tbody><tr><td>$D_i$</td><td><code>fvm.diag()</code></td><td>非边界贡献的对角项</td><td>序列对角模式</td><td>$N_i$</td></tr><tr><td>$L_i$</td><td><code>fvm.lower()</code></td><td>非边界贡献的下三角阵</td><td>COO模式<code>fvm.lduAddr().[lowerAddr(), upperAddr()]</code></td><td>$K_i$</td></tr><tr><td>$U_i$</td><td><code>fvm.upper()</code></td><td>非边界贡献的上三角阵</td><td>COO模式 <code>fvm.lduAddr().[upperAddr(), lowerAddr()]</code></td><td>$K_i$</td></tr><tr><td>$s_i$</td><td><code>fvm.source()</code></td><td>非边界贡献的源项</td><td>序列对角模式</td><td>$N_i$</td></tr><tr><td>$I^N_{i,r}$</td><td><code>fvm.internalCoeffs()[r]</code></td><td>第r个普通边界的对角项贡献</td><td>坐标对角模式 <code>fvm.psi().lduAddr(). patchAddr(r)</code></td><td>$R_{i,r}$</td></tr><tr><td>$I^C_{i,r}$</td><td><code>fvm.internalCoeffs()[c]</code></td><td>耦合边界的对角项贡献</td><td>坐标对角模式 <code>fvm.psi().lduAddr(). patchAddr(c)</code></td><td>$C_{i,c}$</td></tr><tr><td>$b^N_{i,n}$</td><td><code>fvm.boundaryCoeffs()[r]</code></td><td>第r个普通边界的源项贡献</td><td>坐标模式向量 <code>fvm.psi().lduAddr().patchAddr(r)</code></td><td>$R_{i,r}$</td></tr><tr><td>$B^C<em>{i,c}T</em>{ji,c}(x^0_j)$</td><td>计算得到</td><td>第c个耦合边界的显式耦合源项贡献</td><td>同上，且<code>false==fvm.psi().boundaryField()[patchi].coupled()</code></td><td>$C_{i,c}$</td></tr><tr><td>$B^C_{i,c}$</td><td><code>fvm.boundaryCoeffs()[c]</code></td><td>第c个耦合边界的显式耦合源项贡献的系数</td><td>全局行为类似COO模式，行坐标为<code>fvm.psi().lduAddr().patchAddr(c)</code> 列坐标对cyclic BC 为 <code>neighbPatch().faceCells()</code> 对于processor BC 为另一个processor上的<code>fvm.psi().lduAddr().patchAddr(c)</code></td><td>$C_{i,c}$</td></tr><tr><td>$x^0_{j}$</td><td><code>fvm.psi(). boundaryField(). scalarInterfaces()[c]. patchNeighbourField()</code></td><td>第c个耦合边界另一侧的初值</td><td>序列对角模式</td><td>$C_{i,c}$</td></tr><tr><td>$T_{ji,c}$</td><td><code>forwardT()</code></td><td>第c个耦合边界的坐标变换算子，通常可表示为一个张量</td><td>这是Element Wise的操作。</td><td>3*3</td></tr></tbody></table></div><p>参考<code>http://sssslide.com/www.slideshare.net/fumiyanozaki96/openfoam-32087641</code>中的38页。</p><h3 id="fvMatrix-solveSegregated-基本结构"><a href="#fvMatrix-solveSegregated-基本结构" class="headerlink" title="fvMatrix::solveSegregated()基本结构"></a><code>fvMatrix::solveSegregated()</code>基本结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fvMatrix.H +397</span></span><br><span class="line"><span class="comment">//- Solve segregated returning the solution statistics.</span></span><br><span class="line"><span class="comment">//  Use the given solver controls</span></span><br><span class="line">SolverPerformance&lt;Type&gt; solveSegregated(<span class="keyword">const</span> dictionary&amp;); <span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fvMatrixSolve.C +102</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:SolverPerformance&lt;Type&gt; Foam::fvMatrix&lt;Type&gt;::solveSegregated</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; solverControls</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        Info.masterStream(<span class="keyword">this</span>-&gt;mesh().comm())</span><br><span class="line">            &lt;&lt; <span class="string">"fvMatrix&lt;Type&gt;::solveSegregated"</span></span><br><span class="line">               <span class="string">"(const dictionary&amp; solverControls) : "</span></span><br><span class="line">               <span class="string">"solving fvMatrix&lt;Type&gt;"</span></span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; psi =</span><br><span class="line">       <span class="keyword">const_cast</span>&lt;GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp;&gt;(psi_);</span><br><span class="line"></span><br><span class="line">    SolverPerformance&lt;Type&gt; solverPerfVec</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"fvMatrix&lt;Type&gt;::solveSegregated"</span>,</span><br><span class="line">        psi.name()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    scalarField saveDiag(diag());//复制原有的diag_，注意diag_是标量数组</span><br><span class="line"></span><br><span class="line">    Field&lt;Type&gt; source(source_);<span class="comment">//复制原有的source_，注意source_是Field&lt;Type&gt;数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point include the boundary source from the coupled boundaries.</span></span><br><span class="line">    <span class="comment">// This is corrected for the implict part by updateMatrixInterfaces within</span></span><br><span class="line">    <span class="comment">// the component loop.</span></span><br><span class="line">    <span class="comment">//源项中加入非耦合边界项，以及耦合边界项</span></span><br><span class="line">    <span class="comment">// s' = s + boundary source (including coupled BC's contribution)</span></span><br><span class="line">    <span class="comment">//注意这里是加！</span></span><br><span class="line">    addBoundarySource(source); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typename</span> Type::labelType validComponents</span><br><span class="line">    (</span><br><span class="line">        psi.mesh().<span class="keyword">template</span> validComponents&lt;Type&gt;()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (direction cmpt=<span class="number">0</span>; cmpt&lt;Type::nComponents; cmpt++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (validComponents[cmpt] == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//有时候有的分量不用求解。比如对称张量，球张量等</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy field and source</span></span><br><span class="line"></span><br><span class="line">        scalarField psiCmpt(psi.primitiveField().component(cmpt));//复制cmpt分量</span><br><span class="line">        <span class="comment">//加入对角项不区分耦合边界和非耦合边界</span></span><br><span class="line">        <span class="comment">//D' = D + I(边界对对角项的贡献)</span></span><br><span class="line">        addBoundaryDiag(diag(), cmpt);</span><br><span class="line"></span><br><span class="line">        scalarField sourceCmpt(source.component(cmpt));//源项cmpt分量</span><br><span class="line"></span><br><span class="line">        FieldField&lt;Field, scalar&gt; bouCoeffsCmpt</span><br><span class="line">        (</span><br><span class="line">            boundaryCoeffs_.component(cmpt)</span><br><span class="line">        );<span class="comment">//边界系数的cmpt分量：非耦合边界是源项，耦合边界是邻侧系数</span></span><br><span class="line"></span><br><span class="line">        FieldField&lt;Field, scalar&gt; intCoeffsCmpt</span><br><span class="line">        (</span><br><span class="line">            internalCoeffs_.component(cmpt)</span><br><span class="line">        );<span class="comment">//边界对角系数的cmpt分量</span></span><br><span class="line"></span><br><span class="line">        lduInterfaceFieldPtrsList interfaces =</span><br><span class="line">            psi.boundaryField().scalarInterfaces(); <span class="comment">//对于非耦合求解器，采用的是scalarInterfaces()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the initMatrixInterfaces and updateMatrixInterfaces to correct</span></span><br><span class="line">        <span class="comment">// bouCoeffsCmpt for the explicit part of the coupled boundary</span></span><br><span class="line">        <span class="comment">// conditions</span></span><br><span class="line">        <span class="comment">//先接收耦合边界发来的消息，然后把耦合边界内侧的值发出去。</span></span><br><span class="line">        <span class="comment">//根据几个实现来看，其实并不更改sourceCmpt</span></span><br><span class="line">        initMatrixInterfaces </span><br><span class="line">        (</span><br><span class="line">            bouCoeffsCmpt, <span class="comment">//用边界系数去update</span></span><br><span class="line">            interfaces, <span class="comment">//用那些耦合边界</span></span><br><span class="line">            psiCmpt, <span class="comment">//耦合时的初值</span></span><br><span class="line">            sourceCmpt, <span class="comment">//结果加入sourceCmpt中</span></span><br><span class="line">            cmpt <span class="comment">//指定cmpt分量</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新sourceCmpt的值</span></span><br><span class="line"><span class="comment">//sourceCmpt -= bouCoeffsCmpt*scalarReceiveBuf_</span></span><br><span class="line"><span class="comment">// s'' = s' - 耦合边界的源项贡献</span></span><br><span class="line"><span class="comment">//注意这里是减去</span></span><br><span class="line"><span class="comment">//此时源项s''中只剩下非耦合边界的贡献了。</span></span><br><span class="line">        updateMatrixInterfaces</span><br><span class="line">        (</span><br><span class="line">            bouCoeffsCmpt, <span class="comment">//用边界系数去update</span></span><br><span class="line">            interfaces,</span><br><span class="line">            psiCmpt,</span><br><span class="line">            sourceCmpt, <span class="comment">//结果加入sourceCmpt中</span></span><br><span class="line">            cmpt</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        solverPerformance solverPerf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Solver call</span></span><br><span class="line">        solverPerf = lduMatrix::solver::New</span><br><span class="line">        (</span><br><span class="line">            psi.name() + pTraits&lt;Type&gt;::componentNames[cmpt],</span><br><span class="line">            *<span class="keyword">this</span>,</span><br><span class="line">            bouCoeffsCmpt,</span><br><span class="line">            intCoeffsCmpt,</span><br><span class="line">            interfaces,</span><br><span class="line">            solverControls</span><br><span class="line">        )-&gt;solve(psiCmpt, sourceCmpt, cmpt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SolverPerformance&lt;Type&gt;::debug)</span><br><span class="line">        &#123;</span><br><span class="line">            solverPerf.print(Info.masterStream(<span class="keyword">this</span>-&gt;mesh().comm()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        solverPerfVec.replace(cmpt, solverPerf);</span><br><span class="line">        solverPerfVec.solverName() = solverPerf.solverName();</span><br><span class="line"></span><br><span class="line">        psi.primitiveFieldRef().replace(cmpt, psiCmpt);</span><br><span class="line">        diag() = saveDiag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    psi.correctBoundaryConditions();</span><br><span class="line"></span><br><span class="line">    psi.mesh().setSolverPerformance(psi.name(), solverPerfVec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solverPerfVec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于OpenFOAM中耦合边界的具体实现&lt;/p&gt;
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://chengdi123000.github.io/categories/OpenFOAM/"/>
    
    
      <category term="OpenFOAM" scheme="http://chengdi123000.github.io/tags/OpenFOAM/"/>
    
      <category term="coupledBC" scheme="http://chengdi123000.github.io/tags/coupledBC/"/>
    
  </entry>
  
  <entry>
    <title>OpenFOAM的残差定义</title>
    <link href="http://chengdi123000.github.io/2018/01/04/OpenFOAM%E7%9A%84%E6%AE%8B%E5%B7%AE%E5%AE%9A%E4%B9%89/"/>
    <id>http://chengdi123000.github.io/2018/01/04/OpenFOAM的残差定义/</id>
    <published>2018-01-05T00:19:44.000Z</published>
    <updated>2018-01-05T16:08:48.218Z</updated>
    
    <content type="html"><![CDATA[<p>关于OpenFOAM中残差定义的具体实现</p><a id="more"></a><h1 id="关于normFactor"><a href="#关于normFactor" class="headerlink" title="关于normFactor"></a>关于<code>normFactor</code></h1><p>根据代码，OpenFOAM求解器输出的标量残差initialResidual为量化的向量$L1$ 模。</p><p>定义为:</p><script type="math/tex; mode=display">Res = \frac{|r|_1}{normFactor}= \frac{|s-A\cdot x|_1}{|A\cdot x^0 - A\cdot W  \cdot x^0|_1+|s - A\cdot W\cdot x^0|_1+\epsilon}</script><p>其中$W$是有效权重矩阵</p><script type="math/tex; mode=display">W= \frac 1 N \begin{bmatrix}  1 & 1 & \dots &1 &1 \\1 & \vdots & \ddots &\vdots  & 1 \\1 & \dots & \dots & 1 & 1 \\\end{bmatrix}_{N\times N} =  \begin{bmatrix}  1 \\1 \\\vdots \\1\\1\end{bmatrix}_{N\times1} \times  \begin{bmatrix}  \frac 1 N & \frac 1 N & \dots &\frac 1 N &\frac 1 N \end{bmatrix} _{1\times N}\\=S\cdot M</script><p>$S$代表对矩阵行和算子，$M$ 代表对列向量的平均算子。</p><p>$\epsilon$是非常小量，OpenFOAM常定义为+1e-20。</p><p>向量$L1$模的定义为：$|x|_1= \sum_i{|x_i|}$</p><p>但是要做MMS比较需要用到函数的L1模：</p><script type="math/tex; mode=display">|r|_{L1}=\frac{\int_{\Omega}{|r|dx}}{\int_{\Omega}{dx}} \approx \frac{\sum_i{V_i |r|}}{\sum_i V_i}</script><p>与向量$L1$模相比，相差了一个单元体积的权重。</p><p>我想这部分解释了为何学术界的文章里残差收敛特别快，而OpenFOAM总是收敛到一定程度就收敛不下去了，因为OpenFOAM的残差采用的normFactor每次都在随$x^0​$变化，随着解的收敛，normFactor在减小，从而导致OpenFOAM输出的残差收敛速度降低。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PCG.C:107</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// --- Calculate normalised residual norm</span></span><br><span class="line">    solverPerf.initialResidual() =</span><br><span class="line">        gSumMag(rA, matrix().mesh().comm()) <span class="comment">//this is the vector L1 norm向量L1模</span></span><br><span class="line">       /normFactor;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//lduMatrixSolver.C:175</span></span><br><span class="line">Foam::scalar Foam::lduMatrix::solver::normFactor</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; psi,</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; source,</span><br><span class="line">    <span class="keyword">const</span> scalarField&amp; Apsi,</span><br><span class="line">    scalarField&amp; tmpField</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// --- Calculate A dot reference value of psi</span></span><br><span class="line">    matrix_.sumA(tmpField, interfaceBouCoeffs_, interfaces_); <span class="comment">//tmpField = A*S</span></span><br><span class="line"></span><br><span class="line">    tmpField *= gAverage(psi, matrix_.lduMesh_.comm()); <span class="comment">//tmpField = A*S*M*x0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// normFactor = |A*x0-A*S*M*x0|_1+|s-A*S*M*x0|_1+eps</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        gSum</span><br><span class="line">        (</span><br><span class="line">            (mag(Apsi - tmpField) + mag(source - tmpField))(),</span><br><span class="line">            matrix_.lduMesh_.comm()</span><br><span class="line">        )</span><br><span class="line">      + solverPerformance::small_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At convergence this simpler method is equivalent to the above</span></span><br><span class="line">    <span class="comment">// return 2*gSumMag(source) + solverPerformance::small_;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于OpenFOAM中残差定义的具体实现&lt;/p&gt;
    
    </summary>
    
      <category term="OpenFOAM" scheme="http://chengdi123000.github.io/categories/OpenFOAM/"/>
    
    
      <category term="OpenFOAM" scheme="http://chengdi123000.github.io/tags/OpenFOAM/"/>
    
      <category term="coupledBC" scheme="http://chengdi123000.github.io/tags/coupledBC/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://chengdi123000.github.io/2017/08/09/hello-world/"/>
    <id>http://chengdi123000.github.io/2017/08/09/hello-world/</id>
    <published>2017-08-09T10:07:25.000Z</published>
    <updated>2017-09-16T10:35:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hello World! </p><p>对公式、代码和插入图片进行测试。</p><a id="more"></a><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><ul><li>行内公式: $e^{\pi i}+1=0$</li><li>块公式:</li><li><script type="math/tex; mode=display">F=\frac{Gm_1m_2}{r^2}</script></li></ul><script type="math/tex; mode=display">F=\frac{Gm_1m_2}{r^2}</script><ul><li>关于$\rho$的连续性方程</li></ul><script type="math/tex; mode=display">\frac{\partial \rho}{\partial t}+\vec v\cdot\frac{\partial \rho}{\partial x}=0</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight fortran"><figcaption><span>CFL3D主程序中的Setup子程序声明</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">subroutine</span></span> setup(lw,lw2,w,mgwk,wk,nwork,iwk,iwork,itest,</span><br><span class="line">     .                 jtest,ktest,maxbl,mxbli,maxgr,maxseg,nsub1,</span><br><span class="line">     .                 maxxe,intmax,iitot,ncycmax,lwdat,lig,lbg,iovrlp,</span><br><span class="line">     .                 qb,nblock,iviscg,jdimg,kdimg,idimg,utrans,</span><br><span class="line">     .                 vtrans,wtrans,omegax,omegay,omegaz,xorig,</span><br><span class="line">     .                 yorig,zorig,dxmx,dymx,dzmx,dthxmx,dthymx,</span><br><span class="line">     .                 dthzmx,thetax,thetay,thetaz,rfreqt,rfreqr,</span><br><span class="line">     .                 xorig0,yorig0,zorig0,time2,thetaxl,thetayl,</span><br><span class="line">     .                 thetazl,itrans,irotat,idefrm,bcvali,bcvalj,</span><br><span class="line">     .                 bcvalk,nbci0,nbcidim,nbcj0,nbcjdim,</span><br><span class="line">     .                 nbck0,nbckdim,ibcinfo,jbcinfo,kbcinfo,bcfilei,</span><br><span class="line">     .                 bcfilej,bcfilek,ngrid,ncgg,nblg,iemg,inewgg,</span><br><span class="line">     .                 rms,clw,cdw,cdpw,cdvw,cxw,cyw,czw,cmxw,cmyw,</span><br><span class="line">     .                 cmzw,n_clcd,clcd,nblocks_clcd,blocks_clcd,</span><br><span class="line">     .                 chdw,swetw,fmdotw,cfttotw,cftmomw,cftpw,</span><br><span class="line">     .                 cftvw,rmstr,nneg,ntr,windex,</span><br><span class="line">     .                 ninter,iindex,nblkpt,dthetxx,dthetyy,dthetzz,</span><br><span class="line">     .                 iibg,kkbg,jjbg,ibcg,dxintg,dyintg,dzintg,iiig,</span><br><span class="line">     .                 jjig,kkig,ibpntsg,iipntsg,mblk2nd,nou,bou,nbuf,</span><br><span class="line">     .                 ibufdim,ireq_qb,igridg,bcfiles,mxbcfil,</span><br><span class="line">     .                 utrnsae,vtrnsae,wtrnsae,omgxae,omgyae,omgzae,</span><br><span class="line">     .                 xorgae,yorgae,zorgae,thtxae,thtyae,thtzae,</span><br><span class="line">     .                 rfrqtae,rfrqrae,icsi,icsf,jcsi,jcsf,</span><br><span class="line">     .                 kcsi,kcsf,freq,gmass,damp,x0,gf0,nmds,maxaes,</span><br><span class="line">     .                 aesrfdat,perturb,islavept,nslave,iskip,jskip,</span><br><span class="line">     .                 kskip,bmat,stm,stmi,gforcn,gforcnm,xxn,</span><br><span class="line">     .                 nsegdfrm,idfrmseg,iaesurf,maxsegdg,nmaster,</span><br><span class="line">     .                 aehist,timekeep,inpl3d,nplots,nplot3d,levelg,</span><br><span class="line">     .                 iadvance,xs,gforcs,xorgae0,yorgae0,zorgae0,</span><br><span class="line">     .                 icouple,lfgm,nblk,limblk,isva,nblelst,</span><br><span class="line">     .                 iskmax,jskmax,kskmax,ue,irdrea,nbli,nummem)</span><br><span class="line">#   ifdef <span class="built_in">CMPLX</span></span><br><span class="line">#   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">use</span> module_kwstm, <span class="keyword">only</span>:kws_init</span><br><span class="line">#   <span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h2 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h2><p>欢迎访问本博客：冰水混合物<br><img src="/images/qr_code_test.jpg" alt="冰水混合物"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hello World! &lt;/p&gt;
&lt;p&gt;对公式、代码和插入图片进行测试。&lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="http://chengdi123000.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="公式" scheme="http://chengdi123000.github.io/tags/%E5%85%AC%E5%BC%8F/"/>
    
      <category term="图形" scheme="http://chengdi123000.github.io/tags/%E5%9B%BE%E5%BD%A2/"/>
    
      <category term="测试" scheme="http://chengdi123000.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
